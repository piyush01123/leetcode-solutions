[{"id":"3216915","title":"Minimum Impossible OR","url":"/discuss/topic/3216915/first-missing-positive-bit-manipulation-easy-to-understand","questionTitle":"Minimum Impossible OR","post":{"creationDate":1677040948},"post_data":{"id":3216915,"title":"First missing positive + Bit manipulation [Easy to understand]","solutionTags":[{"name":"C++"}],"post":{"id":5030542,"content":"# Intuition\nThis problem seems similar to [First Missing Positive](https://leetcode.com/problems/first-missing-positive/). Here is a solution to that probelm:\n\n```\nint firstMissingPositive(vector<int>& nums) {\n    unordered_set<int> numSet(nums.begin(),nums.end());\n    int i = 1;\n    while (i <= nums.size()){\n        if (!numSet.count(i)) return i;\n        i++;\n    }\n    return i;\n}\n```\n# Observation\nOur solution is similar to the above in spirit. The crucial thing to notice is that if we have just powers of 2, we can construct all numbers upto the next power of 2 by their OR.\n\nFor example, given the array `[1,2,4,8,16]`, we can do `OR` between various elements to construct all numbers from 1 to 31. So the presence of other numbers in the middle like 3,5,6 etc. does not change the range of possible numbers. Hence these are the only ones that need to be checked.\n\n# Code\n```\nclass Solution {\npublic:\n    int minImpossibleOR(vector<int>& nums) \n    {\n        unordered_set<int> numSet(nums.begin(),nums.end());\n        int cur = 1;\n        while (cur<INT_MAX)\n        {\n            if (!numSet.count(cur)) return cur;\n            cur <<= 1;\n        }\n        return INT_MAX;\n    }\n};\n```","creationDate":1677040948}},"acRate":55.412433478471215,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"2568","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"minimum-impossible-or","topicTags":[],"hasSolution":false,"hasVideoSolution":false,"content":"<p>You are given a <strong>0-indexed</strong>&nbsp;integer array <code>nums</code>.</p>\n\n<p>We say that an integer x is <strong>expressible</strong> from <code>nums</code> if there exist some integers <code>0 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt; ... &lt; index<sub>k</sub> &lt; nums.length</code> for which <code>nums[index<sub>1</sub>] | nums[index<sub>2</sub>] | ... | nums[index<sub>k</sub>] = x</code>. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of <code>nums</code>.</p>\n\n<p>Return <em>the minimum <strong>positive non-zero integer</strong>&nbsp;that is not </em><em>expressible from </em><code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> 1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,3,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We can show that 1 is the smallest number that is not expressible.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"},{"id":"3216829","title":"4Sum","url":"/discuss/topic/3216829/k-sum-solution-explained","questionTitle":"4Sum","post":{"creationDate":1677038671},"post_data":{"id":3216829,"title":"K Sum solution explained","solutionTags":[{"name":"C++"}],"post":{"id":5030396,"content":"# Explanation\nWe will generalize 2-sum to K-Sum.\n\n## Revision of 2 Sum\nThere are two main ways to solve 2 Sum in $O(n)$ time. Let us look at both. We will not look at finding whether two sum exists but return all such pairs (with repitition if repititions are present). For the 2nd method, let us assume that the array was given to us in sorted order. We will talk about this assumption later.\n\n### 2 Sum using HashSet: $O(n)$ time, $O(n)$ space\n```\nvector<vector<int>> twoSum(vector<int>nums, target)\n{\n    vector<vector<int>> res;\n    unordered_set<int> complements;\n    for (int n: nums)\n    {\n        if (complements.count(n)) vec.push_back({target-n, target});\n        complements.insert(target-n);\n    }\n    return res;\n}\n```\n\n### 2 Sum using double pointer: $O(n)$ time, $O(1)$ space\n**Note:** We had assumed `nums` to be pre-sorted.\n```\nvector<vector<int>> twoSum(vector<int>nums, target)\n{\n    vector<vector<int>> res;\n    int lo=0, hi=nums.size()-1;\n    while(lo<hi)\n    {\n        int cur = nums[lo] + nums[hi];\n        if (cur==target)\n        {\n            res.push_back({nums[lo],nums[hi]});\n            lo++;\n            hi--;\n        }\n        else if (cur<target) lo++;\n        else hi--;\n    }\n    return res;\n}\n```\n\nNow to generalize this to K-Sum we can have a recursive function such that `KSum` for `K` will be created using `KSum` for `K-1`. When we reach `K=2` we will use the `twoSum` that we have written earlier.\n\nNow the crucial thing to note is that for `K=3,4,5,...` we will always have a situation where `TC` is at least $O(n^2)$, hence it makes sense to pre-sort array in $O(n\\log(n))$ time and use the 2nd method. It also helps in keeping track of unique subsets because otherwise we will have to sort the subset each time before adding to `res`.\n\n\n# Code\n```\n#define ll long long\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) \n    {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        return KSum(nums, target, 4, 0);\n    }\n    vector<vector<int>> KSum(vector<int>&nums, ll target, \\\n                             int K, int start)\n    {\n        if (start>=nums.size()) return {};\n        if (target<(ll)nums[start]*K || target>(ll)nums.back()*K) return {};\n        if (K==2) return twoSum(nums, target, start);\n        set<vector<int>> res;\n        for (int i=start; i<nums.size(); i++)\n        {\n            vector<vector<int>> kSumPrev = KSum(nums, target-nums[i], K-1, i+1);\n            for (auto subset: kSumPrev)\n            {\n                subset.push_back(nums[i]);\n                res.insert(subset);\n            }\n        }\n        return vector<vector<int>>(res.begin(),res.end());\n    }\n    vector<vector<int>> twoSum(vector<int>&nums, ll target, int start)\n    {\n        vector<vector<int>> res;\n        int lo=start, hi=nums.size()-1;\n        while(lo<hi)\n        {\n            ll cur = (ll)nums[lo] + nums[hi];\n            if (cur==target)\n            {\n                res.push_back({nums[lo],nums[hi]});\n                lo++;\n                hi--;\n            }\n            else if (cur<target) lo++;\n            else hi--;\n        }\n        return res;\n    }\n};\n```\n# Complexity\n`TC`: $O(n^3)$\n`SC`: $O(n)$","creationDate":1677038671}},"acRate":36.04422421890663,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"18","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"4sum","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>\n\t<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>\n\t<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0\n<strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2], target = 8\n<strong>Output:</strong> [[2,2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n"},{"id":"3216706","title":"Capacity To Ship Packages Within D Days","url":"/discuss/topic/3216706/binary-search-with-proper-explanation","questionTitle":"Capacity To Ship Packages Within D Days","post":{"creationDate":1677034577},"post_data":{"id":3216706,"title":"Binary search with proper explanation","solutionTags":[{"name":"C++"},{"name":"Binary Search"}],"post":{"id":5030218,"content":"# Intuition\\r\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\nWe need to find the minimum possible capacity that will work. So, we can think of the problem as a search problem with a test of whether it will work at a given capacity. If we want to find the answer in a range `[0,M]` then we can apply the test at `M/2` and if it works then we recurse in the lower half and if it does not work then we recurse in the upper half. In this way we can come up with a binary search.\\r\n\\r\n# Approach\\r\n<!-- Describe your approach to solving the problem. -->\\r\nTo create the test described above we need to write a function `bool possible(int capacity, int days, vector<int>&weights)` which will return `true` if it is possible and `false` if it is not possible to work with `capacity`. We will use this for binary search as described previously.\\r\n\\r\n\\r\n# Code\\r\n```\\r\nclass Solution {\\r\npublic:\\r\n    bool possible(int capacity, int days, vector<int>&weights)\\r\n    {\\r\n        int n=weights.size(), i=0, ctr=0;\\r\n        while(i<n)\\r\n        {\\r\n            if (weights[i]>capacity) return false;\\r\n            int cur = 0;\\r\n            while(i<n && cur+weights[i]<=capacity)\\r\n            {\\r\n                cur += weights[i];\\r\n                i++;\\r\n            }\\r\n            ctr ++;\\r\n        }\\r\n        return (ctr<=days);\\r\n    }\\r\n    int shipWithinDays(vector<int>& weights, int days) \\r\n    {\\r\n        int lo=0, hi=INT_MAX;\\r\n        while (lo<=hi)\\r\n        {\\r\n            int mid = lo + (hi-lo)/2;\\r\n            if (possible(mid, days, weights)) hi = mid-1;\\r\n            else lo = mid+1;\\r\n        }\\r\n        return lo;\\r\n    }\\r\n};\\r\n```\\r\n\\r\n# Complexity\\r\n- Time complexity: $O(n \\log(M))$ where $M$ is the maximum possible value of `capacity`. It can be the maximum value of `weights` array but in our implementation we have taken it to be `INT_MAX` since the difference is trivial anyway (in log scale).\\r\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\n\\r\n- Space complexity: $O(1)$\\r\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\n","creationDate":1677034577}},"acRate":67.0929470150013,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1011","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"capacity-to-ship-packages-within-d-days","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>A conveyor belt has packages that must be shipped from one port to another within <code>days</code> days.</p>\r\n\r\n<p>The <code>i<sup>th</sup></code> package on the conveyor belt has a weight of <code>weights[i]</code>. Each day, we load the ship with packages on the conveyor belt (in the order given by <code>weights</code>). We may not load more weight than the maximum weight capacity of the ship.</p>\r\n\r\n<p>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within <code>days</code> days.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> weights = [1,2,3,4,5,6,7,8,9,10], days = 5\r\n<strong>Output:</strong> 15\r\n<strong>Explanation:</strong> A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\r\n1st day: 1, 2, 3, 4, 5\r\n2nd day: 6, 7\r\n3rd day: 8\r\n4th day: 9\r\n5th day: 10\r\n\r\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> weights = [3,2,2,4,1,4], days = 3\r\n<strong>Output:</strong> 6\r\n<strong>Explanation:</strong> A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\r\n1st day: 3, 2\r\n2nd day: 2, 4\r\n3rd day: 1, 4\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> weights = [1,2,3,1,1], days = 4\r\n<strong>Output:</strong> 3\r\n<strong>Explanation:</strong>\r\n1st day: 1\r\n2nd day: 2\r\n3rd day: 3\r\n4th day: 1, 1\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= days &lt;= weights.length &lt;= 5 * 10<sup>4</sup></code></li>\r\n\t<li><code>1 &lt;= weights[i] &lt;= 500</code></li>\r\n</ul>"},{"id":"3212716","title":"Count the Number of Square-Free Subsets","url":"/discuss/topic/3212716/no-dfs-no-dp-just-bitmask-simple-counting","questionTitle":"Count the Number of Square-Free Subsets","post":{"creationDate":1676954530},"post_data":{"id":3212716,"title":"No DFS, No DP, Just Bitmask + simple counting","solutionTags":[{"name":"C++"},{"name":"Bitmask"}],"post":{"id":5025121,"content":"We just count all valid bitmasks.\n```\nclass Solution {\npublic:\n    int mod = 1000000007;\n    vector<int> primes = vector<int>{2,3,5,7,11,13,17,19,23,29};\n    int getMask(int n)\n    {\n        if (n==1) return 0;\n        int mask = 0;\n        for (int i=0; i<primes.size();i++)\n        {\n            int ctr = 0;\n            while (n%primes[i]==0)\n            {\n                n /= primes[i];\n                ctr ++;\n            }\n            if (ctr>=2) return -1;\n            if(ctr) mask |= (1<<i);\n        }\n        return mask;\n    }\n    int squareFreeSubsets(vector<int>& nums) \n    {\n        unordered_map<long long,long long> H;\n        for (int n: nums)\n        {\n            unordered_map<long long,long long> Hcopy = H;\n            int mask = getMask(n);\n            if (mask==-1) continue;\n            for (auto [k,v]: Hcopy) if ((k & mask)==0) H[ (k|mask) ] = (H[k|mask]%mod + v%mod)%mod;\n            H[mask]++;\n        }\n        long long res = 0;\n        for (auto [k,v]: H) res += v;\n        return (int)(res%mod);\n    }\n};\n```","creationDate":1676954530}},"acRate":18.460396564521258,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"2572","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"count-the-number-of-square-free-subsets","topicTags":[],"hasSolution":false,"hasVideoSolution":false,"content":"<p>You are given a positive integer <strong>0-indexed</strong>&nbsp;array <code>nums</code>.</p>\n\n<p>A subset of the array <code>nums</code> is <strong>square-free</strong> if the product of its elements is a <strong>square-free integer</strong>.</p>\n\n<p>A <strong>square-free integer</strong> is an integer that is divisible by no square number other than <code>1</code>.</p>\n\n<p>Return <em>the number of square-free non-empty subsets of the array</em> <strong>nums</strong>. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>A <strong>non-empty</strong>&nbsp;<strong>subset</strong> of <code>nums</code> is an array that can be obtained by deleting some (possibly none but not all) elements from <code>nums</code>. Two subsets are different if and only if the chosen indices to delete are different.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,4,5]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are 3 square-free subsets in this example:\n- The subset consisting of the 0<sup>th</sup> element [3]. The product of its elements is 3, which is a square-free integer.\n- The subset consisting of the 3<sup>rd</sup> element [5]. The product of its elements is 5, which is a square-free integer.\n- The subset consisting of 0<sup>th</sup> and 3<sup>rd</sup> elements [3,5]. The product of its elements is 15, which is a square-free integer.\nIt can be proven that there are no more than 3 square-free subsets in the given array.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> There is 1 square-free subset in this example:\n- The subset consisting of the 0<sup>th</sup> element [1]. The product of its elements is 1, which is a square-free integer.\nIt can be proven that there is no more than 1 square-free subset in the given array.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 30</code></li>\n</ul>\n"},{"id":"3195707","title":"Put Marbles in Bags","url":"/discuss/topic/3195707/2-heap-solution-with-explaination","questionTitle":"Put Marbles in Bags","post":{"creationDate":1676608064},"post_data":{"id":3195707,"title":"2 Heap solution with explaination","solutionTags":[{"name":"C++"},{"name":"Heap (Priority Queue)"}],"post":{"id":5002952,"content":"The question amounts to putting up `K-1` walls inside the `weights` array. The score is the sum of all the adjacent members of walls plus `weights[0]+weights[n-1]`.\nFor example consider the input `weights = [a,b,c,d,e,f,g,h,i], K=3` and if we put up walls like this: `a b c | d e f g |  h i`  then the score is `(a+c) + (d+g) + (h+i)` which can also be written as `(a+i) + (c+d) + (g+h)`.\n\nNow we want to find the difference between minimum and maximum scores. Notice that the first and last elements will always be part of any score. So, we need not consider them to calculate the difference. We can use a max-heap and a min-heap to store the sum of all adjacent pairs. In our example, this will be `a+b, b+c, c+d, d+e, e+f, f+g, g+h, h+i`. Once we have constructed both the heaps, the maximum score is the sum of `K-1` largest numbers from max heap and the minimum score is the sum of `K-1` smallest numbers from the min heap (plus the first and last, but we are ignoring them because they occur in both). Their difference gives us the answer.\n \n# Code\n```\nclass Solution {\npublic:\n    long long putMarbles(vector<int>& weights, int k) \n    {\n        int n = weights.size(), cur=weights[0];\n        if(k==1 || n==k) return 0;\n        priority_queue<int> max_pq;\n        priority_queue<int, vector<int>, greater<int>> min_pq;\n        for (int i=1; i<n; i++)\n        {\n            if (i>=2) cur -= weights[i-2];\n            cur += weights[i];\n            max_pq.push(cur);\n            min_pq.push(cur);\n\n        }\n        long long res = 0;\n        for (int i=0; i<k-1; i++)\n        {\n            res += max_pq.top();\n            res -= min_pq.top();\n            max_pq.pop();\n            min_pq.pop();\n        }\n        return res;\n    }\n};\n```\n\n# Complexity\nTC: $O(n + k\\log(n))$, SC: $O(n)$\n\nIf you like this post, please upvote it!","creationDate":1676608064}},"acRate":52.080763487632275,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"2551","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"put-marbles-in-bags","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Greedy","id":"VG9waWNUYWdOb2RlOjE3","slug":"greedy"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"},{"name":"Heap (Priority Queue)","id":"VG9waWNUYWdOb2RlOjYxMDUw","slug":"heap-priority-queue"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>You have <code>k</code> bags. You are given a <strong>0-indexed</strong> integer array <code>weights</code> where <code>weights[i]</code> is the weight of the <code>i<sup>th</sup></code> marble. You are also given the integer <code>k.</code></p>\n\n<p>Divide the marbles into the <code>k</code> bags according to the following rules:</p>\n\n<ul>\n\t<li>No bag is empty.</li>\n\t<li>If the <code>i<sup>th</sup></code> marble and <code>j<sup>th</sup></code> marble are in a bag, then all marbles with an index between the <code>i<sup>th</sup></code> and <code>j<sup>th</sup></code> indices should also be in that same bag.</li>\n\t<li>If a bag consists of all the marbles with an index from <code>i</code> to <code>j</code> inclusively, then the cost of the bag is <code>weights[i] + weights[j]</code>.</li>\n</ul>\n\n<p>The <strong>score</strong> after distributing the marbles is the sum of the costs of all the <code>k</code> bags.</p>\n\n<p>Return <em>the <strong>difference</strong> between the <strong>maximum</strong> and <strong>minimum</strong> scores among marble distributions</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> weights = [1,3,5,1], k = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> \nThe distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> weights = [1, 3], k = 2\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The only distribution possible is [1],[3]. \nSince both the maximal and minimal score are the same, we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= weights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= weights[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"},{"id":"3181314","title":"Substring XOR Queries","url":"/discuss/topic/3181314/clean-hashmap-solution","questionTitle":"Substring XOR Queries","post":{"creationDate":1676305201},"post_data":{"id":3181314,"title":"Clean HashMap solution","solutionTags":[{"name":"C++"}],"post":{"id":4984304,"content":"# Intuition\nThe idea is to store all (upto 32 digits long) binary substrings of `\"s\"` in a hashmap and then check the hashmap for each query.\n\nHere is the logic to enumerate all non-zero binary substrings of a string of length 1 to 32:\n```\nfor (int i=0; i<s.length(); i++)\n{\n    if (s[i]==\"0\") continue;\n    int num = 0;\n    for (int j=i; j<min(i+32,s.length()); j++) \n    {\n        num = (num<<1) + (s[j]-\"0\");\n        cout << \"substring:\" << s.substr(i,j-i+1) << \",value:\" << num << endl; \n    }\n}\n```\nWe just need to expand this logic to also consider the substring `\"0\"` and also to create a hashmap of `num: [i,j]` instead of just printing. \n\nThe hashmap stores the positions of first instance of a substring.\n\nWhile querying, we are looking for `query[0]^query[1]` because `a^c=b => c=a^b`. If we find it in hashmap we append its positions to result else append `[-1,-1]`.\n\n# Code\n```\nclass Solution {\npublic:\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) \n    {\n        unordered_map<int, vector<int>> H;\n        for (int i=0; i<s.length(); i++)\n        {\n            if (s[i]==\"0\")\n            {\n                if (!H.count(0)) H[0]={i,i}; \n                continue;\n            }\n            int num = 0;\n            for (int j=i; j<min(i+32,(int)s.length()); j++) \n            {\n                num = (num<<1)+(s[j]-\"0\");\n                if (!H.count(num)) H[num] = {i,j};\n            }\n        }\n        vector<vector<int>> res;\n        for (auto &query: queries)\n        {\n            int val = query[0]^query[1];\n            if (H.count(val)) res.push_back(H[val]);\n            else res.push_back({-1,-1});\n        }\n        return res;\n    }\n};\n```\n\n# Complexity\nTC: $O(n+m)$, SC: $O(n+m)$ where $n=\\vert s \\vert$, $m=\\vert Q \\vert $\n\n### Note on limits\nActually we can also change the for loop to only consider substrings of upto 30 digits long: `for (int j=i; j<min(i+30,(int)s.length()); j++)`. This is because both `first` and `second` are in the range $[0,10^9]$, we know that $10^9$ in binary is 30 digits long. Hence their XOR can be at max 30 digits long ie their maximum value can be `2^{30}-1`.\n\nIn the current solution written above, the hashmap will also contain -ve numbers which is not useful for us but does us no harm. By changing 32 to 30 in the for loop, we can make hashmap a little bit smaller.\n","creationDate":1676305201}},"acRate":33.27011341653075,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"2564","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"substring-xor-queries","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Bit Manipulation","id":"VG9waWNUYWdOb2RlOjE5","slug":"bit-manipulation"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>You are given a <strong>binary string</strong> <code>s</code>, and a <strong>2D</strong> integer array <code>queries</code> where <code>queries[i] = [first<sub>i</sub>, second<sub>i</sub>]</code>.</p>\n\n<p>For the <code>i<sup>th</sup></code> query, find the <strong>shortest substring</strong> of <code>s</code> whose <strong>decimal value</strong>, <code>val</code>, yields <code>second<sub>i</sub></code> when <strong>bitwise XORed</strong> with <code>first<sub>i</sub></code>. In other words, <code>val ^ first<sub>i</sub> == second<sub>i</sub></code>.</p>\n\n<p>The answer to the <code>i<sup>th</sup></code> query is the endpoints (<strong>0-indexed</strong>) of the substring <code>[left<sub>i</sub>, right<sub>i</sub>]</code> or <code>[-1, -1]</code> if no such substring exists. If there are multiple answers, choose the one with the <strong>minimum</strong> <code>left<sub>i</sub></code>.</p>\n\n<p><em>Return an array</em> <code>ans</code> <em>where</em> <code>ans[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> <em>is the answer to the</em> <code>i<sup>th</sup></code> <em>query.</em></p>\n\n<p>A <strong>substring</strong> is a contiguous non-empty sequence of characters within a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;101101&quot;, queries = [[0,5],[1,2]]\n<strong>Output:</strong> [[0,2],[2,3]]\n<strong>Explanation:</strong> For the first query the substring in range <code>[0,2]</code> is <strong>&quot;101&quot;</strong> which has a decimal value of <strong><code>5</code></strong>, and <strong><code>5 ^ 0 = 5</code></strong>, hence the answer to the first query is <code>[0,2]</code>. In the second query, the substring in range <code>[2,3]</code> is <strong>&quot;11&quot;,</strong> and has a decimal value of <strong>3</strong>, and <strong>3<code> ^ 1 = 2</code></strong>.&nbsp;So, <code>[2,3]</code> is returned for the second query. \n\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0101&quot;, queries = [[12,8]]\n<strong>Output:</strong> [[-1,-1]]\n<strong>Explanation:</strong> In this example there is no substring that answers the query, hence <code>[-1,-1] is returned</code>.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1&quot;, queries = [[4,5]]\n<strong>Output:</strong> [[0,0]]\n<strong>Explanation:</strong> For this example, the substring in range <code>[0,0]</code> has a decimal value of <strong><code>1</code></strong>, and <strong><code>1 ^ 4 = 5</code></strong>. So, the answer is <code>[0,0]</code>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= first<sub>i</sub>, second<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n"},{"id":"3166951","title":"As Far from Land as Possible","url":"/discuss/topic/3166951/multi-source-bfs","questionTitle":"As Far from Land as Possible","post":{"creationDate":1676011851},"post_data":{"id":3166951,"title":"Multi Source BFS","solutionTags":[{"name":"C++"},{"name":"Breadth-First Search"}],"post":{"id":4965542,"content":"BFS is very appropriate here. We just need to check how many times we need to traverse to finish the queue of land cells. In one traversal, all adjacent members of the current queue get covered and converted to land cells. \n\n```\nclass Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) \n    {\n        int n = grid.size(), distance=-1;\n        queue<pair<int,int>> Q;\n        for (int i=0; i<n; i++) for (int j=0; j<n; j++)\n            if (grid[i][j]) Q.push({i,j});\n        if (Q.empty()||Q.size()==n*n) return -1;//All water or all land\n        vector<pair<int,int>> directions{{-1,0},{1,0},{0,-1},{0,1}};\n        while (!Q.empty())\n        {\n            for (int i=Q.size(); i>0; i--)\n            {\n                auto cell = Q.front();\n                Q.pop();\n                for (auto &dir: directions)\n                {\n                    int x = cell.first+dir.first;\n                    int y = cell.second+dir.second;\n                    if (x<0||x>=n||y<0||y>=n) continue;\n                    if (grid[x][y]==0)\n                    {\n                        grid[x][y] = 1;\n                        Q.push({x,y});\n                    }\n                }\n            }\n            distance++;\n        }\n        return distance;\n    }\n};\n```","creationDate":1676011851}},"acRate":51.903729922734264,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1162","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"as-far-from-land-as-possible","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an <code>n x n</code> <code>grid</code>&nbsp;containing only values <code>0</code> and <code>1</code>, where&nbsp;<code>0</code> represents water&nbsp;and <code>1</code> represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance.&nbsp;If no land or water exists in the grid, return <code>-1</code>.</p>\n\n<p>The distance used in this problem is the Manhattan distance:&nbsp;the distance between two cells <code>(x0, y0)</code> and <code>(x1, y1)</code> is <code>|x0 - x1| + |y0 - y1|</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/03/1336_ex1.JPG\" style=\"width: 185px; height: 87px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,0,1],[0,0,0],[1,0,1]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The cell (1, 1) is as far as possible from all the land with distance 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/03/1336_ex2.JPG\" style=\"width: 184px; height: 87px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,0,0],[0,0,0],[0,0,0]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The cell (2, 2) is as far as possible from all the land with distance 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;is <code>0</code> or <code>1</code></li>\n</ul>\n"},{"id":"3165155","title":"Naming a Company","url":"/discuss/topic/3165155/hashset-for-all-letters","questionTitle":"Naming a Company","post":{"creationDate":1675963422},"post_data":{"id":3165155,"title":"HashSet for all letters","solutionTags":[{"name":"C++"},{"name":"Hash Table"}],"post":{"id":4963113,"content":"# Intuition\nConsider the example with all words from either `\"a\"` or `\"b\"`:\n```\nideas = [\"apple\",\"and\",\"alpha\",\"amaze\",\"aye\",\"aid\",\"bye\",\"bid\",\"bat\",\"beef\",\"brown\"]\n```\nBased on the starting letter and the suffix we can see this pattern:\n```\n\"a\": [\"pple\",\"nd\",\"lpha\",\"maze\",\"ye\",\"id\"]\n\"b\": [\"ye\",\"id\",\"at\",\"eef\",\"rown\"]\n```\nNotice that `\"ye\"` and `\"id\"` are present in both. These cannot be used for company names because for example suppose we use `\"aye\",\"bat\"` we will have `\"bye aat\"` as the company name but `\"bye\"` is present in original list of `ideas` hence not valid. So, we need to find the suffixes present in only one of the arrays:\n```\n\"a\": [\"pple\",\"lpha\",\"nd\",\"maze\"]\n\"b\": [\"at\",\"eef\",\"rown\"]\n```\nWe can choose 12 pairs from here and from them we will have 24 company names:\n```\ncompany_names = [\"aat bpple\", \"bpple aat\", \"aeef bpple\", \"bpple aeef\", \"arown bpple\", \"bpple arown\", \"aat blpha\", \"blpha aat\", \"aeef blpha\", \"blpha aeef\", \"arown blpha\", \"blpha arown\", \"aat bnd\", \"bnd aat\", \"aeef bnd\", \"bnd aeef\", \"arown bnd\", \"bnd arown\", \"aat bmaze\", \"bmaze aat\", \"aeef bmaze\", \"bmaze aeef\", \"arown bmaze\", \"bmaze arown\"]\n```\nHence answer for this example is 24.\n\n# Approach\nWe will use 26 HashSets to store suffixes for each alphabet. For each pair of alphabets, we will add their contribution as $2*n1*n2$ where $n1,n2$ are the suffixes from each alphabet not present in the other one.\n\n# Code\n```\nclass Solution {\npublic:\n    long long distinctNames(vector<string>& ideas) \n    {\n        long long res = 0;\n        vector<unordered_set<string>> ideaSet(26, unordered_set<string>{});\n        for(string idea: ideas) ideaSet[idea[0]-\"a\"].insert(idea.substr(1));\n        for (int i=0; i<26; i++)\n        {\n            for(int j=i+1; j<26; j++)\n            {\n                int common=0;\n                for(string idea: ideaSet[j]) common+=ideaSet[i].count(idea);\n                int n1 = ideaSet[i].size()-common, n2=ideaSet[j].size()-common;\n                res += 2LL*n1*n2;\n            }\n        }\n        return res;\n    }\n};\n```\n\n# Complexity\nWorst case time complexity is $O(nm)$ where $n$ is the number of words in `ideas`, $m$ is the maximum size of word in `ideas` .\nSpace complexity: $O(nm)$\n\n# Alternative solution\nWe can have slightly more efficient solution (same TC) if instead of storing suffixes we just maintain a 26x26 frequency table to check validity of name.\n```\nclass Solution {\npublic:\n    long long distinctNames(vector<string>& ideas) \n    {\n        long long res = 0;\n        unordered_set<string> ideaSet(ideas.begin(),ideas.end());\n        vector<vector<int>>freq_table(26,vector<int>(26,0));\n        for (string idea: ideas)\n        {\n            for(char ch=\"a\"; ch<=\"z\"; ch++)\n            {\n                string namePart = string(1,ch)+idea.substr(1);\n                if(!ideaSet.count(namePart))\n                    freq_table[idea[0]-\"a\"][ch-\"a\"]++;\n            }\n        }\n        for (int i=0; i<26; i++)\n            for (int j=i+1; j<26; j++)\n                res += 2LL*freq_table[i][j]*freq_table[j][i];\n        return res;\n    }\n};\n```","creationDate":1675963422}},"acRate":47.043766705264716,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"2306","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"naming-a-company","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Bit Manipulation","id":"VG9waWNUYWdOb2RlOjE5","slug":"bit-manipulation"},{"name":"Enumeration","id":"VG9waWNUYWdOb2RlOjYxMDY2","slug":"enumeration"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given an array of strings <code>ideas</code> that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:</p>\n\n<ol>\n\t<li>Choose 2 <strong>distinct</strong> names from <code>ideas</code>, call them <code>idea<sub>A</sub></code> and <code>idea<sub>B</sub></code>.</li>\n\t<li>Swap the first letters of <code>idea<sub>A</sub></code> and <code>idea<sub>B</sub></code> with each other.</li>\n\t<li>If <strong>both</strong> of the new names are not found in the original <code>ideas</code>, then the name <code>idea<sub>A</sub> idea<sub>B</sub></code> (the <strong>concatenation</strong> of <code>idea<sub>A</sub></code> and <code>idea<sub>B</sub></code>, separated by a space) is a valid company name.</li>\n\t<li>Otherwise, it is not a valid name.</li>\n</ol>\n\n<p>Return <em>the number of <strong>distinct</strong> valid names for the company</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> ideas = [&quot;coffee&quot;,&quot;donuts&quot;,&quot;time&quot;,&quot;toffee&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The following selections are valid:\n- (&quot;coffee&quot;, &quot;donuts&quot;): The company name created is &quot;doffee conuts&quot;.\n- (&quot;donuts&quot;, &quot;coffee&quot;): The company name created is &quot;conuts doffee&quot;.\n- (&quot;donuts&quot;, &quot;time&quot;): The company name created is &quot;tonuts dime&quot;.\n- (&quot;donuts&quot;, &quot;toffee&quot;): The company name created is &quot;tonuts doffee&quot;.\n- (&quot;time&quot;, &quot;donuts&quot;): The company name created is &quot;dime tonuts&quot;.\n- (&quot;toffee&quot;, &quot;donuts&quot;): The company name created is &quot;doffee tonuts&quot;.\nTherefore, there are a total of 6 distinct company names.\n\nThe following are some examples of invalid selections:\n- (&quot;coffee&quot;, &quot;time&quot;): The name &quot;toffee&quot; formed after swapping already exists in the original array.\n- (&quot;time&quot;, &quot;toffee&quot;): Both names are still the same after swapping and exist in the original array.\n- (&quot;coffee&quot;, &quot;toffee&quot;): Both names formed after swapping already exist in the original array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ideas = [&quot;lack&quot;,&quot;back&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no valid selections. Therefore, 0 is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= ideas.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= ideas[i].length &lt;= 10</code></li>\n\t<li><code>ideas[i]</code> consists of lowercase English letters.</li>\n\t<li>All the strings in <code>ideas</code> are <strong>unique</strong>.</li>\n</ul>\n"},{"id":"3154206","title":"Subarrays with K Different Integers","url":"/discuss/topic/3154206/sliding-window-hashmap","questionTitle":"Subarrays with K Different Integers","post":{"creationDate":1675749131},"post_data":{"id":3154206,"title":"Sliding window + HashMap","solutionTags":[{"name":"C++"}],"post":{"id":4949070,"content":"We solve the problem of subarray with at most K distinct integers and use it for K and K-1 to get the answer.\n\n\n```\nclass Solution {\npublic:\n    int subarraysWithKDistinct(vector<int>& nums, int k)\n    {\n        return atMostK(nums,k)-atMostK(nums,k-1);\n    }\n    int atMostK(vector<int>& nums, int k) \n    {\n        int n = nums.size(), i=0, res=0;\n        unordered_map<int,int> H;\n        for (int j=0; j<n; j++)\n        {\n            H[nums[j]]++;\n            while(H.size()>k)\n            {\n                H[nums[i]]--;\n                if (H[nums[i]]==0) H.erase(nums[i]);\n                i++;\n            }\n            res += (j-i+1);\n        }\n        return res;\n    }\n};\n```","creationDate":1675749131}},"acRate":54.60178782877583,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"992","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"subarrays-with-k-different-integers","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Sliding Window","id":"VG9waWNUYWdOb2RlOjU1ODIx","slug":"sliding-window"},{"name":"Counting","id":"VG9waWNUYWdOb2RlOjYxMDYy","slug":"counting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the number of <strong>good subarrays</strong> of </em><code>nums</code>.</p>\n\n<p>A <strong>good array</strong> is an array where the number of different integers in that array is exactly <code>k</code>.</p>\n\n<ul>\n\t<li>For example, <code>[1,2,3,1,2]</code> has <code>3</code> different integers: <code>1</code>, <code>2</code>, and <code>3</code>.</li>\n</ul>\n\n<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,2,3], k = 2\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,4], k = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= nums.length</code></li>\n</ul>\n"},{"id":"3153941","title":"Fruit Into Baskets","url":"/discuss/topic/3153941/reaching-the-best-solution","questionTitle":"Fruit Into Baskets","post":{"creationDate":1675744650},"post_data":{"id":3153941,"title":"Reaching the best solution","solutionTags":[{"name":"C++"}],"post":{"id":4948702,"content":"We can immediately think of a brute-force $O(n^3)$ solution by checking all subarrays:\n```\nclass Solution {\npublic:\n    bool valid(vector<int>&fruits, int i, int j)\n    {\n        unordered_set<int> unq_fruits;\n        for(int k=i; k<=j; k++) unq_fruits.insert(fruits[k]);\n        return (unq_fruits.size()<=2);\n    }\n    int totalFruit(vector<int>& fruits) \n    {\n        int n = fruits.size(), res=0;\n        if(n==1) return 1;\n        for (int i=0; i<n; i++) for (int j=i+1; j<n; j++)\n            if (valid(fruits,i,j)) res=max(res,j-i+1);\n        return res;\n    }\n};\n```\nThis will give us TLE. We can improve it to $O(n^2)$ by noticing that we do not need to check all subarrays. For any starting index, we only extend a subarray to the right as long as it is valid subarray.\n```\nclass Solution {\npublic:\n    int totalFruit(vector<int>& fruits) \n    {\n        int n = fruits.size(), res=0;\n        if(n==1) return 1;\n        for (int i=0; i<n; i++)\n        {\n            int j=i;\n            unordered_set<int> unq_fruits;\n            while (j<n)\n            {\n                if (!unq_fruits.count(fruits[j]) && unq_fruits.size()==2) break;\n                unq_fruits.insert(fruits[j]);\n                j++;\n            }\n            res = max(res, j-i);\n        }\n        return res;\n    }\n};\n```\nThis also gives us TLE. By now we must realize that HashSet will not be enough, we are going to need HashMap. The crucial use of HashMap is we can know exactly at what index the subarray becomes valid.\n\n```\nclass Solution {\npublic:\n    int totalFruit(vector<int>& fruits) \n    {\n        int n = fruits.size(), res=0, i=0;\n        if(n==1) return 1;\n        unordered_map<int,int> H;\n        for (int j=0; j<n; j++)\n        {\n            H[fruits[j]]++;\n            while(i<n && H.size()>2)\n            {\n                H[fruits[i]]--;\n                if (H[fruits[i]]==0) H.erase(fruits[i]);\n                i++;\n            }\n            res = max(res, j-i+1);\n        }\n        return res;\n    }\n};\n```\nThis is $O(n)$ solution and hence AC. However we can still do a minor improvement: We need not check all valid subarrays, only subarrays longer than the longest valid one we have seen earlier. In this solution, we lose track of the exact `(i,j)` that gives us the answer but the length is what we need. This is still $O(n)$.\n```\nclass Solution {\npublic:\n    int totalFruit(vector<int>& fruits) \n    {\n        int n = fruits.size(), res=0, i=0,j;\n        if(n==1) return 1;\n        unordered_map<int,int> H;\n        for (j=0; j<n; j++)\n        {\n            H[fruits[j]]++;\n            if(i<n && H.size()>2)\n            {\n                H[fruits[i]]--;\n                if (H[fruits[i]]==0) H.erase(fruits[i]);\n                i++;\n            }\n        }\n        return (j-i);\n    }\n};\n```","creationDate":1675744650}},"acRate":43.71344023122978,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"904","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"fruit-into-baskets","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Sliding Window","id":"VG9waWNUYWdOb2RlOjU1ODIx","slug":"sliding-window"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array <code>fruits</code> where <code>fruits[i]</code> is the <strong>type</strong> of fruit the <code>i<sup>th</sup></code> tree produces.</p>\n\n<p>You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:</p>\n\n<ul>\n\t<li>You only have <strong>two</strong> baskets, and each basket can only hold a <strong>single type</strong> of fruit. There is no limit on the amount of fruit each basket can hold.</li>\n\t<li>Starting from any tree of your choice, you must pick <strong>exactly one fruit</strong> from <strong>every</strong> tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.</li>\n\t<li>Once you reach a tree with fruit that cannot fit in your baskets, you must stop.</li>\n</ul>\n\n<p>Given the integer array <code>fruits</code>, return <em>the <strong>maximum</strong> number of fruits you can pick</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> fruits = [<u>1,2,1</u>]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can pick from all 3 trees.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> fruits = [0,<u>1,2,2</u>]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can pick from trees [1,2,2].\nIf we had started at the first tree, we would only pick from trees [0,1].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> fruits = [1,<u>2,3,2,2</u>]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> We can pick from trees [2,3,2,2].\nIf we had started at the first tree, we would only pick from trees [1,2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li>\n</ul>\n"},{"id":"3134605","title":"Zigzag Conversion","url":"/discuss/topic/3134605/easy-method","questionTitle":"Zigzag Conversion","post":{"creationDate":1675402140},"post_data":{"id":3134605,"title":"Easy Method","solutionTags":[{"name":"C++"}],"post":{"id":4923524,"content":"We only need to notice that the row number for any character is decided by its modulus wrt $m=2*|s|-2$. This can be easily observed once you notice that the pattern starts repeating after it reaches the top row after one zigzag. Hence $m$ is the length of one zigzag. Next we need to check if each position is coming in the downward phase or the upward phase of zigzag and accordingly update that row.\n\n```\nclass Solution {\npublic:\n    string convert(string s, int numRows) \n    {\n        if (numRows==1) return s;\n        int m = 2*numRows - 2;\n        vector<string> rows(numRows, \"\");\n        for (int i=0; i<s.length(); i++)\n        {\n            int r = i%m;\n            if (r<numRows) rows[r].push_back(s[i]);\n            else rows[m-r].push_back(s[i]);\n        }\n        string res = \"\";\n        for (string r: rows) res+=r;\n        return res;\n    }\n};\n```\n\nTime complexity: $O(n)$\n","creationDate":1675402140}},"acRate":44.69372813648778,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"6","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"zigzag-conversion","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>\n\n<pre>\nP   A   H   N\nA P L S I I G\nY   I   R\n</pre>\n\n<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>\n\n<p>Write the code that will take a string and make this conversion given a number of rows:</p>\n\n<pre>\nstring convert(string s, int numRows);\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 3\n<strong>Output:</strong> &quot;PAHNAPLSIIGYIR&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 4\n<strong>Output:</strong> &quot;PINALSIGYAHRPI&quot;\n<strong>Explanation:</strong>\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A&quot;, numRows = 1\n<strong>Output:</strong> &quot;A&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of English letters (lower-case and upper-case), <code>&#39;,&#39;</code> and <code>&#39;.&#39;</code>.</li>\n\t<li><code>1 &lt;= numRows &lt;= 1000</code></li>\n</ul>\n"},{"id":"3106735","title":"Word Break II","url":"/discuss/topic/3106735/word-break-extension-dp","questionTitle":"Word Break II","post":{"creationDate":1674847049},"post_data":{"id":3106735,"title":"Word Break extension (DP)","solutionTags":[{"name":"C++"}],"post":{"id":4887032,"content":"# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is from [Word Break](https://leetcode.com/problems/word-break). Basically we check at each position, if there is a valid word from any previous position. Reproducing my solution for Word Break below:\n```\nbool wordBreak(string s, vector<string>& words) \n{\n    unordered_set<string> wordSet(words.begin(),words.end());\n    int n = s.length();\n    vector<bool> valid(n+1, false);\n    valid[0] = true;\n    for (int j=1; j<=n; j++)\n        for (int i=0; i<j && !valid[j]; i++)\n            valid[j] = valid[i] && wordSet.count(s.substr(i,j-i));\n    return valid[n];\n}\n```\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nInstead of a 1-D boolean `valid` array, here we will maintain a 2-D string array `A`. `A[i]` will have all valid \"sentences\" for `s[0:i]`. `A[0]` is a single word sentence (placeholder *). To find `A[j]` we look for all previous `A[i]` for all `i` in `0<=i<j` and if we find any sentence in `A[i]` then `A[j]` will have that sentence added with the word `s.substr(i,j-i)`. Finally we get rid of the placeholder and first space character in each sentence of `A[n]` to get the answer.\n\n\n\n# Code\n```\nclass Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& words) \n    {\n        unordered_set<string> wordSet(words.begin(),words.end());\n        int n = s.length();\n        vector<vector<string>> A(n+1,vector<string>{});\n        A[0] = {\"*\"};\n        for (int j=1; j<=n; j++)\n            for (int i=0; i<j; i++)\n                if (A[i].size()>0 && wordSet.count(s.substr(i,j-i)))\n                    for (string w: A[i])\n                        A[j].push_back(w+\" \"+s.substr(i,j-i));\n        auto res = A[n];\n        for (string &s: res) s = s.substr(2);\n        return res;\n    }\n};\n```\n\nRelated:\nhttps://leetcode.com/problems/concatenated-words/solutions/3106355/","creationDate":1674847049}},"acRate":45.092155256436484,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"140","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"word-break-ii","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Backtracking","id":"VG9waWNUYWdOb2RlOjE0","slug":"backtracking"},{"name":"Trie","id":"VG9waWNUYWdOb2RlOjI3","slug":"trie"},{"name":"Memoization","id":"VG9waWNUYWdOb2RlOjMz","slug":"memoization"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]\n<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]\n<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]\n<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n</ul>\n"},{"id":"3106355","title":"Concatenated Words","url":"/discuss/topic/3106355/word-break-extension-dp","questionTitle":"Concatenated Words","post":{"creationDate":1674841449},"post_data":{"id":3106355,"title":"Word Break extension (DP)","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":4886580,"content":"# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nIntuition is from [Word Break](https://leetcode.com/problems/word-break). Basically we check at each position, if there is a valid word from any previous position. Reproducing my solution for Word Break below:\n```\nbool wordBreak(string s, vector<string>& words) \n{\n    unordered_set<string> wordSet(words.begin(),words.end());\n    int n = s.length();\n    vector<bool> valid(n+1, false);\n    valid[0] = true;\n    for (int j=1; j<=n; j++)\n        for (int i=0; i<j && !valid[j]; i++)\n            valid[j] = valid[i] && wordSet.count(s.substr(i,j-i));\n    return valid[n];\n}\n```\n# Approach\n<!-- Describe your approach to solving the problem. -->\nWe just repeat Word Break for each word with all the other words.\n\n# Complexity\n- Time complexity: $O(N*M^3)$ where N is size of `words` array and `M` is the length of longest word. $N*M^2$ can be seen clearly from the `for` loops in code below. Extra `M` term is for string hashing.\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $O(N*M)$\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution {\npublic:\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) \n    {\n        unordered_set<string> wordSet(words.begin(),words.end());\n        vector<string> res;\n        for (string word: words)\n        {\n            wordSet.erase(word);\n            int n = word.length();\n            vector<bool> valid(n+1, false);\n            valid[0] = true;\n            for (int j=1; j<=n; j++)\n                for (int i=0; i<j && !valid[j]; i++)\n                    valid[j] = valid[i] && wordSet.count(word.substr(i,j-i));\n            if (valid[n]) res.push_back(word);\n            wordSet.insert(word);\n        }\n        return res;        \n    }\n};\n```","creationDate":1674841449}},"acRate":50.14746165752763,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"472","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"concatenated-words","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Trie","id":"VG9waWNUYWdOb2RlOjI3","slug":"trie"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an array of strings <code>words</code> (<strong>without duplicates</strong>), return <em>all the <strong>concatenated words</strong> in the given list of</em> <code>words</code>.</p>\n\n<p>A <strong>concatenated word</strong> is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct)&nbsp;in the given array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]\n<strong>Output:</strong> [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]\n<strong>Explanation:</strong> &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; \n&quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; \n&quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;dog&quot;,&quot;catdog&quot;]\n<strong>Output:</strong> [&quot;catdog&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> consists of only lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are <strong>unique</strong>.</li>\n\t<li><code>1 &lt;= sum(words[i].length) &lt;= 10<sup>5</sup></code></li>\n</ul>\n"},{"id":"3055690","title":"Increment Submatrices by One","url":"/discuss/topic/3055690/cumulative-sum","questionTitle":"Increment Submatrices by One","post":{"creationDate":1673806047},"post_data":{"id":3055690,"title":"Cumulative Sum","solutionTags":[{"name":"C++"}],"post":{"id":4818416,"content":"# Intuition\nWe will maintain a matrix where each update is `O(1)` in time. At the end, we will use cumulative sum method to get final output.\n\n# Approach\nLet us first solve the [1-D version of the problem](https://leetcode.com/problems/range-addition/). Also availabe [here](https://leetcode.ca/all/370.html). I will give a brief overview.\nProblem is given length of array N starting with all zeros and some update queries of format `(left,right,increment)`, return the final array.\n```\nInput: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]\n```\nA naive way would be to update from left to right for each query:\n```\nvector<int> solve(int n, vector<vector<int>> updates)\n{\n    vector<int> A(n,0);\n    for (auto &query: updates)\n    {\n        int left = query[0], right = query[1], increment = query[2];\n        for (int i=left; i<=right; i++) A[i]+=increment;\n    }\n    return A;\n}\n```\nHere is a smarter way to do this: we just do `+increment` at `left` and `-increment` at `right+1` and finally return the cumulative sum array. We will need array of length `N+1` this time.\n```\nvector<int> solve(int n, vector<vector<int>> updates)\n{\n    vector<int> A(n+1,0);\n    for (auto &query: updates)\n    {\n        int left = query[0], right = query[1], increment = query[2];\n        A[left]+=increment;\n        A[right+1]-=increment\n    }\n    for (int i=1; i<=n; i++) A[i]+=A[i-1];\n    A.pop_back(); // we want only first n items. A[n] is always zero\n    return A;\n}\n```\nYou can see that the first method is $O(Q*N)$ and second method is $O(Q+N)$ where `N` is size of array and `Q` is number of update queries.\n\nLet us extend this logic to our problem.\nHere we will do the following updates for each update query. \n```\nM[r1][c1]++;\nM[r2+1][c1]--;\nM[r1][c2+1]--;\nM[r2+1][c2+1]++;\n```\nThe reason we need to do like this is because here we will be taking a 2-D cumulative sum by which we mean $res[i][j] = \\sum_{ii,jj} M[ii][jj]$ where $0<=ii<=i$ and $0<=jj<=j$\n\n\n# Complexity\n- Time complexity: $O(Q + N^2)$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $O(N^2)$\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) \n    {\n        vector<vector<int>> M = vector<vector<int>>(n+1, vector<int>(n+1,0));\n        for (auto &q: queries)\n        {\n            int r1=q[0], c1=q[1], r2=q[2], c2=q[3];\n            M[r1][c1]++;\n            M[r2+1][c1]--;\n            M[r1][c2+1]--;\n            M[r2+1][c2+1]++;\n        }\n        // Use this to print update matrix. You can check manually that the 2-D cumulative sum of this gives the answer\n        // for (auto &v: M){for(int k: v)cout<<k<<\",\";cout<<endl;} \n        vector<vector<int>> res = vector<vector<int>>(n, vector<int>(n,0));\n        res[0][0] = M[0][0];\n        for (int i=1; i<n; i++) res[i][0]=res[i-1][0]+M[i][0];\n        for (int j=1; j<n; j++) res[0][j]=res[0][j-1]+M[0][j];\n        for (int i=1; i<n; i++) for (int j=1; j<n; j++)\n            res[i][j] = -res[i-1][j-1]+res[i][j-1]+res[i-1][j]+M[i][j];\n        return res;\n    }\n};\n```","creationDate":1673806047}},"acRate":47.97604790419162,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"2536","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"increment-submatrices-by-one","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"},{"name":"Prefix Sum","id":"VG9waWNUYWdOb2RlOjYxMDY4","slug":"prefix-sum"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>You are given a positive integer <code>n</code>, indicating that we initially have an <code>n x n</code>&nbsp;<strong>0-indexed</strong> integer matrix <code>mat</code> filled with zeroes.</p>\n\n<p>You are also given a 2D integer array <code>query</code>. For each <code>query[i] = [row1<sub>i</sub>, col1<sub>i</sub>, row2<sub>i</sub>, col2<sub>i</sub>]</code>, you should do the following operation:</p>\n\n<ul>\n\t<li>Add <code>1</code> to <strong>every element</strong> in the submatrix with the <strong>top left</strong> corner <code>(row1<sub>i</sub>, col1<sub>i</sub>)</code> and the <strong>bottom right</strong> corner <code>(row2<sub>i</sub>, col2<sub>i</sub>)</code>. That is, add <code>1</code> to <code>mat[x][y]</code> for all <code>row1<sub>i</sub> &lt;= x &lt;= row2<sub>i</sub></code> and <code>col1<sub>i</sub> &lt;= y &lt;= col2<sub>i</sub></code>.</li>\n</ul>\n\n<p>Return<em> the matrix</em> <code>mat</code><em> after performing every query.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p2example11.png\" style=\"width: 531px; height: 121px;\" />\n<pre>\n<strong>Input:</strong> n = 3, queries = [[1,1,2,2],[0,0,1,1]]\n<strong>Output:</strong> [[1,1,0],[1,2,1],[0,1,1]]\n<strong>Explanation:</strong> The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.\n- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).\n- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p2example22.png\" style=\"width: 261px; height: 82px;\" />\n<pre>\n<strong>Input:</strong> n = 2, queries = [[0,0,1,1]]\n<strong>Output:</strong> [[1,1],[1,1]]\n<strong>Explanation:</strong> The diagram above shows the initial matrix and the matrix after the first query.\n- In the first query we add 1 to every element in the matrix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= row1<sub>i</sub> &lt;= row2<sub>i</sub> &lt; n</code></li>\n\t<li><code>0 &lt;= col1<sub>i</sub> &lt;= col2<sub>i</sub> &lt; n</code></li>\n</ul>\n"},{"id":"3006919","title":"Sum of Subarray Minimums","url":"/discuss/topic/3006919/monotonic-stack-dp","questionTitle":"Sum of Subarray Minimums","post":{"creationDate":1672987718},"post_data":{"id":3006919,"title":"Monotonic Stack + DP","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"},{"name":"Monotonic Stack"}],"post":{"id":4754541,"content":"# Intuition + Approach\n<!-- Describe your first thoughts on how to solve this problem. -->\nThe intuition is that while traversing, we will maintain a 1-D DP array such that\n```\ndp[i] = f(0,i) + f(1,i) + f(2,i) + ... + f(i,i)\n```\nwhere \n```\nf(j,i) = Minimum from indices j to i (inclusive)\n```\n\nOnce we are done, we can add the `dp` array to get our answer.\n\n## Example\n```\narr = [8,6,3,5,4,9,2]\n```\nFor this example, we want that after we are done, the DP should look like:\n```\ndp = [8,12,9,14,17,26,14]\n```\nWe can see that how this matches our expectation:\n```\ndp[0] = 8\ndp[1] = 6+6\ndp[2] = 3+3+3\ndp[3] = 3+3+3+5\ndp[4] = 3+3+3+4+4\ndp[5] = 3+3+3+4+4+9\ndp[6] = 2+2+2+2+2+2+2\n```\nAs expected we can sum the `dp` array to get our answer 100.\n\n## How to create this DP array\nWe will use a monotonic stack (MS) for this. The basic setting for a MS is:\n```\nstack<int> stk;\nfor (int i=0; i<n; i++)\n{\n    while (!stk).empty() && stk.top()>=A[i]) stk.pop();\n    stk.push(A[i]);\n}\n```\nHere we will store the indices instead of the values. For each iteration in `i`, once we are done withe the popping, we can create `dp[i]` as follows:\n- If the stack is empty, it means the current element is the smallest of all elements in `(0,i)` range. Hence, `dp[i] = A[i]*(i+1)` corresponding to ranges `(0,i)`, `(1,i)`, `(2,i)`, ...., `(i,i)`.\n\n- If the stack is not empty and the top of the stack is `j`, then, for the ranges `(0,i)`, `(1,i)`, `(2,i)`, ..., `(j,i)`, the minimum element is stored in `dp[j]` (their sum) and for the ranges `(j+1,i)`, `(j+2,i)`, ..., `(i,i)`, the minimum element is `A[i]`. Hence, `dp[i] = dp[j] + A[i]*(i-j)`\n\n# Complexity\n- Time complexity: $O(n)$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $O(n)$\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\n#define ll long long int\nclass Solution {\npublic:\n    int sumSubarrayMins(vector<int>& arr) \n    {\n        int n = arr.size(), mod=1000000007;\n        ll res = 0;\n        vector<ll> dp(n,-1);\n        stack<int> stk;\n        for (int i=0; i<n; i++)\n        {\n            while (!stk.empty() && arr[i]<=arr[stk.top()]) stk.pop();\n            if (!stk.empty())\n            {\n                int j = stk.top();\n                dp[i] = dp[j] + arr[i]*(i-j);\n            } \n            else dp[i] = arr[i]*(i+1);\n            stk.push(i);\n        }\n        for (int x: dp) res+=x;\n        return (int)(res%mod);\n    }\n};\n```","creationDate":1672987718}},"acRate":35.82808776983534,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"907","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"sum-of-subarray-minimums","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Monotonic Stack","id":"VG9waWNUYWdOb2RlOjYxMDU0","slug":"monotonic-stack"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an array of integers arr, find the sum of <code>min(b)</code>, where <code>b</code> ranges over every (contiguous) subarray of <code>arr</code>. Since the answer may be large, return the answer <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [3,1,2,4]\n<strong>Output:</strong> 17\n<strong>Explanation:</strong> \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [11,81,94,43,3]\n<strong>Output:</strong> 444\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 3 * 10<sup>4</sup></code></li>\n</ul>\n"},{"id":"3004894","title":"Day of the Year","url":"/discuss/topic/3004894/intuitive-c-solution","questionTitle":"Day of the Year","post":{"creationDate":1672954936},"post_data":{"id":3004894,"title":"Intuitive C++ solution","solutionTags":[{"name":"C++"}],"post":{"id":4751778,"content":"Make sure to take care of [leap year rule](https://www.mathsisfun.com/leap-years.html).\nExamples of leap years: 1992,1996,2000,2004,..,2096,2104\n\n# Code\n```\nclass Solution {\npublic:\n    int dayOfYear(string date) {\n        int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31};\n        int Y=stoi(date.substr(0,4)), M=stoi(date.substr(5,2)), D=stoi(date.substr(8,2));\n        if ((Y%4==0 && Y%100>0) || (Y%400==0)) days[1]=29;\n        int ctr=0;\n        for (int m=0;m<M-1;m++) ctr+=days[m];\n        ctr+=D;\n        return ctr;\n    }\n};\n```","creationDate":1672954936}},"acRate":49.81557718392309,"difficulty":"Easy","freqBar":null,"frontendQuestionId":"1154","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"day-of-the-year","topicTags":[{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>Given a string <code>date</code> representing a <a href=\"https://en.wikipedia.org/wiki/Gregorian_calendar\" target=\"_blank\">Gregorian calendar</a> date formatted as <code>YYYY-MM-DD</code>, return <em>the day number of the year</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> date = &quot;2019-01-09&quot;\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> Given date is the 9th day of the year in 2019.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> date = &quot;2019-02-10&quot;\n<strong>Output:</strong> 41\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>date.length == 10</code></li>\n\t<li><code>date[4] == date[7] == &#39;-&#39;</code>, and all other <code>date[i]</code>&#39;s are digits</li>\n\t<li><code>date</code> represents a calendar date between Jan 1<sup>st</sup>, 1900 and Dec 31<sup>th</sup>, 2019.</li>\n</ul>\n"},{"id":"2966382","title":"Longest Absolute File Path","url":"/discuss/topic/2966382/monotonic-stack-solution-explained","questionTitle":"Longest Absolute File Path","post":{"creationDate":1672301744},"post_data":{"id":2966382,"title":"Monotonic stack solution explained","solutionTags":[{"name":"C++"},{"name":"Monotonic Stack"}],"post":{"id":4702329,"content":"# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nMonotonic stack will be very useful here because we need to keep track of length of directory at current depth.\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nWe will maintain the stack of `(depth, length of path)` and for each entry, we will keep popping from stack till we are at the correct depth.\nExample 1:\n```\ndir: [(0,3)]\n\tsubdir1: [(0,3)(1,11)]\n\tsubdir2: [(0,3)(1,11)]\n\t\tfile.ext: [(0,3)(1,11)(2,20)]\n```\nExample 2:\n```\ndir: [(0,3)]\n\tsubdir1: [(0,3)(1,11)]\n\t\tfile1.ext: [(0,3)(1,11)(2,21)]\n\t\tsubsubdir1: [(0,3)(1,11)(2,22)]\n\tsubdir2: [(0,3)(1,11)]\n\t\tsubsubdir2: [(0,3)(1,11)(2,22)]\n\t\t\tfile2.ext: [(0,3)(1,11)(2,22)(3,32)]\n```\n# Complexity\n- Time complexity: $$O(n)$$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $$O(n)$$\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution {\npublic:\n    int lengthLongestPath(string input) \n    {\n        stringstream ss(input);\n        string line;\n        vector<string> lines;\n        while (getline(ss, line, \"\\\n\")) lines.push_back(line);\n        stack<pair<int,int>> stk;\n        int res=0;\n        for (auto &line: lines)\n        {\n            int tabs=0;\n            while (line[tabs]==\"\t\") tabs++;\n            while (!stk.empty() && tabs<=stk.top().first) stk.pop();\n            int cur = (stk.empty() ? line.length() : stk.top().second+1+line.length()-tabs);\n            stk.push({tabs, cur});\n            if (find(line.begin(),line.end(),\".\")!=line.end()) res = max(res,cur);\n        }\n        return res;\n    }\n};\n```","creationDate":1672301744}},"acRate":46.629882252293775,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"388","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"longest-absolute-file-path","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg\" style=\"width: 681px; height: 322px;\" /></p>\n\n<p>Here, we have <code>dir</code> as the only directory in the root. <code>dir</code> contains two subdirectories, <code>subdir1</code> and <code>subdir2</code>. <code>subdir1</code> contains a file <code>file1.ext</code> and subdirectory <code>subsubdir1</code>. <code>subdir2</code> contains a subdirectory <code>subsubdir2</code>, which contains a file <code>file2.ext</code>.</p>\n\n<p>In text form, it looks like this (with  representing the tab character):</p>\n\n<pre>\ndir\n subdir1\n  file1.ext\n  subsubdir1\n subdir2\n  subsubdir2\n   file2.ext\n</pre>\n\n<p>If we were to write this representation in code, it will look like this: <code>&quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot;</code>. Note that the <code>&#39;\\n&#39;</code> and <code>&#39;\\t&#39;</code> are the new-line and tab characters.</p>\n\n<p>Every file and directory has a unique <strong>absolute path</strong> in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by <code>&#39;/&#39;s</code>. Using the above example, the <strong>absolute path</strong> to <code>file2.ext</code> is <code>&quot;dir/subdir2/subsubdir2/file2.ext&quot;</code>. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form <code>name.extension</code>, where <code>name</code> and <code>extension</code> consist of letters, digits, and/or spaces.</p>\n\n<p>Given a string <code>input</code> representing the file system in the explained format, return <em>the length of the <strong>longest absolute path</strong> to a <strong>file</strong> in the abstracted file system</em>. If there is no file in the system, return <code>0</code>.</p>\n\n<p><strong>Note</strong> that the testcases are generated such that the file system is valid and no file or directory name has length 0.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg\" style=\"width: 401px; height: 202px;\" />\n<pre>\n<strong>Input:</strong> input = &quot;dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext&quot;\n<strong>Output:</strong> 20\n<strong>Explanation:</strong> We have only one file, and the absolute path is &quot;dir/subdir2/file.ext&quot; of length 20.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg\" style=\"width: 641px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> input = &quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot;\n<strong>Output:</strong> 32\n<strong>Explanation:</strong> We have two files:\n&quot;dir/subdir1/file1.ext&quot; of length 21\n&quot;dir/subdir2/subsubdir2/file2.ext&quot; of length 32.\nWe return 32 since it is the longest absolute path to a file.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> input = &quot;a&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> We do not have any files, just a single directory named &quot;a&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= input.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>input</code> may contain lowercase or uppercase English letters, a new line character <code>&#39;\\n&#39;</code>, a tab character <code>&#39;\\t&#39;</code>, a dot <code>&#39;.&#39;</code>, a space <code>&#39; &#39;</code>, and digits.</li>\n\t<li>All file and directory names have <strong>positive</strong> length.</li>\n</ul>\n"},{"id":"2930804","title":"Daily Temperatures","url":"/discuss/topic/2930804/monotonic-stack","questionTitle":"Daily Temperatures","post":{"creationDate":1671513976},"post_data":{"id":2930804,"title":"Monotonic stack","solutionTags":[{"name":"C++"},{"name":"Monotonic Stack"}],"post":{"id":4656313,"content":"# Intuition\nThe idea is to maintain a montonically decreasing stack of temperatures. As soon as you see a value greater than the stack top, you have found the answer for the numbers at stack top which have value lower than current value.\n\n# Approach\nWe will use a monotonically decreasing stack. When we see a value smaller than stack top, just add it to the stack. But if we see a value higher than the stack top then we will update our answer for the stack top and pop from stack. We will keep doing this as long as current value is higher than stack top.\n\n# Complexity\n- Time complexity:\nO(N) where N is the number of days.\n- Space complexity:\nO(N) because stack size could go up to the number of days N.\n\n# Code\n```\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) \n    {\n        int n = temperatures.size();\n        stack<pair<int,int>> stk;\n        vector<int> res(n, 0);\n        for (int i=0; i<n; i++)\n        {\n            while (!stk.empty() && temperatures[i]>stk.top().first)\n            {\n                res[stk.top().second] = i-stk.top().second;\n                stk.pop();\n            }\n            stk.push({temperatures[i],i});\n        }\n        return res;\n    }\n};\n```","creationDate":1671513976}},"acRate":66.32943027934535,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"739","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"daily-temperatures","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Monotonic Stack","id":"VG9waWNUYWdOb2RlOjYxMDU0","slug":"monotonic-stack"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an array of integers <code>temperatures</code> represents the daily temperatures, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is the number of days you have to wait after the</em> <code>i<sup>th</sup></code> <em>day to get a warmer temperature</em>. If there is no future day for which this is possible, keep <code>answer[i] == 0</code> instead.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> temperatures = [73,74,75,71,69,72,76,73]\n<strong>Output:</strong> [1,1,4,2,1,1,0,0]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> temperatures = [30,40,50,60]\n<strong>Output:</strong> [1,1,1,0]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> temperatures = [30,60,90]\n<strong>Output:</strong> [1,1,0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;temperatures.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>30 &lt;=&nbsp;temperatures[i] &lt;= 100</code></li>\n</ul>\n"},{"id":"2930673","title":"Keys and Rooms","url":"/discuss/topic/2930673/dfs-bfs-solutions","questionTitle":"Keys and Rooms","post":{"creationDate":1671512189},"post_data":{"id":2930673,"title":"DFS + BFS solutions","solutionTags":[{"name":"C++"},{"name":"Depth-First Search"},{"name":"Breadth-First Search"},{"name":"Graph"}],"post":{"id":4656152,"content":"# Intuition\nThis is a straightforward graph traversal problem.\n# Approach\nWe can do a simple BFS or DFS traversal to solve this.\n# Complexity\n- Time complexity:\nO(V) where V is the number of rooms\n- Space complexity:\nO(V) where V is the number of rooms\n# Code\n## BFS solution\n```\nclass Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        vector<bool> visited = vector<bool>(n,false);\n        queue<int> Q;\n        Q.push(0);\n        while (!Q.empty())\n        {\n            for (int i=Q.size(); i>0; i--)\n            {\n                int cur = Q.front();\n                Q.pop();\n                visited[cur] = true;\n                for (int adj: rooms[cur]) if (!visited[adj]) Q.push(adj);\n            }\n        }\n        for (bool v: visited) if (!v) return false;\n        return true;\n    }\n};\n```\n## DFS solution\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<int>> &rooms, vector<bool>&visited, int u)\n    {\n        visited[u] = true;\n        for (int v: rooms[u]) if (!visited[v]) dfs(rooms,visited,v);\n    }\n    bool canVisitAllRooms(vector<vector<int>>& rooms) \n    {\n        int n = rooms.size();\n        vector<bool> visited = vector<bool>(n,false);\n        dfs(rooms, visited, 0);\n        for (bool v: visited) if (!v) return false;\n        return true;\n    }\n};\n```","creationDate":1671512189}},"acRate":71.43009200125877,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"841","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"keys-and-rooms","topicTags":[{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Graph","id":"VG9waWNUYWdOb2RlOjI0","slug":"graph"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>There are <code>n</code> rooms labeled from <code>0</code> to <code>n - 1</code>&nbsp;and all the rooms are locked except for room <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p>\n\n<p>When you visit a room, you may find a set of <strong>distinct keys</strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p>\n\n<p>Given an array <code>rooms</code> where <code>rooms[i]</code> is the set of keys that you can obtain if you visited room <code>i</code>, return <code>true</code> <em>if you can visit <strong>all</strong> the rooms, or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[1],[2],[3],[]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[1,3],[3,0,1],[2],[0]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We can not enter room number 2 since the only key that unlocks it is in that room.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li>\n\t<li><code>0 &lt;= rooms[i][j] &lt; n</code></li>\n\t<li>All the values of <code>rooms[i]</code> are <strong>unique</strong>.</li>\n</ul>\n"},{"id":"2865494","title":"Human Traffic of Stadium","url":"/discuss/topic/2865494/hacky-solution","questionTitle":"Human Traffic of Stadium","post":{"creationDate":1669880386},"post_data":{"id":2865494,"title":"Hacky solution","solutionTags":[],"post":{"id":4570559,"content":"\n```\nselect distinct st.id,visit_date,st.people from stadium st join\n(\n    select * from\n    (\n        select id,people from stadium where people >= 100\n    ) as T1\n    inner join\n    (\n        select (id-1) as id2, people as people2 from stadium\n    ) as T2\n    inner join\n    (\n        select (id-2) as id3, people as people3 from stadium\n    ) as T3\n    on \n    T1.id = T2.id2 and T1.id=T3.id3\n    where people2>=100 and people3>=100\n) as T4\non st.id=T4.id or st.id-1=T4.id or st.id-2=T4.id\norder by visit_date asc\n```","creationDate":1669880386}},"acRate":50.1723253397177,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"601","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"human-traffic-of-stadium","topicTags":[{"name":"Database","id":"VG9waWNUYWdOb2RlOjYxMDQz","slug":"database"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Table: <code>Stadium</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| visit_date    | date    |\n| people        | int     |\n+---------------+---------+\nvisit_date is the primary key for this table.\nEach row of this table contains the visit date and visit id to the stadium with the number of people during the visit.\nNo two rows will have the same visit_date, and as the id increases, the dates increase as well.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write an SQL query to display the records with three or more rows with <strong>consecutive</strong> <code>id</code>&#39;s, and the number of people is greater than or equal to 100 for each.</p>\n\n<p>Return the result table ordered by <code>visit_date</code> in <strong>ascending order</strong>.</p>\n\n<p>The query result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nStadium table:\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>Output:</strong> \n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>Explanation:</strong> \nThe four rows with ids 5, 6, 7, and 8 have consecutive ids and each of them has &gt;= 100 people attended. Note that row 8 was included even though the visit_date was not the next day after row 7.\nThe rows with ids 2 and 3 are not included because we need at least three consecutive ids.\n</pre>\n"},{"id":"2865333","title":"Department Top Three Salaries","url":"/discuss/topic/2865333/dense-rank","questionTitle":"Department Top Three Salaries","post":{"creationDate":1669877422},"post_data":{"id":2865333,"title":"Dense rank","solutionTags":[],"post":{"id":4570352,"content":"To understand this, you need to understand rank and dense rank.\n# Rank\nSay you have these `(name,salary)` rows in table T as\n```\n(A,100), (B,200), (C,200)\n```\nThen\nthe result of query\n```\nselect *,rank() over(order by salary desc) as sal_rank from T\n```\nwill be\n```\n(B,200,1),(C,200,1),(A,100,3)\n```\nie in case of clash same rank is given to all clashing and some ranks will be skipped.\n\nHowever `dense_rank` query\n```\nselect *,dense_rank() over(order by salary desc) as sal_rank from T\n```\nwill give following output\n```\n(B,200,1),(C,200,1),(A,100,2)\n```\nie same rank is given for clash similar to `rank()` but no ranks are skipped.\n\nOther trick to know is `partition by` inside the `over()` argument in `dense_rank()` function, just add `partition by dept` then, the ranks will be for people having same value of `dept`.\n\n# SQL code:\n\n```\nselect department,employee,salary from (\nselect *, dense_rank() over (partition by department order by salary desc) as sal_rank from \n(select E.name as employee,D.name as department,E.salary from employee E inner join department D on E.departmentid = D.id) as T1\n) as T2\nwhere T2.sal_rank<=3\n```","creationDate":1669877422}},"acRate":50.30785719297142,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"185","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"department-top-three-salaries","topicTags":[{"name":"Database","id":"VG9waWNUYWdOb2RlOjYxMDQz","slug":"database"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Table: <code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key column for this table.\ndepartmentId is a foreign key of the ID from the <code>Department </code>table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key column for this table.\nEach row of this table indicates the ID of a department and its name.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>A company&#39;s executives are interested in seeing who earns the most money in each of the company&#39;s departments. A <strong>high earner</strong> in a department is an employee who has a salary in the <strong>top three unique</strong> salaries for that department.</p>\n\n<p>Write an SQL query to find the employees who are <strong>high earners</strong> in each of the departments.</p>\n\n<p>Return the result table <strong>in any order</strong>.</p>\n\n<p>The query result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<strong>Output:</strong> \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Joe      | 85000  |\n| IT         | Randy    | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n<strong>Explanation:</strong> \nIn the IT department:\n- Max earns the highest unique salary\n- Both Randy and Joe earn the second-highest unique salary\n- Will earns the third-highest unique salary\n\nIn the Sales department:\n- Henry earns the highest salary\n- Sam earns the second-highest salary\n- There is no third-highest salary as there are only two employees\n</pre>\n"},{"id":"2862161","title":"Paths in Matrix Whose Sum Is Divisible by K","url":"/discuss/topic/2862161/3d-dp-table","questionTitle":"Paths in Matrix Whose Sum Is Divisible by K","post":{"creationDate":1669793681},"post_data":{"id":2862161,"title":"3D DP table","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":4566216,"content":"Firstly a note regarding notation, I have replaced small k with capital K and I am using small k for indexing.\n# Algorithm:\nWe will create a DP table of shape `(M,N,K)` where `dp[i][j][k]` denotes number of ways to reach `(i,j)` coordinate with `sum%K==k`. At the end we will return `dp[M-1][N-1][0]`.\n\nNow for `(0,0)` there is one way to reach `dp[0][0]%K` but for other values of k, there is no way to achieve that sum.\n\n## Recurrence relation\n```\ndp[i][j][k] = A + B\n```\n\nwhere A is the number of ways to reach `(i,j)` via `(i,j-1)` and B is the number of ways to reach `(i,j)` via `(i-1,j)`\nNow we know that `A = dp[i][j-1][idx]`. We want to find this `idx`\nSuppose `grid[i][j]%K==x`. Then \n```\nidx = (K + k - x) % K\n```\nThis `idx` value is same even for `(i-1,j)`\n\n# C++ code:\n```\nclass Solution {\npublic:\n    int numberOfPaths(vector<vector<int>>& grid, int K) \n    {\n        int m=grid.size(), n=grid[0].size(), mod=1000000007;\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n,vector<int>(K,0)));\n        dp[0][0][grid[0][0]%K]++;\n        for (int i=0; i<m; i++)\n            for (int j=0; j<n; j++)\n                for (int k=0; k<K; k++)\n                {\n                    if (i==0 && j==0) continue;\n                    int a = ((j==0) ? 0 : dp[i][j-1][(K+k-grid[i][j]%K)%K] % mod);\n                    int b = ((i==0) ? 0 : dp[i-1][j][(K+k-grid[i][j]%K)%K] % mod);\n                    dp[i][j][k] = (a+b)%mod;\n                }\n        return dp[m-1][n-1][0];\n    }\n};\n```","creationDate":1669793681}},"acRate":41.46037853283164,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"2435","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"paths-in-matrix-whose-sum-is-divisible-by-k","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code> and an integer <code>k</code>. You are currently at position <code>(0, 0)</code> and you want to reach position <code>(m - 1, n - 1)</code> moving only <strong>down</strong> or <strong>right</strong>.</p>\n\n<p>Return<em> the number of paths where the sum of the elements on the path is divisible by </em><code>k</code>. Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/08/13/image-20220813183124-1.png\" style=\"width: 437px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two paths where the sum of the elements on the path is divisible by k.\nThe first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.\nThe second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/08/17/image-20220817112930-3.png\" style=\"height: 85px; width: 132px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0]], k = 5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/08/12/image-20220812224605-3.png\" style=\"width: 257px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 50</code></li>\n</ul>\n"},{"id":"2849626","title":"Maximum Profit in Job Scheduling","url":"/discuss/topic/2849626/explained-example-dp-knapsack-oop-faster-than-97","questionTitle":"Maximum Profit in Job Scheduling","post":{"creationDate":1669455269},"post_data":{"id":2849626,"title":"[Explained + Example] DP (Knapsack)+ OOP Faster than 97%","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":4549524,"content":"# Explanation\nWe sort the jobs by their ending times.\nNow as we traverse through the `jobs` array, we are going to apply a logic similar to Knapsack:\n- We maintain a `dp` array of `(endTime,maxProfitTillHere)` entities. We initialize it to `[(0,0)]`.\n- For each job, we have two options: (i) To do this job: in this case we need to find the `maxProfit` till the time before the `startTime` of current job. (ii) Not do this job: in the case we will have the same `maxProfit`till the previous `dp` member.\n- This is equivalent to the two options we have in a knapsack problem.\n\n# Example\n```\nInput: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n```\n\nThen sorted by endTime, we will have\n```\njobs = [(1,3,50),(2,4,10),(3,5,40),(3,6,70)]\n```\nInitialize dp:\n```\ndp = [(0,0)]`\n```\nAt i=0,\n```\noption_A = 0+50\noption_B = 0\n```\ndp gets appended.\n```\ndp = [(0,0),(3,50)]\n```\nAt i=1, Job = (2,4,10):\n```\noption_A = 0+10\noption_B = 50\n```\ndp remains same.\n```\ndp = [(0,0),(3,50)]\n```\nAt i=2, Job = (3,5,40):\n```\noption_A = 50+40\noption_B = 50\n```\ndp gets appended\n```\ndp = [(0,0),(3,50),(5,90)]\n```\nAt i=3, Job = (3,6,70):\n```\noption_A = 50+70\noption_B = 90\n```\ndp gets appended\n```\ndp = [(0,0),(3,50),(5,90),(6,120)]\n```\nFinally answer is 120.\n\nFor implementation we create a custom class `Job`. For the DP part, we just use `startTime=-1` for all timestamps as it does not matter.\n# C++ code:\n\n```\nclass Job\n{\n    public:\n    int startTime, endTime, profit;\n    Job(int s, int e, int p): startTime(s), endTime(e), profit(p) {}\n    bool operator <  (const Job &other_job)const{return endTime  < other_job.endTime;}\n    bool operator == (const Job &other_job)const{return endTime == other_job.endTime;}\n};\n\nclass Solution {\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) \n    {\n        int n = startTime.size();\n        vector<Job> jobs;\n        for (int i=0; i<n; i++)\n            jobs.push_back(Job(startTime[i],endTime[i],profit[i]));\n        sort(jobs.begin(),jobs.end());\n        \n        vector<Job> dp = vector<Job>{Job(-1,0,0)};\n        for (const Job &job: jobs)\n        {\n            auto itr = upper_bound(dp.begin(),dp.end(),Job(-1,job.startTime,-1));\n            int idx = itr-dp.begin()-1;\n            int opt_A = dp[idx].profit + job.profit;\n            int opt_B = dp.rbegin()->profit;\n            if (opt_A > opt_B)\n                dp.push_back(Job(-1,job.endTime, opt_A));\n        }\n        return dp.rbegin()->profit;\n    }\n};\n```","creationDate":1669455269}},"acRate":53.45886711843543,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"1235","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"maximum-profit-in-job-scheduling","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>We have <code>n</code> jobs, where every job is scheduled to be done from <code>startTime[i]</code> to <code>endTime[i]</code>, obtaining a profit of <code>profit[i]</code>.</p>\n\n<p>You&#39;re given the <code>startTime</code>, <code>endTime</code> and <code>profit</code> arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.</p>\n\n<p>If you choose a job that ends at time <code>X</code> you will be able to start another job that starts at time <code>X</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png\" style=\"width: 380px; height: 154px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n<strong>Output:</strong> 120\n<strong>Explanation:</strong> The subset chosen is the first and fourth job. \nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png\" style=\"width: 600px; height: 112px;\" /> </strong></p>\n\n<pre>\n<strong>Input:</strong> startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n<strong>Output:</strong> 150\n<strong>Explanation:</strong> The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png\" style=\"width: 400px; height: 112px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n<strong>Output:</strong> 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= profit[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"},{"id":"2830288","title":"Is Graph Bipartite?","url":"/discuss/topic/2830288/bfs","questionTitle":"Is Graph Bipartite?","post":{"creationDate":1668867339},"post_data":{"id":2830288,"title":"BFS","solutionTags":[{"name":"C++"},{"name":"Breadth-First Search"}],"post":{"id":4523033,"content":"The idea is to check if a two-color coloring can be done to the graph. Colors={1,-1} and 0 denotes uncolored. Start with node 0 and traverse by BFS. Then for any other connected component repeat. To do this, we can run for all i from 0 to n and only start doing BFS if it is uncolored.\n\nNote that uncolored = unvisited.\n\n\n```\nclass Solution {\npublic:\n    bool isBipartite(vector<vector<int>>& graph) \n    {\n        int V = graph.size();\n        vector<int> colors = vector<int>(V,0);\n        queue<int> Q;\n\n        for (int i=0; i<V; i++)\n        {\n            if (colors[i]!=0) continue;\n            colors[i] = 1;\n            Q.push(i);\n            while(!Q.empty())\n            {\n                int u = Q.front();\n                Q.pop();\n                for (int v: graph[u])\n                {\n                    if (colors[v]==0)\n                    {\n                        colors[v] = -colors[u];\n                        Q.push(v);\n                    }\n                    else\n                        if (colors[v]==colors[u])\n                            return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```","creationDate":1668867339}},"acRate":53.00188927221948,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"785","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"is-graph-bipartite","topicTags":[{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Union Find","id":"VG9waWNUYWdOb2RlOjIz","slug":"union-find"},{"name":"Graph","id":"VG9waWNUYWdOb2RlOjI0","slug":"graph"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:</p>\n\n<ul>\n\t<li>There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).</li>\n\t<li>There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).</li>\n\t<li>If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</li>\n\t<li>The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.</li>\n</ul>\n\n<p>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.</p>\n\n<p>Return <code>true</code><em> if and only if it is <strong>bipartite</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>graph.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= graph[u].length &lt; n</code></li>\n\t<li><code>0 &lt;= graph[u][i] &lt;= n - 1</code></li>\n\t<li><code>graph[u]</code>&nbsp;does not contain&nbsp;<code>u</code>.</li>\n\t<li>All the values of <code>graph[u]</code> are <strong>unique</strong>.</li>\n\t<li>If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.</li>\n</ul>\n"},{"id":"2822950","title":"Rectangle Area","url":"/discuss/topic/2822950/overlapping-intervals-expand-idea-from-1d","questionTitle":"Rectangle Area","post":{"creationDate":1668665158},"post_data":{"id":2822950,"title":"Overlapping intervals expand idea from 1D","solutionTags":[{"name":"C++"}],"post":{"id":4513234,"content":"First let us solve the problem in 1D:\n**Given Two intervals (a1,a2) and (b1,b2) find if they are overlapping or not**\nWell, the answer is they are overlapping if \n```\nbool overlap = a1 < b2 && a2 > b1;\n```\n\n**What is the length of this overlap?**\nWell the length of overlap is\n```\nint L_overlap= min(a2,b2) - max(a1,b1);\n```\n\n**So, what is the total length**\n```\nint L1 = (a2-a1),   L2 = (b2-b1);\nint L_total = (overlap ? L1+L2-L_overlap : L1+L2);\n```\n\nNow we will expand this idea to 2D.\nThe only crucial difference is that the overlap happens only if the overlap condition is met in both X and Y directions.\n\nC++ code:\n```\nclass Solution {\npublic:\n    int area(int x1, int y1, int x2, int y2)\n    {\n        return (x2-x1) * (y2-y1);\n    }\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n        int A = area(ax1,ay1,ax2,ay2);\n        int B = area(bx1,by1,bx2,by2);        \n        bool overlap_x = bx1 < ax2 && bx2 > ax1;\n        bool overlap_y = by1 < ay2 && by2 > ay1;\n        if (!overlap_x || !overlap_y) return A + B;\n        int cx1 = max(ax1,bx1);\n        int cy1 = max(ay1,by1);\n        int cx2 = min(ax2,bx2);\n        int cy2 = min(ay2,by2);\n        int C = area(cx1,cy1,cx2,cy2);                \n        return A + B - C;\n    }\n};\n```","creationDate":1668665158}},"acRate":45.04663110554246,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"223","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"rectangle-area","topicTags":[{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"Geometry","id":"VG9waWNUYWdOb2RlOjM4","slug":"geometry"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the coordinates of two <strong>rectilinear</strong> rectangles in a 2D plane, return <em>the total area covered by the two rectangles</em>.</p>\n\n<p>The first rectangle is defined by its <strong>bottom-left</strong> corner <code>(ax1, ay1)</code> and its <strong>top-right</strong> corner <code>(ax2, ay2)</code>.</p>\n\n<p>The second rectangle is defined by its <strong>bottom-left</strong> corner <code>(bx1, by1)</code> and its <strong>top-right</strong> corner <code>(bx2, by2)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"Rectangle Area\" src=\"https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png\" style=\"width: 700px; height: 365px;\" />\n<pre>\n<strong>Input:</strong> ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n<strong>Output:</strong> 45\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n<strong>Output:</strong> 16\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>4</sup> &lt;= ax1 &lt;= ax2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= ay1 &lt;= ay2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= bx1 &lt;= bx2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= by1 &lt;= by2 &lt;= 10<sup>4</sup></code></li>\n</ul>\n"},{"id":"2822056","title":"Count Complete Tree Nodes","url":"/discuss/topic/2822056/recursivle-solution-with-explanation","questionTitle":"Count Complete Tree Nodes","post":{"creationDate":1668635378},"post_data":{"id":2822056,"title":"Recursivle solution with explanation","solutionTags":[{"name":"C++"},{"name":"Tree"},{"name":"Recursion"}],"post":{"id":4511990,"content":"First, let us define the concept of a \"full\" tree: a tree with no null nodes in the last level ie full upto its complete height.\n(Consider height of root as 0, level 1 as 1 etc)\n**IMP: What is the #(Nodes) in a full tree of height h**\nAns: `2^(h+1) - 1`\n\nNow, given that we have \"complete\" tree of height `h`, we can say that either the left subtree is a \"full\" tree of height `h-1` or the right subtree is a \"full\" tree of height `h-2`. \n\nIn the first case we have\n```\ncountNodes(root) = 2^h + countNodes(root->right)\n```\n(`2^h = 2^h - 1` for left subtree and `1` for root)\nand in the second case, we have\n\n```\ncountNodes(root) = 2^(h-1) + countNodes(root->left)\n```\n(`2^(h-1) = 2^(h-1) - 1` for right subtree and `1` for root)\n\nC++ code:\n```\nclass Solution {\npublic:\n    int height(TreeNode *root)\n    {\n        return root == NULL ? -1 : 1+height(root->left);\n    }\n    int countNodes(TreeNode* root) \n    {\n        if (!root) return 0;\n        int h = height(root);\n        if (h==0) return 1;\n        if (height(root->right)==h-1)\n            return (1<<h) + countNodes(root->right);\n        else\n            return (1<<h-1) + countNodes(root->left);\n        return -1;\n    }\n};\n```\n```\nTC=O((log n)^2)\n```\n","creationDate":1668635378}},"acRate":60.295432622115065,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"222","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"count-complete-tree-nodes","topicTags":[{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"},{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>\n\n<p>According to <strong><a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>\n\n<p>Design an algorithm that runs in less than&nbsp;<code data-stringify-type=\"code\">O(n)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" style=\"width: 372px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>The tree is guaranteed to be <strong>complete</strong>.</li>\n</ul>\n"},{"id":"2819522","title":"Word Search II","url":"/discuss/topic/2819522/explained-trie-dfs-clean-c-code","questionTitle":"Word Search II","post":{"creationDate":1668576290},"post_data":{"id":2819522,"title":"[Explained] Trie + DFS Clean C++ code","solutionTags":[{"name":"C++"},{"name":"Depth-First Search"},{"name":"Trie"}],"post":{"id":4508695,"content":"Step 1 is to build Trie. This should be simple enough if you have done [this](https://leetcode.com/problems/implement-trie-prefix-tree/).\n\nStep 2 is to do DFS and pass this Trie as an argument of DFS. In a simpler implemtation, you can pass the same trie that we constructed again and again and search from root using `hasPrefix` and `hasWord` to look for candidates but this will give you a TLE because it is traversing from the root node again and again. The more efficient way is to pass child trie in the recursive call, so we dont actually need `hasPrefix` or `hasWord`. Nevertheless I have left it as it helps us to understand Trie concept.\n\nYou might still get a TLE. Now, change the arguments `board` to pass only reference to avoid time of copying in memory for each recursive call. \n\nThis gives us an AC.\n\n```\n\nclass Trie\n{\n    public:\n    vector<Trie *> children = vector<Trie *>(26, NULL);\n    bool isEnd = false;\n    void insert(string word, int pos=0)\n    {\n        if (pos==word.length())\n        {\n            isEnd = true;\n            return;\n        }\n        int idx = word[pos]-\"a\";\n        if (children[idx]==NULL)\n            children[idx] = new Trie;\n        children[idx]->insert(word, pos+1);\n    }\n    bool hasPrefix(string prefix, int pos=0)\n    {\n        if (pos==prefix.length()) return true;\n        int idx = prefix[pos]-\"a\";\n        if (children[idx]==NULL) return false;\n        return children[idx]->hasPrefix(prefix, pos+1);\n    }\n    bool hasWord(string word, int pos=0)\n    {\n        if (pos==word.length()) return isEnd;\n        int idx = word[pos]-\"a\";\n        if (children[idx]==NULL) return false;\n        return children[idx]->hasWord(word, pos+1);\n    }\n};\n\nclass Solution {\npublic:\n    void dfs(vector<vector<char>> &board, int i, int j, int m, int n, Trie *trie, unordered_set<string>&res,string &curr)\n    {\n        if (board[i][j]==\"*\") return;\n        int idx = board[i][j]-\"a\";\n        Trie *child_trie = trie->children[idx];\n        if (child_trie==NULL) return;\n        curr.push_back(board[i][j]);\n        if (child_trie->isEnd) res.insert(curr);\n        board[i][j] = \"*\";\n        if (i-1>=0) dfs(board,i-1,j,m,n,child_trie,res,curr);\n        if (i+1<m)  dfs(board,i+1,j,m,n,child_trie,res,curr);\n        if (j-1>=0) dfs(board,i,j-1,m,n,child_trie,res,curr);\n        if (j+1<n)  dfs(board,i,j+1,m,n,child_trie,res,curr);\n        board[i][j] = \"a\"+idx;\n        curr.pop_back();\n    }\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) \n    {\n        Trie *trie = new Trie;\n        for (string word: words)\n            trie->insert(word);\n\n        // Code for testing Trie\n        // for (string w: vector<string>{\"oat\",\"oath\",\"oaths\",\"oas\",\"aoth\",\"eat\"})\n        //     cout << w << \" hasPrefix: \" << trie.hasPrefix(w) << \" hasWord: \" << trie.hasWord(w) << endl;\n\n        int m=board.size(), n=board[0].size();\n        unordered_set<string> res;\n        for (int i=0; i<m; i++)\n            for (int j=0; j<n; j++)\n            {\n                string cur=\"\";\n                dfs(board, i, j, m, n, trie, res, cur);\n            }\n        vector<string>resv;\n        for(string s: res) resv.push_back(s);\n        return resv;\n    }\n};\n```\n\nNote: My old code which gave TLE for large input can be found [here](https://leetcode.com/submissions/detail/844142181/). It is simpler in implementation but calls `hasPrefix` again and again which traverses from root everytime.","creationDate":1668576290}},"acRate":36.53431730156823,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"212","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"word-search-ii","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Backtracking","id":"VG9waWNUYWdOb2RlOjE0","slug":"backtracking"},{"name":"Trie","id":"VG9waWNUYWdOb2RlOjI3","slug":"trie"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an <code>m x n</code> <code>board</code>&nbsp;of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>\n\n<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search1.jpg\" style=\"width: 322px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]\n<strong>Output:</strong> [&quot;eat&quot;,&quot;oath&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>board[i][j]</code> is a lowercase English letter.</li>\n\t<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are unique.</li>\n</ul>\n"},{"id":"2810978","title":"Reverse Words in a String","url":"/discuss/topic/2810978/one-liner","questionTitle":"Reverse Words in a String","post":{"creationDate":1668347210},"post_data":{"id":2810978,"title":"    One Liner","solutionTags":[{"name":"Python"}],"post":{"id":4497016,"content":"Python has stuff like `split`, `reversed` and `join` which lets us write a 1-liner.\n```\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(reversed(s.split()))\n```","creationDate":1668347210}},"acRate":32.47631441102231,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"151","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"reverse-words-in-a-string","topicTags":[{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>\n\n<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>\n\n<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>\n\n<p><b>Note</b> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;the sky is blue&quot;\n<strong>Output:</strong> &quot;blue is sky the&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;  hello world  &quot;\n<strong>Output:</strong> &quot;world hello&quot;\n<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a good   example&quot;\n<strong>Output:</strong> &quot;example good a&quot;\n<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b data-stringify-type=\"bold\">Follow-up:&nbsp;</b>If the string data type is mutable in your language, can&nbsp;you solve it&nbsp;<b data-stringify-type=\"bold\">in-place</b>&nbsp;with&nbsp;<code data-stringify-type=\"code\">O(1)</code>&nbsp;extra space?</p>\n"},{"id":"2810955","title":"Kth Largest Element in a Stream","url":"/discuss/topic/2810955/min-heap","questionTitle":"Kth Largest Element in a Stream","post":{"creationDate":1668346642},"post_data":{"id":2810955,"title":"Min Heap","solutionTags":[{"name":"Heap (Priority Queue)"}],"post":{"id":4496982,"content":"Maintain the highest K elements in a min Heap. Then the root node is always the answer.\n```\nclass KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int k;\n    KthLargest(int k, vector<int>& nums): k(k)\n    {\n        for (int n: nums) pq.push(n);\n        while (pq.size()>k) pq.pop();\n    }\n    \n    int add(int val) \n    {\n        pq.push(val);\n        while(pq.size()>k) pq.pop();\n        return pq.top();\n    }\n};\n```","creationDate":1668346642}},"acRate":55.43862028136126,"difficulty":"Easy","freqBar":null,"frontendQuestionId":"703","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"kth-largest-element-in-a-stream","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"},{"name":"Binary Search Tree","id":"VG9waWNUYWdOb2RlOjMw","slug":"binary-search-tree"},{"name":"Heap (Priority Queue)","id":"VG9waWNUYWdOb2RlOjYxMDUw","slug":"heap-priority-queue"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"},{"name":"Data Stream","id":"VG9waWNUYWdOb2RlOjYxMDYz","slug":"data-stream"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Design a class to find the <code>k<sup>th</sup></code> largest element in a stream. Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p>\n\n<p>Implement <code>KthLargest</code> class:</p>\n\n<ul>\n\t<li><code>KthLargest(int k, int[] nums)</code> Initializes the object with the integer <code>k</code> and the stream of integers <code>nums</code>.</li>\n\t<li><code>int add(int val)</code> Appends the integer <code>val</code> to the stream and returns the element representing the <code>k<sup>th</sup></code> largest element in the stream.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n<strong>Output</strong>\n[null, 4, 5, 5, 8, 8]\n\n<strong>Explanation</strong>\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= val &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>.</li>\n\t<li>It is guaranteed that there will be at least <code>k</code> elements in the array when you search for the <code>k<sup>th</sup></code> element.</li>\n</ul>\n"},{"id":"2810670","title":"Minimum Number of Operations to Sort a Binary Tree by Level","url":"/discuss/topic/2810670/bfs-min-swaps-to-sort","questionTitle":"Minimum Number of Operations to Sort a Binary Tree by Level","post":{"creationDate":1668341117},"post_data":{"id":2810670,"title":"BFS + Min swaps to sort","solutionTags":[{"name":"C++"},{"name":"Breadth-First Search"}],"post":{"id":4496615,"content":"Use BFS to get nodes at each level. Then we need an algorithm to find minimum number of swaps to sort an array. I used [this reference](https://www.youtube.com/watch?v=kFe_LRWuZjE) for this part. The idea is simple: Traverse through sorted version of array and try to get back original array by swapping repeatedly.\n\n```\nclass Solution {\npublic:\n    int numSwaps(vector<int> &A)\n    {\n        int swaps = 0, n=A.size();\n        vector<pair<int,int>> vec;\n        for (int i=0; i<n; i++) vec.push_back({A[i],i});\n        sort(vec.begin(),vec.end());\n        for (int i=0; i<n; i++)\n        {\n            int value=vec[i].first, index=vec[i].second;\n            if (i!=index)\n            {\n                swaps++;\n                swap(vec[i], vec[index]);\n                i--;\n            }\n        }\n        return swaps;\n    }\n    int minimumOperations(TreeNode* root) \n    {\n        queue<TreeNode *>Q;\n        Q.push(root);\n        int ctr = 0;\n        while(!Q.empty())\n        {\n            vector<int> vals;\n            for (int i=Q.size(); i>0; i--)\n            {\n                TreeNode *u = Q.front();\n                Q.pop();\n                vals.push_back(u->val);\n                if (u->left) Q.push(u->left);\n                if (u->right) Q.push(u->right);\n            }\n            if (vals.size()<=1) continue;\n            ctr += numSwaps(vals);\n        }\n        return ctr;\n    }\n};\n```","creationDate":1668341117}},"acRate":62.47009945864283,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"2471","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"minimum-number-of-operations-to-sort-a-binary-tree-by-level","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>You are given the <code>root</code> of a binary tree with <strong>unique values</strong>.</p>\n\n<p>In one operation, you can choose any two nodes <strong>at the same level</strong> and swap their values.</p>\n\n<p>Return <em>the minimum number of operations needed to make the values at each level sorted in a <strong>strictly increasing order</strong></em>.</p>\n\n<p>The <strong>level</strong> of a node is the number of edges along the path between it and the root node<em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png\" style=\"width: 500px; height: 324px;\" />\n<pre>\n<strong>Input:</strong> root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\n- Swap 4 and 3. The 2<sup>nd</sup> level becomes [3,4].\n- Swap 7 and 5. The 3<sup>rd</sup> level becomes [5,6,8,7].\n- Swap 8 and 7. The 3<sup>rd</sup> level becomes [5,6,7,8].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png\" style=\"width: 400px; height: 303px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,2,7,6,5,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\n- Swap 3 and 2. The 2<sup>nd</sup> level becomes [2,3].\n- Swap 7 and 4. The 3<sup>rd</sup> level becomes [4,6,5,7].\n- Swap 6 and 5. The 3<sup>rd</sup> level becomes [4,5,6,7].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png\" style=\"width: 400px; height: 274px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Each level is already sorted in increasing order so return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>All the values of the tree are <strong>unique</strong>.</li>\n</ul>\n"},{"id":"2805260","title":"Odd String Difference","url":"/discuss/topic/2805260/o1-space-100-faster","questionTitle":"Odd String Difference","post":{"creationDate":1668223437},"post_data":{"id":2805260,"title":"O(1) space + 100% faster","solutionTags":[{"name":"C++"}],"post":{"id":4488947,"content":"```\nclass Solution {\npublic:\n    string oddString(vector<string>& words) \n    {\n        int m=words.size(), n=words[0].length();\n        for(int j=1; j<n; j++)\n        {\n            int dA = words[0][j]-words[0][j-1];\n            int dB = words[1][j]-words[1][j-1];\n            if (dA!=dB)\n            {\n                int dC = words[2][j]-words[2][j-1];\n                return ((dC==dA) ? words[1] : words[0]);\n            }\n            // dA==dB\n            for (int i=2; i<m; i++)\n            {\n                int diff = words[i][j]-words[i][j-1];\n                if (diff!=dA) return words[i];\n            }\n        }\n        return \"\";\n    }\n};\n```","creationDate":1668223437}},"acRate":60.237471952131635,"difficulty":"Easy","freqBar":null,"frontendQuestionId":"2451","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"odd-string-difference","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>You are given an array of equal-length strings <code>words</code>. Assume that the length of each string is <code>n</code>.</p>\n\n<p>Each string <code>words[i]</code> can be converted into a <strong>difference integer array</strong> <code>difference[i]</code> of length <code>n - 1</code> where <code>difference[i][j] = words[i][j+1] - words[i][j]</code> where <code>0 &lt;= j &lt;= n - 2</code>. Note that the difference between two letters is the difference between their <strong>positions</strong> in the alphabet i.e.&nbsp;the position of <code>&#39;a&#39;</code> is <code>0</code>, <code>&#39;b&#39;</code> is <code>1</code>, and <code>&#39;z&#39;</code> is <code>25</code>.</p>\n\n<ul>\n\t<li>For example, for the string <code>&quot;acb&quot;</code>, the difference integer array is <code>[2 - 0, 1 - 2] = [2, -1]</code>.</li>\n</ul>\n\n<p>All the strings in words have the same difference integer array, <strong>except one</strong>. You should find that string.</p>\n\n<p>Return<em> the string in </em><code>words</code><em> that has different <strong>difference integer array</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;adc&quot;,&quot;wzy&quot;,&quot;abc&quot;]\n<strong>Output:</strong> &quot;abc&quot;\n<strong>Explanation:</strong> \n- The difference integer array of &quot;adc&quot; is [3 - 0, 2 - 3] = [3, -1].\n- The difference integer array of &quot;wzy&quot; is [25 - 22, 24 - 25]= [3, -1].\n- The difference integer array of &quot;abc&quot; is [1 - 0, 2 - 1] = [1, 1]. \nThe odd array out is [1, 1], so we return the corresponding string, &quot;abc&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;aaa&quot;,&quot;bob&quot;,&quot;ccc&quot;,&quot;ddd&quot;]\n<strong>Output:</strong> &quot;bob&quot;\n<strong>Explanation:</strong> All the integer arrays are [0, 0] except for &quot;bob&quot;, which corresponds to [13, -13].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>n == words[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 20</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n"},{"id":"2764996","title":"Where Will the Ball Fall","url":"/discuss/topic/2764996/just-play-the-game","questionTitle":"Where Will the Ball Fall","post":{"creationDate":1667265982},"post_data":{"id":2764996,"title":"Just play the game!","solutionTags":[],"post":{"id":4434753,"content":"Just follow the rules and play the game.\n- If you get stuck on the left or right edge, return -1\n- If you get stuck in a V shape pattern return -1\n- If exit from the last row, return column index.\n\n**Well thats it. Now just play the game!**\n```\nclass Solution {\npublic:\n    int playGame(vector<vector<int>>&grid, int i, int j, int m, int n)\n    {\n        if (i==m) return j;\n        if (j<n-1 && grid[i][j]== 1 && grid[i][j+1]==-1) return -1;\n        if (j>0   && grid[i][j]==-1 && grid[i][j-1]== 1) return -1;\n        if (j==0 && grid[i][j] ==-1) return -1;\n        if (j==n-1 && grid[i][j]==1) return -1;\n        if (grid[i][j]==1) \n            return playGame(grid,i+1, j+1, m, n);\n        return playGame(grid,i+1,j-1,m,n);\n    }\n    \n    vector<int> findBall(vector<vector<int>>& grid) \n    {\n        int m=grid.size(), n=grid[0].size();\n        vector<int>res(n,0);\n        for (int j=0; j<n; ++j)\n            res[j] = playGame(grid,0,j,m,n);\n        return res;\n    }\n};\n```","creationDate":1667265982}},"acRate":71.54503970814223,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1706","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"where-will-the-ball-fall","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"},{"name":"Simulation","id":"VG9waWNUYWdOb2RlOjYxMDU1","slug":"simulation"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You have a 2-D <code>grid</code> of size <code>m x n</code> representing a box, and you have <code>n</code> balls. The box is open on the top and bottom sides.</p>\n\n<p>Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.</p>\n\n<ul>\n\t<li>A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as <code>1</code>.</li>\n\t<li>A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as <code>-1</code>.</li>\n</ul>\n\n<p>We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a &quot;V&quot; shaped pattern between two boards or if a board redirects the ball into either wall of the box.</p>\n\n<p>Return <em>an array </em><code>answer</code><em> of size </em><code>n</code><em> where </em><code>answer[i]</code><em> is the column that the ball falls out of at the bottom after dropping the ball from the </em><code>i<sup>th</sup></code><em> column at the top, or <code>-1</code><em> if the ball gets stuck in the box</em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/26/ball.jpg\" style=\"width: 500px; height: 385px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\n<strong>Output:</strong> [1,-1,-1,-1,-1]\n<strong>Explanation:</strong> This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[-1]]\n<strong>Output:</strong> [-1]\n<strong>Explanation:</strong> The ball gets stuck against the left wall.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\n<strong>Output:</strong> [0,1,2,3,4,-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> is <code>1</code> or <code>-1</code>.</li>\n</ul>\n"},{"id":"2743862","title":"Valid Parentheses","url":"/discuss/topic/2743862/c-stack-clean-10-line-solution","questionTitle":"Valid Parentheses","post":{"creationDate":1666724722},"post_data":{"id":2743862,"title":"C++ stack clean 10 line solution","solutionTags":[],"post":{"id":4405907,"content":"```\nclass Solution {\npublic:\n    bool isValid(string s) \n    {\n        stack<char>stk;\n        unordered_map<char,char>map{{\"(\",\")\"},{\"{\",\"}\"},{\"[\",\"]\"}};\n        for (char ch: s)\n        {\n            if (map.count(ch)) stk.push(ch);\n            else\n            {\n                if (stk.empty() || map[stk.top()]!=ch)\n                    return false;\n                stk.pop();\n            }\n        }\n        return stk.empty();\n    }\n};\n```","creationDate":1666724722}},"acRate":40.33693164566558,"difficulty":"Easy","freqBar":null,"frontendQuestionId":"20","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"valid-parentheses","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n\n<p>An input string is valid if:</p>\n\n<ol>\n\t<li>Open brackets must be closed by the same type of brackets.</li>\n\t<li>Open brackets must be closed in the correct order.</li>\n\t<li>Every close bracket has a corresponding open bracket of the same type.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()[]{}&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(]&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code>.</li>\n</ul>\n"},{"id":"2743817","title":"Reverse Nodes in k-Group","url":"/discuss/topic/2743817/well-explained-solution-in-easy-way","questionTitle":"Reverse Nodes in k-Group","post":{"creationDate":1666723573},"post_data":{"id":2743817,"title":"Well explained solution in easy way","solutionTags":[{"name":"C++"}],"post":{"id":4405847,"content":"Here is the code to reverse linked list:\n```\nListNode* reverse(ListNode* head) \n{\n\tListNode *curr=head, *prev=NULL, *upcoming;\n\twhile (curr)\n\t{\n\t\tupcoming = curr->next;\n\t\tcurr->next = prev;\n\t\tprev = curr;\n\t\tcurr = upcoming;\n\t}\n\treturn prev;\n}\n```\nCode is pretty much self-explanatory. Here is an example:\n```\nhead=1,2,3,NULL\n```\nAfter 1st iteration:\n```\nhead=1,NULL\nprev=1,NULL\ncurr=2,3,NULL\n```\nAfter 2nd iteration:\n```\nhead=1,NULL\nprev=2,1,NULL\ncurr=3,NULL\n```\nAfter 3rd iteration\n```\nhead=1,NULL\nprev=3,2,1,NULL\ncurr=NULL\n```\nNow it stops.\n\nNow to solve our question and inspired from above logic, we replace constraint in `while(curr)` so that it stops when we have done k iterations. For example\n\n```\nhead=1,2,3,4,5,NULL\nk=2\n```\nWhen while loop stops we will have\n```\nhead=1,NULL\nprev=2,1,NULL\ncurr=3,4,5,NULL\n```\n\nNow we need to check if the remaining part of LL `3,4,5,NULL` requires reversal or not.\nIf it does, then we add the reverse part of the remaining LL to `head` which is still at `1`. If not we add the remaining LL without reversal to `head`. Finally return `prev`.\n\nC++ code:\n\n```\nclass Solution {\npublic:\n    bool countK(ListNode *node, int k)\n    {\n        int i=0;\n        while (node && i<k)\n        {\n            node = node->next;\n            i++;\n        }\n        return (i==k);\n    }\n    ListNode* reverseKGroup(ListNode* head, int k) \n    {\n        ListNode *curr=head, *prev=NULL, *upcoming;\n        int i=0;\n        while (i<k)\n        {\n            upcoming = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = upcoming;\n            i++;\n        }\n        if (curr && countK(curr, k))\n            head->next = reverseKGroup(curr, k);\n        else\n            head->next = curr;\n        return prev;\n    }\n};\n```","creationDate":1666723573}},"acRate":54.36458776629678,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"25","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"reverse-nodes-in-k-group","topicTags":[{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Recursion","id":"VG9waWNUYWdOb2RlOjMx","slug":"recursion"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return <em>the modified list</em>.</p>\n\n<p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.</p>\n\n<p>You may not alter the values in the list&#39;s nodes, only nodes themselves may be changed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 2\n<strong>Output:</strong> [2,1,4,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 3\n<strong>Output:</strong> [3,2,1,4,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you solve the problem in <code>O(1)</code> extra memory space?</p>\n"},{"id":"2743558","title":"Partition Labels","url":"/discuss/topic/2743558/greedy-solution","questionTitle":"Partition Labels","post":{"creationDate":1666719041},"post_data":{"id":2743558,"title":"Greedy Solution","solutionTags":[],"post":{"id":4405486,"content":"Notice that it is sufficient if you get the first partition. Because the rest of the partitions can be obtained by recursively calling the same function for the remaining part of string.\n\nHere is the code to print the first parition (this is not the solution but this code will help you to understand).\n```\nvector<int> partitionLabels(string s) \n{\n\tint n=s.length(), j=n-1;\n\twhile (s[j]!=s[0]) j--;\n\tfor (int i=0; i<=j; i++)\n\t{\n\t\tint jj=n-1;\n\t\twhile (s[jj]!=s[i]) jj--;\n\t\tj = max(j,jj);\n\t}\n\tcout << s.substr(0,j+1) << endl;\n\treturn {};\n}\n```\nFor `s = ababcbacadefegdehijhklij`, it will print `ababcbaca`\nFor `s = defegdehijhklij` it will print `defegde`.\nFor `s = hijhklij` it will print `hijhklij` (same as s).\n\nThe way it works is that for each character in the partition we find the maximum index of its occurence. Then the paritition is equal to the maximum of these max-indexes.\n\nNow we just need to find the remaining partitions uising recursion for the remaining part of string.\n\nC++ code:\n\n```\nclass Solution {\npublic:\n    vector<int> partitionLabels(string s) \n    {\n        vector<int> res;\n        int n=s.length(), j=n-1;\n        while (s[j]!=s[0]) j--;\n        for (int i=0; i<=j; i++)\n        {\n            int jj=n-1;\n            while (s[jj]!=s[i]) jj--;\n            j = max(j,jj);\n        }\n        res.push_back(j+1);\n        if (j<s.length()-1)\n        {\n            for (int len: partitionLabels(s.substr(j+1,n)))\n                res.push_back(len);\n        }\n        return res;\n    }\n};\n```","creationDate":1666719041}},"acRate":79.77909267439057,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"763","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"partition-labels","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Greedy","id":"VG9waWNUYWdOb2RlOjE3","slug":"greedy"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given a string <code>s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</p>\n\n<p>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code>s</code>.</p>\n\n<p>Return <em>a list of integers representing the size of these parts</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ababcbacadefegdehijhklij&quot;\n<strong>Output:</strong> [9,7,8]\n<strong>Explanation:</strong>\nThe partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.\nThis is a partition so that each letter appears in at most one part.\nA partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;eccbbbbdec&quot;\n<strong>Output:</strong> [10]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n"},{"id":"2743339","title":"Palindromic Substrings","url":"/discuss/topic/2743339/c-dp-with-explanation","questionTitle":"Palindromic Substrings","post":{"creationDate":1666715202},"post_data":{"id":2743339,"title":"C++ DP with explanation","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":4405206,"content":"Maintain a boolean 2D matrix table to store palindome-ity. Specifically `dp[i][j]` denotes `s[i,..,j]` is a palindrome or not (i and j included). \nThe tricky part is that you have to traverse from Length = 1 to Length = n. For each length explore all possible starting positions for `i` and j then becomes `i+len-1`\nThe recurrence relation for palindrome-ity is\n```\ndp[i][j] =  (s[i]==s[j] && dp[i+1][j-1])\n```\nBasically it says if the outer two characters are same and the inside string is a palindrome then as a whole is a palindrome.\nHowever, there is no inner string for strings of length 1 and 2. Hence we have to modify:\n```\ndp[i][j] =  (s[i]==s[j] && (len<=2 || dp[i+1][j-1]))\n```\n\nC++ code:\n```\nclass Solution {\npublic:\n    int countSubstrings(string s) \n    {\n        int n = s.length(), ctr = 0;\n        vector<vector<bool>> dp(n, vector(n,false));\n        for (int len=1; len<=n; len++)\n        {\n            for (int i=0; i<=n-len; i++)\n            {\n                int j = i+len-1;\n                if (s[i]==s[j] && (len<=2 || dp[i+1][j-1]))\n                {\n                    dp[i][j] = true;\n                    ctr++;\n                }\n            }\n        }\n        return ctr;\n    }\n};\n```","creationDate":1666715202}},"acRate":66.72098679680832,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"647","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"palindromic-substrings","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a string <code>s</code>, return <em>the number of <strong>palindromic substrings</strong> in it</em>.</p>\n\n<p>A string is a <strong>palindrome</strong> when it reads the same backward as forward.</p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abc&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aaa&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n"},{"id":"2743251","title":"Binary Tree Right Side View","url":"/discuss/topic/2743251/easy-bfs","questionTitle":"Binary Tree Right Side View","post":{"creationDate":1666713849},"post_data":{"id":2743251,"title":"Easy BFS","solutionTags":[{"name":"Breadth-First Search"}],"post":{"id":4405096,"content":"```\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) \n    {\n        if (!root) return {};\n        vector<int>res;\n        queue<TreeNode *>Q;\n        Q.push(root);\n        while (!Q.empty())\n        {\n            int qsize = Q.size();\n            for (int i=0; i<qsize; i++)\n            {\n                root = Q.front();\n                Q.pop();\n                if (root->left) Q.push(root->left);\n                if(root->right) Q.push(root->right);\n            }\n            res.push_back(root->val);\n        }\n        return res;\n    }\n};\n```","creationDate":1666713849}},"acRate":61.51803008295036,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"199","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"binary-tree-right-side-view","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 401px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5,null,4]\n<strong>Output:</strong> [1,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3]\n<strong>Output:</strong> [1,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"},{"id":"2742640","title":"Minimum Path Sum","url":"/discuss/topic/2742640/easy-omn","questionTitle":"Minimum Path Sum","post":{"creationDate":1666702323},"post_data":{"id":2742640,"title":"Easy O(m*n)","solutionTags":[{"name":"C++"}],"post":{"id":4404256,"content":"The top row and leftmost column can simply be computed.\nAfter that for any node, the answer can be either its upward neighbor + node value or its leftward neighbor + node value;\n```\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) \n    {\n        int m=grid.size(), n=grid[0].size();\n        vector<vector<int>> sumgrid(m, vector<int>(n,0));\n        sumgrid[0][0] = grid[0][0];\n        for (int i=1; i<m; i++) \n            sumgrid[i][0] = sumgrid[i-1][0] + grid[i][0];\n        for (int j=1; j<n; j++)\n            sumgrid[0][j] = sumgrid[0][j-1] + grid[0][j];\n        for (int i=1; i<m; i++)\n            for (int j=1; j<n; j++)\n                sumgrid[i][j] = min(sumgrid[i-1][j],sumgrid[i][j-1]) + grid[i][j];\n        return sumgrid[m-1][n-1];\n    }\n};\n```","creationDate":1666702323}},"acRate":61.01363389466147,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"64","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"minimum-path-sum","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p>\n\n<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,2,3],[4,5,6]]\n<strong>Output:</strong> 12\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n"},{"id":"2742578","title":"Unique Binary Search Trees","url":"/discuss/topic/2742578/100-easy-dp","questionTitle":"Unique Binary Search Trees","post":{"creationDate":1666701331},"post_data":{"id":2742578,"title":"[100%] Easy DP","solutionTags":[{"name":"Dynamic Programming"}],"post":{"id":4404179,"content":"Assume that you already know `numTrees(1), numTrees(2), numTrees(3),..., numTrees(n-1)` and want to calculate `numTrees(n)`.\nWe have `n` choices for root. For choice `root` as root let us calculate number of trees. Nodes `1,2,...,root-1` have to be in left subree and nodes `root+1,root+2,...,n` have to be in right subtree. \n\n**Number of trees with root `root` = (Number of trees that can be formed from nodes `1,2,...,root-1`) * (Number of trees that can be formed from nodes `root+1,root+2,...,n`)`**\n\nHence\n```\nnumTrees(n) with root = numTrees(root-1)+numTrees(n-root)`\n```\n\nC++ Code:\n```\nclass Solution {\npublic:\n    int numTrees(int n) \n    {\n        vector<int> dp(n+1,0);\n        dp[0] = 1;\n        for (int i=1; i<=n; i++)\n        {\n            int ctr = 0;\n            for (int root=1; root<=i; root++)\n                ctr += dp[root-1]*dp[i-root];\n            dp[i] = ctr;\n        }\n        return dp[n];\n    }\n};\n```\n```\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Unique Binary Search Trees.\nMemory Usage: 6 MB, less than 71.42% of C++ online submissions for Unique Binary Search Trees.\n```","creationDate":1666701331}},"acRate":59.549244845172886,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"96","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"unique-binary-search-trees","topicTags":[{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Binary Search Tree","id":"VG9waWNUYWdOb2RlOjMw","slug":"binary-search-tree"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer <code>n</code>, return <em>the number of structurally unique <strong>BST&#39;</strong>s (binary search trees) which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 5\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 19</code></li>\n</ul>\n"},{"id":"2742389","title":"Decode String","url":"/discuss/topic/2742389/c-stack-100","questionTitle":"Decode String","post":{"creationDate":1666697807},"post_data":{"id":2742389,"title":"C++ Stack 100%","solutionTags":[{"name":"C++"}],"post":{"id":4403920,"content":"Example: `3[a2[c]]` \nAfter traversal we will have the stack `(\"\",3),(a,2)` and have the string `c` as the current string. \nFrom the stack we pop `num` and then `prevString`.\n```\ncurString = prevString + num*curString\n```\n \nC++ code:\n```\nclass Solution {\npublic:\n    string decodeString(string s) \n    {\n        string curString=\"\", curNum=\"\";\n        stack<string> stk;\n        for (char ch: s)\n        {\n            if (ch==\"[\")\n            {\n                stk.push(curString);\n                stk.push(curNum);\n                curString = \"\";\n                curNum = \"\";\n            }\n            else if (ch==\"]\")\n            {\n                int num = stoi(stk.top());\n                stk.pop();\n                string prevString = stk.top();\n                stk.pop();\n                string temp = prevString;\n                for (int i=0;i<num;i++) \n                    temp += curString;\n                curString = temp;\n            }\n            else if (isdigit(ch))\n                curNum += ch;\n            else\n                curString += ch;\n        }\n        return curString;\n    }\n};\n```","creationDate":1666697807}},"acRate":57.97383861865506,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"394","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"decode-string","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Recursion","id":"VG9waWNUYWdOb2RlOjMx","slug":"recursion"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an encoded string, return its decoded string.</p>\n\n<p>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.</p>\n\n<p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there will not be input like <code>3a</code> or <code>2[4]</code>.</p>\n\n<p>The test cases are generated so that the length of the output will never exceed <code>10<sup>5</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3[a]2[bc]&quot;\n<strong>Output:</strong> &quot;aaabcbc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3[a2[c]]&quot;\n<strong>Output:</strong> &quot;accaccacc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;2[abc]3[cd]ef&quot;\n<strong>Output:</strong> &quot;abcabccdcdcdef&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 30</code></li>\n\t<li><code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.</li>\n\t<li><code>s</code> is guaranteed to be <strong>a valid</strong> input.</li>\n\t<li>All the integers in <code>s</code> are in the range <code>[1, 300]</code>.</li>\n</ul>\n"},{"id":"2742171","title":"Rotting Oranges","url":"/discuss/topic/2742171/easy-bfs","questionTitle":"Rotting Oranges","post":{"creationDate":1666693697},"post_data":{"id":2742171,"title":"Easy BFS","solutionTags":[{"name":"C++"},{"name":"Breadth-First Search"}],"post":{"id":4403622,"content":"BFS is very appropriate here. We just need to check how many times we need to traverse to finish the queue. In one traversal, all adjacent members of the current queue get covered. At the end we also check thre is a fresh orange, if yes we return -1 and if not we return the answer.\n- Add all cells with rotten oranges in Queue.\n- Run BFS in the queue.\n- Count the number of times we need to traverse.\n- After we are done, check for any fresh remaining orange.\n\nC++ Code:\n\n```\nclass Solution {\npublic:\n    bool notdone(vector<vector<int>> &grid)\n    {\n        for (auto row: grid)\n            for (int cell: row)\n                if (cell==1)\n                    return true;\n        return false;\n    }\n\n    int orangesRotting(vector<vector<int>>& grid) \n    {\n        if (!notdone(grid)) return 0;\n        int m=grid.size(), n=grid[0].size(), ctr=0;\n        vector<pair<int,int>> dirs {{-1,0},{1,0},{0,-1},{0,1}};\n        queue<pair<int,int>> Q;\n        for (int i=0; i<m; i++)\n            for (int j=0; j<n; j++)\n                if (grid[i][j]==2)\n                    Q.push({i,j});\n        while (!Q.empty())\n        {\n            int qsize = Q.size();\n            for (int i=0; i<qsize; i++)\n            {\n                auto point = Q.front();\n                Q.pop();\n                for (auto dir: dirs)\n                {\n                    int x = point.first + dir.first;\n                    int y = point.second + dir.second;\n                    if (x<0 || x>=m || y<0 || y>=n || grid[x][y]!=1)\n                        continue;\n                    grid[x][y] = 2;\n                    Q.push({x,y});\n                }\n            }\n            ctr++;\n        }\n        if (notdone(grid)) return -1;\n        return ctr-1;\n    }\n};\n```","creationDate":1666693697}},"acRate":52.82196108375583,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"994","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"rotting-oranges","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given an <code>m x n</code> <code>grid</code> where each cell can have one of three values:</p>\n\n<ul>\n\t<li><code>0</code> representing an empty cell,</li>\n\t<li><code>1</code> representing a fresh orange, or</li>\n\t<li><code>2</code> representing a rotten orange.</li>\n</ul>\n\n<p>Every minute, any fresh orange that is <strong>4-directionally adjacent</strong> to a rotten orange becomes rotten.</p>\n\n<p>Return <em>the minimum number of minutes that must elapse until no cell has a fresh orange</em>. If <em>this is impossible, return</em> <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/16/oranges.png\" style=\"width: 650px; height: 137px;\" />\n<pre>\n<strong>Input:</strong> grid = [[2,1,1],[1,1,0],[0,1,1]]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[2,1,1],[0,1,1],[1,0,1]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,2]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Since there are already no fresh oranges at minute 0, the answer is just 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>grid[i][j]</code> is <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n</ul>\n"},{"id":"2741753","title":"Path Sum III","url":"/discuss/topic/2741753/easy-dfs","questionTitle":"Path Sum III","post":{"creationDate":1666686010},"post_data":{"id":2741753,"title":"Easy DFS","solutionTags":[{"name":"Depth-First Search"}],"post":{"id":4403084,"content":"The idea is that any valid path will have a starting node and go down thereafter. So, we start from root and go down while checking if there is valid path starting from that node.\nSo, for the tree in the question example 1:\n```\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n```\nWe will check paths \n```\n[10],[10,5],[10,5,3],[10,5,3,3],[10,5,3,-2],[10,5,2],[10,5,2,1],[10,-3],[10,-3,11]\n```\nThen we will check paths\n```\n[5],[5,3],[5,3,3],[5,3,-2],[5,2],[5,2,1]\n```\nand so on.\n\nC++ code:\n```\nclass Solution {\npublic:\n    int pathSum(TreeNode* root, int targetSum) \n    {\n        if (!root) return 0;\n        return sumUp(root, 0, targetSum) + pathSum(root->left, targetSum) + pathSum(root->right, targetSum);\n    }\n    int sumUp(TreeNode *root, long long curr, int target)\n    {\n        if (!root) return 0;\n        curr += root->val;\n        return (curr==target) + sumUp(root->left, curr, target) + sumUp(root->right,curr,target);\n    }\n};\n```","creationDate":1666686010}},"acRate":48.161809358638386,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"437","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"path-sum-iii","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>the number of paths where the sum of the values&nbsp;along the path equals</em>&nbsp;<code>targetSum</code>.</p>\n\n<p>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg\" style=\"width: 450px; height: 386px;\" />\n<pre>\n<strong>Input:</strong> root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The paths that sum to 8 are shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 1000]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n"},{"id":"2741593","title":"Find Minimum in Rotated Sorted Array","url":"/discuss/topic/2741593/iterative-binary-search","questionTitle":"Find Minimum in Rotated Sorted Array","post":{"creationDate":1666682871},"post_data":{"id":2741593,"title":"Iterative binary search","solutionTags":[{"name":"C++"}],"post":{"id":4402874,"content":"Notice that to verify if an array element is minimum or not, it is sufficient to verify that it is smaller than both its neighbors (with rotation).ie\n```\nprev = (mid==0) ? n-1 : mid-1\nnext = (mid==n-1) ? 0 : mid+1\nA[mid]<=A[prev] and A[mid]<=A[next]\n```\nWe want to find an index `mid` in the range `[0,n)` that satisfies this condition. We use binary search for this.\n\n```\nint findMin(vector<int>& nums) \n{\n\tint n=nums.size(), lo=0, hi=n-1, mid;\n\twhile (lo<=hi)\n\t{\n\t\tmid = lo + (hi-lo)/2;\n\t\tint prev = (mid-1+n)%n, next = (mid+1)%n;\n\t\tif (nums[mid]<=nums[prev] && nums[mid]<=nums[next])\n\t\t\tbreak;\n\t\telse if (nums[mid] <= nums[hi])\n\t\t\thi = mid-1;\n\t\telse\n\t\t\tlo = mid+1; // nums[0...mid] subarray is sorted\n\t}\n\treturn nums[mid];\n}\n```","creationDate":1666682871}},"acRate":48.76786494215313,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"153","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"find-minimum-in-rotated-sorted-array","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(log n) time.</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,5,1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,6,7,0,1,2]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [11,13,15,17]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n"},{"id":"2730302","title":"Factorial Trailing Zeroes","url":"/discuss/topic/2730302/easy-one-liner","questionTitle":"Factorial Trailing Zeroes","post":{"creationDate":1666380488},"post_data":{"id":2730302,"title":"[Easy] One liner","solutionTags":[{"name":"C++"}],"post":{"id":4387631,"content":"You should notice that the number of zeros is bounded by the number of factors of 5 and its powers because 2 will have always more. So we just count the number of factors of each power of 5 from 1 to n using a simple divide operation.\n```\nint trailingZeroes(int n) \n{\n    return n/3125 + n/625 + n/125 + n/25 + n/5;\n}\n```","creationDate":1666380488}},"acRate":42.088686409217786,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"172","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"factorial-trailing-zeroes","topicTags":[{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer <code>n</code>, return <em>the number of trailing zeroes in </em><code>n!</code>.</p>\n\n<p>Note that <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> 3! = 6, no trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 5! = 120, one trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you write a solution that works in logarithmic time complexity?</p>\n"},{"id":"2730248","title":"Wiggle Sort II","url":"/discuss/topic/2730248/trial-and-error","questionTitle":"Wiggle Sort II","post":{"creationDate":1666378972},"post_data":{"id":2730248,"title":"Trial and Error","solutionTags":[{"name":"C++"}],"post":{"id":4387554,"content":"My first attempt was to do alternate from front (first even 0,2,4,.. indices then odd 1,3,5,... indices) ie\n`0,1,2,3,4,5` becomes `0,3,1,4,2,5` and `0,1,2,3,4` becomes `0,3,1,4,2`. \n```\nvoid wiggleSort(vector<int>& nums) \n{\n    int n = nums.size();\n    sort(nums.begin(),nums.end());\n    vector<int> arr(n, 0);\n    for (int i=0; i<n; i+=2)\n        arr[n-1-i] = nums[(n+i)/2]; \n    for (int i=1; i<n; i+=2)\n        arr[n-1-i] = nums[i/2];\n    nums = arr;\n}\n```\nHowever this fails for `4,5,5,6` because it will give us `4,5,5,6`. \nNotice however that alternate from back works ie `5,6,4,5` (again even indices R to L then odd indices R to L). A few more tests should tell you that this is a valid algorithm. Hence gives us an AC. However we have to take special care of whether array size is even or odd. \n\n```\nvoid wiggleSort(vector<int>& nums) \n{\n    int n = nums.size();\n    sort(nums.begin(),nums.end());\n    vector<int> arr(n, 0);\n    for (int i=0; i<n; i+=2)\n        arr[i] = nums[(n-i)/2 - (n%2==0 ? 1 : 0)];\n    for (int i=1; i<n; i+=2)\n        arr[i] = nums[n-1-i/2];\n    nums = arr;\n}\n```","creationDate":1666378972}},"acRate":33.20384575702244,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"324","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"wiggle-sort-ii","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Divide and Conquer","id":"VG9waWNUYWdOb2RlOjEy","slug":"divide-and-conquer"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"},{"name":"Quickselect","id":"VG9waWNUYWdOb2RlOjYxMDY5","slug":"quickselect"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>Given an integer array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>\n\n<p>You may assume the input array always has a valid answer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,1,1,6,4]\n<strong>Output:</strong> [1,6,1,5,1,4]\n<strong>Explanation:</strong> [1,4,1,5,1,6] is also accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,2,2,3,1]\n<strong>Output:</strong> [2,3,1,3,1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>It is guaranteed that there will be an answer for the given input <code>nums</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow Up:</strong> Can you do it in <code>O(n)</code> time and/or <strong>in-place</strong> with <code>O(1)</code> extra space?"},{"id":"2729881","title":"Fraction to Recurring Decimal","url":"/discuss/topic/2729881/faster-than-100-easy-concise-c-step-by-step","questionTitle":"Fraction to Recurring Decimal","post":{"creationDate":1666371309},"post_data":{"id":2729881,"title":"[Faster than 100%] Easy + Concise C++ Step by step","solutionTags":[],"post":{"id":4387033,"content":"Here is the code without taking care of the recurring decimal (Will give you WA for case `nr=1,dr=3` but still it is useful to understand):\n```\nstring fractionToDecimal(int nr, int dr) \n{\n\tif (nr==0) return \"0\";\n\tstring res = \"\";\n\tif ((nr<0)^(dr<0)) res += \"-\";\n\tnr = abs(nr), dr=abs(dr);\n\tres += to_string(nr/dr);\n\tint rem = nr%dr;\n\tif (rem==0) return res;\n\tres += \".\";\n\twhile (rem>0)\n\t{\n\t\trem *= 10;\n\t\tres += to_string(rem/dr);\n\t\trem %= dr;\n\t}\n\treturn res;\n}\n```\n\nNow we add the recurring decimal part. We will use a hash map to store the position of each decimal digit. If we have seen it earlier than we are due to repeat, hence we break and return.\n\nThere are some gotchas you need to take care of.\n- `abs(INT_MIN)` is `INT_MIN` as defined in `cstdlib.h`.\n- Hence we use `long long int` for our nr and dr.\n- Also use `long long int` for the remainder.\n- You got to be careful about the insertion position of the starting open paranthesis `(`.\n\nFinal code:\n```\nstring fractionToDecimal(long long nr, long long dr) \n{\n    if (nr==0) return \"0\";\n    string res = \"\";\n    if ((nr<0)^(dr<0)) res += \"-\";\n    nr = abs(nr), dr=abs(dr);\n    res += to_string(nr/dr);\n    long long rem = nr%dr;\n    if (rem==0) return res;\n    res += \".\";\n    unordered_map<int,int> decimal;\n    while (rem>0 && decimal.count(rem)==0)\n    {\n        decimal[rem] = res.length();\n        rem *= 10;\n        res += to_string(rem/dr);\n        rem %= dr;\n    }\n    if (rem>0)\n    {\n        res.insert(decimal[rem], \"(\");\n        res += \")\";\n    }\n    return res;\n}\n```\n\n**Result:**\n```\nSuccess\nDetails\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Fraction to Recurring Decimal.\nMemory Usage: 6.3 MB, less than 74.68% of C++ online submissions for Fraction to Recurring Decimal.\n```","creationDate":1666371309}},"acRate":24.25594066140199,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"166","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"fraction-to-recurring-decimal","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p>\n\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\n\n<p>If multiple answers are possible, return <strong>any of them</strong>.</p>\n\n<p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10<sup>4</sup></code> for all the given inputs.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 1, denominator = 2\n<strong>Output:</strong> &quot;0.5&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 2, denominator = 1\n<strong>Output:</strong> &quot;2&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 4, denominator = 333\n<strong>Output:</strong> &quot;0.(012)&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;=&nbsp;numerator, denominator &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>denominator != 0</code></li>\n</ul>\n"},{"id":"2729721","title":"Word Break","url":"/discuss/topic/2729721/easy-concise-dp","questionTitle":"Word Break","post":{"creationDate":1666367634},"post_data":{"id":2729721,"title":"Easy Concise DP","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":4386823,"content":"The overall idea is that we maintain a `dp` array of dtype `bool` which denotes whether it is possible for string ending at i. The recursive relation is:\n\n```\ndp[i] = True if any (dp[j] = True and s[j:i] is in wordDict for j in 0..i)\nElse dp[i] = False\n```\nC++ code:\n```\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string>words;\n        for (string w: wordDict) words.insert(w);\n        int n=s.length();\n        \n        vector<bool>valid(n+1,false);\n        valid[0] = true;\n        \n        for (int j=1; j<=n; j++)\n        {\n            bool curr = false;\n            for (int i=0; i<j; i++)\n            {\n                string sub(s.begin()+i, s.begin()+j);\n                if (valid[i] && words.count(sub)){curr=true; break;}\n            }\n            valid[j] = curr;\n        }\n        return valid[n];\n    }\n};\n```","creationDate":1666367634}},"acRate":45.54160453672236,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"139","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"word-break","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Trie","id":"VG9waWNUYWdOb2RlOjI3","slug":"trie"},{"name":"Memoization","id":"VG9waWNUYWdOb2RlOjMz","slug":"memoization"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.\nNote that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n</ul>\n"},{"id":"2728624","title":"Insert Delete GetRandom O(1)","url":"/discuss/topic/2728624/simple-hashset","questionTitle":"Insert Delete GetRandom O(1)","post":{"creationDate":1666344180},"post_data":{"id":2728624,"title":"Simple Hashset","solutionTags":[{"name":"C++"}],"post":{"id":4385375,"content":"```\nclass RandomizedSet {\n    unordered_set<int> numset;\npublic:\n    RandomizedSet() {\n    }\n    \n    bool insert(int val) {\n        if (numset.count(val)) return false;\n        numset.insert(val);\n        return true;\n    }\n    \n    bool remove(int val) {\n        if (!numset.count(val)) return false;\n        numset.erase(val);\n        return true;\n    }\n    \n    int getRandom() {\n        int idx = rand() % numset.size();\n        auto it = numset.begin();\n        for (int i=0; i<idx; ++i) ++it;\n        return *it;\n    }\n};\n```","creationDate":1666344180}},"acRate":52.80563840795847,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"380","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"insert-delete-getrandom-o1","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"},{"name":"Randomized","id":"VG9waWNUYWdOb2RlOjYxMDc1","slug":"randomized"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Implement the <code>RandomizedSet</code> class:</p>\n\n<ul>\n\t<li><code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.</li>\n\t<li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.</li>\n\t<li><code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.</li>\n\t<li><code>int getRandom()</code> Returns a random element from the current set of elements (it&#39;s guaranteed that at least one element exists when this method is called). Each element must have the <b>same probability</b> of being returned.</li>\n</ul>\n\n<p>You must implement the functions of the class such that each function works in&nbsp;<strong>average</strong>&nbsp;<code>O(1)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]\n[[], [1], [2], [2], [], [1], [2], []]\n<strong>Output</strong>\n[null, true, false, true, 2, true, false, 2]\n\n<strong>Explanation</strong>\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>At most <code>2 *&nbsp;</code><code>10<sup>5</sup></code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.</li>\n\t<li>There will be <strong>at least one</strong> element in the data structure when <code>getRandom</code> is called.</li>\n</ul>\n"},{"id":"2728437","title":"Contains Duplicate II","url":"/discuss/topic/2728437/hashset","questionTitle":"Contains Duplicate II","post":{"creationDate":1666339672},"post_data":{"id":2728437,"title":"Hashset","solutionTags":[{"name":"C++"}],"post":{"id":4385136,"content":"The idea is to find if we have seen the current value already in the range. Since the search operation in hashset is constant time, hence our algorithm is efficient.\n```\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) \n    {\n        int n=nums.size();\n        unordered_set<int> numset;\n        for (int i=0; i<k && i<n; ++i)\n        {\n            if (numset.count(nums[i])) return true;\n            numset.insert(nums[i]);\n        }\n        for (int i=k; i<n; ++i)\n        {\n            if (numset.count(nums[i])) return true;\n            numset.insert(nums[i]);\n            numset.erase(nums[i-k]);\n        }\n        return false;\n    }\n};\n```\n```\nTC: O(n)\nSC: O(k)\n```","creationDate":1666339672}},"acRate":42.47945389652406,"difficulty":"Easy","freqBar":null,"frontendQuestionId":"219","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"contains-duplicate-ii","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Sliding Window","id":"VG9waWNUYWdOb2RlOjU1ODIx","slug":"sliding-window"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> <em>if there are two <strong>distinct indices</strong> </em><code>i</code><em> and </em><code>j</code><em> in the array such that </em><code>nums[i] == nums[j]</code><em> and </em><code>abs(i - j) &lt;= k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1], k = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,1], k = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1,2,3], k = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n"},{"id":"2720542","title":"Top K Frequent Words","url":"/discuss/topic/2720542/cpython31-lines-two-methods-sorting-max-heap","questionTitle":"Top K Frequent Words","post":{"creationDate":1666154539},"post_data":{"id":2720542,"title":"[C++,Python(3/1 lines)] Two methods: Sorting / Max heap","solutionTags":[{"name":"C++"},{"name":"Python"}],"post":{"id":4374687,"content":"# Sorting:\nWe implement a custom comparator for the condition \"sort by frequency (descending) and for same frequency sort by string (ascending)\"\n```\nbool comp(pair<string,int>a, pair<string,int>b)\n{\n    if (a.second==b.second)\n        return a.first < b.first;\n    return a.second > b.second;\n}\n\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) \n    {\n        unordered_map<string,int> H;\n        for (string w: words) H[w]++;\n        vector<pair<string,int>> vec;\n        for (auto p: H) vec.push_back({p.first,p.second});\n        sort(vec.begin(),vec.end(),comp);\n        vector<string>res;\n        for (int i=0; i<k; ++i) res.push_back(vec[i].first);\n        return res;\n    }\n};\n```\nSame thing in Python3. Python has inbuilt `collections.Counter` to get frequency map  from array. Also Python\"s sorting API accepts the use of 2 keys if the first key has equal value, hence we need not write a separate comparator function.\n```\nclass Solution:\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        counter = Counter(words)\n        sorted_words = sorted(counter.keys(), key=lambda i: (-counter[i], i))\n        return sorted_words[:k]\n```\n\nIf you \"really\" like compact albeit slightly difficult to read code, here is a one-liner for you (though I wont recommend it in real life):\n```\ndef topKFrequent(self, words: List[str], k: int) -> List[str]:\n\treturn [i[0] for i in sorted(Counter(words).items(), key=lambda j: (-j[1],j[0]))][:k]\n```\n\n```\nTC: O( n log(n))\nSC: O(n)\n```\n# Priority Queue\nInstead of sorting we can maintain a priority queue of length K. If length exceeds K, we pop out the last item as per our condition.\n```\nbool comp(pair<string,int>a, pair<string,int>b)\n{\n    if (a.second==b.second)\n        return a.first < b.first;\n    return a.second > b.second;\n}\n\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) \n    {\n        unordered_map<string,int> H;\n        for (string w: words) H[w]++;\n        priority_queue<pair<string,int>, vector<pair<string,int>>, decltype(comp)*> pq(comp);\n        for (auto p: H)\n        {\n            pq.push({p.first,p.second});\n            if (pq.size()>k) pq.pop();\n        }\n        vector<string>res;\n        while (!pq.empty())\n        {\n            res.insert(res.begin(), pq.top().first);\n            pq.pop();\n        }\n        return res;\n    }\n};\n```\n```\nTC: O(n log(K))\nSC: O(n)\n```\nIf you have any questions dont hesitate to ask. Please upvote if you find this useful.","creationDate":1666154539}},"acRate":57.08482396964837,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"692","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"top-k-frequent-words","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Trie","id":"VG9waWNUYWdOb2RlOjI3","slug":"trie"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"},{"name":"Heap (Priority Queue)","id":"VG9waWNUYWdOb2RlOjYxMDUw","slug":"heap-priority-queue"},{"name":"Bucket Sort","id":"VG9waWNUYWdOb2RlOjYxMDYw","slug":"bucket-sort"},{"name":"Counting","id":"VG9waWNUYWdOb2RlOjYxMDYy","slug":"counting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an array of strings <code>words</code> and an integer <code>k</code>, return <em>the </em><code>k</code><em> most frequent strings</em>.</p>\n\n<p>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;i&quot;,&quot;love&quot;,&quot;coding&quot;], k = 2\n<strong>Output:</strong> [&quot;i&quot;,&quot;love&quot;]\n<strong>Explanation:</strong> &quot;i&quot; and &quot;love&quot; are the two most frequent words.\nNote that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;the&quot;,&quot;day&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;the&quot;,&quot;the&quot;,&quot;the&quot;,&quot;sunny&quot;,&quot;is&quot;,&quot;is&quot;], k = 4\n<strong>Output:</strong> [&quot;the&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;day&quot;]\n<strong>Explanation:</strong> &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li><code>k</code> is in the range <code>[1, The number of <strong>unique</strong> words[i]]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Could you solve it in <code>O(n log(k))</code> time and <code>O(n)</code> extra space?</p>\n"},{"id":"2716972","title":"Search a 2D Matrix II","url":"/discuss/topic/2716972/top-right-to-bottom-left","questionTitle":"Search a 2D Matrix II","post":{"creationDate":1666072878},"post_data":{"id":2716972,"title":"Top right to bottom left","solutionTags":[{"name":"C++"}],"post":{"id":4369992,"content":"The idea is to start from top right cell. If it is larger than target than we can ignore last column, if smaller we can ignore first row. This way we keep moving.\n```\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \n    {\n        int m = matrix.size(), n = matrix[0].size();\n        int i=0, j=n-1;\n        while (i<m && j>=0)\n        {\n            if (matrix[i][j] == target) return true;\n            else if (matrix[i][j] > target) j--;\n            else  i++;\n        }\n        return false;\n    }\n};\n```","creationDate":1666072878}},"acRate":50.91428708374773,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"240","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"search-a-2d-matrix-ii","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"},{"name":"Divide and Conquer","id":"VG9waWNUYWdOb2RlOjEy","slug":"divide-and-conquer"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>\n\n<ul>\n\t<li>Integers in each row are sorted in ascending from left to right.</li>\n\t<li>Integers in each column are sorted in ascending from top to bottom.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the integers in each row are <strong>sorted</strong> in ascending order.</li>\n\t<li>All the integers in each column are <strong>sorted</strong> in ascending order.</li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n"},{"id":"2716923","title":"Min Stack","url":"/discuss/topic/2716923/beauty-of-oop","questionTitle":"Min Stack","post":{"creationDate":1666072080},"post_data":{"id":2716923,"title":"Beauty of OOP","solutionTags":[{"name":"C++"}],"post":{"id":4369935,"content":"We use pre-built stack class but with our own class object instead of int which will have information on minimum value at any point on stack.\n\n```\nclass Item\n{\n    public:\n    int val;\n    int minVal;\n    Item(int v, int mv): val(v), minVal(mv){}\n};\n\nclass MinStack {\n    stack<Item> stk;\npublic:\n    MinStack() \n    {}\n    \n    void push(int val) \n    {\n        int m = (stk.empty()) ? val : min(stk.top().minVal, val);\n        stk.push(Item(val, m));\n    }\n    \n    void pop() \n    {\n        stk.pop();\n    }\n    \n    int top() \n    {\n        return stk.top().val;\n    }\n    \n    int getMin() \n    {\n        return stk.top().minVal;\n    }\n};\n```","creationDate":1666072080}},"acRate":52.19947319970356,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"155","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"min-stack","topicTags":[{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>\n\n<p>Implement the <code>MinStack</code> class:</p>\n\n<ul>\n\t<li><code>MinStack()</code> initializes the stack object.</li>\n\t<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>\n\t<li><code>void pop()</code> removes the element on the top of the stack.</li>\n\t<li><code>int top()</code> gets the top element of the stack.</li>\n\t<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>\n</ul>\n\n<p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>Output</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>Explanation</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li>\n</ul>\n"},{"id":"2714941","title":"Surrounded Regions","url":"/discuss/topic/2714941/island-method-dfs","questionTitle":"Surrounded Regions","post":{"creationDate":1666023272},"post_data":{"id":2714941,"title":"Island method [DFS]","solutionTags":[{"name":"Depth-First Search"}],"post":{"id":4367286,"content":"This is inspired from my previous posts on simlar questions: [Number of Islands](https://leetcode.com/problems/number-of-islands/discuss/2714931/Easy-DFS) and [Count sub islands](https://leetcode.com/problems/count-sub-islands/discuss/2632544/DFS-solution).\n\nThe idea is to collect all the cells of an island in an array and check if the island is indeed surrounded or not. If it is then we change to X\"s and if not, we revert to original. The check for whether an island is surrounded or not is pretty simple: If any of its cells is a boundary cell then it is not surrounded and if not then it is surrounded.\n\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<char>> &board, int m, int n, int i, int j, vector<pair<int,int>>&isle)\n    {\n        if (i<0||i>=m||j<0||j>=n||board[i][j]!=\"O\") return;\n        board[i][j] = \"*\";\n        isle.push_back({i,j});\n        dfs(board,m,n,i-1,j,isle);\n        dfs(board,m,n,i+1,j,isle);\n        dfs(board,m,n,i,j-1,isle);\n        dfs(board,m,n,i,j+1,isle);\n    }\n    void surround(vector<vector<char>> &board, int m, int n,vector<pair<int,int>>&isle)\n    {\n        bool toSurround = true;\n        for (auto p: isle)\n            if (p.first==0 || p.first==(m-1) || p.second==0 || p.second==n-1)\n            {\n                toSurround = false;\n                break;\n            }\n        if (toSurround)\n        {\n            for (auto p: isle)\n                board[p.first][p.second] = \"X\";            \n        }\n        else\n        {\n            for (auto p: isle)\n                board[p.first][p.second] = \"O\";            \n        }\n        \n    }\n    void solve(vector<vector<char>>& board) \n    {\n        int m = board.size(), n=board[0].size();\n        for (int i=0; i<m; ++i)\n        {\n            for (int j=0; j<n; ++j)\n            {\n                if (board[i][j]==\"O\")\n                {\n                    vector<pair<int,int>> isle;\n                    dfs(board,m,n,i,j,isle);\n                    surround(board,m,n,isle);\n                }\n            }\n        }\n    }\n};\n```\n\nThe other method is to mark all islands having at leat one cell at boundary with `*`. Then if you find land, depending on whether it is marked or not convert it to \"X\" or back to \"O\".\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<char>>& board, int m, int n, int i, int j)\n    {\n        if (i<0||i>=m||j<0||j>=n||board[i][j]!=\"O\") return;\n        board[i][j] = \"*\";\n        dfs(board,m,n,i-1,j);\n        dfs(board,m,n,i+1,j);\n        dfs(board,m,n,i,j-1);\n        dfs(board,m,n,i,j+1);\n    }\n    void solve(vector<vector<char>>& board) \n    {\n        int m = board.size(), n=board[0].size();\n        for (int i=0; i<m; ++i)\n        {\n            dfs(board, m, n, i, 0);\n            dfs(board, m, n, i, n-1);\n        }\n        for (int j=0; j<n; ++j)\n        {\n            dfs(board, m, n, 0, j);\n            dfs(board, m, n, m-1, j);\n        }\n        for (int i=0; i<m; ++i)\n        {\n            for (int j=0; j<n; ++j)\n            {\n                if (board[i][j]==\"*\")\n                    board[i][j] = \"O\";\n                else if (board[i][j] = \"O\")\n                    board[i][j] = \"X\";\n            }\n        }\n        return;\n    }\n};\n```\nCredits for 2nd method goes to [this post](https://leetcode.com/problems/surrounded-regions/discuss/691675/C%2B%2B-Beginner-Friendly-or-Boundary-DFS-or-inPlace)\n\n# Note on TC and SC\nBoth the solutions have `O(m*n)` TC and first solution has `O(m*n)` SC whereas second solution has `O(1)` SC.\n\nIn general for any grid type problem it is impossible to find better than `O(m*n)` TC but the SC can be improved as we saw here.","creationDate":1666023272}},"acRate":36.54756549493391,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"130","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"surrounded-regions","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Union Find","id":"VG9waWNUYWdOb2RlOjIz","slug":"union-find"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an <code>m x n</code> matrix <code>board</code> containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <em>capture all regions that are 4-directionally&nbsp;surrounded by</em> <code>&#39;X&#39;</code>.</p>\n\n<p>A region is <strong>captured</strong> by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg\" style=\"width: 550px; height: 237px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]\n<strong>Output:</strong> [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]\n<strong>Explanation:</strong> Notice that an &#39;O&#39; should not be flipped if:\n- It is on the border, or\n- It is adjacent to an &#39;O&#39; that should not be flipped.\nThe bottom &#39;O&#39; is on the border, so it is not flipped.\nThe other three &#39;O&#39; form a surrounded region, so they are flipped.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = [[&quot;X&quot;]]\n<strong>Output:</strong> [[&quot;X&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li>\n</ul>\n"},{"id":"2714931","title":"Number of Islands","url":"/discuss/topic/2714931/easy-dfs","questionTitle":"Number of Islands","post":{"creationDate":1666023051},"post_data":{"id":2714931,"title":"Easy DFS","solutionTags":[{"name":"Depth-First Search"}],"post":{"id":4367269,"content":"The idea is to go over all cells and once you see a 1 (land) start exploring its neighborhood and change grid cell value to 2 to avoid double visits. This way you dont need to maintain a `visited` array.\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<char>>&grid, int i, int j, int m, int n)\n    {\n        if(i<0 || i>=m || j<0 || j>=n || grid[i][j]!=\"1\") return;\n        grid[i][j] = \"2\";\n        dfs(grid, i-1, j, m, n);\n        dfs(grid, i+1, j, m, n);\n        dfs(grid, i, j-1, m, n);\n        dfs(grid, i, j+1, m, n);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i=0; i<m; i++)\n        {\n            for (int j=0; j<n; j++)\n            {\n                if (grid[i][j]==\"1\")\n                {\n                    dfs(grid, i, j, m, n);\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n```","creationDate":1666023051}},"acRate":56.83610779809648,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"200","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"number-of-islands","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Union Find","id":"VG9waWNUYWdOb2RlOjIz","slug":"union-find"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>\n\n<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]\n]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]\n]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n"},{"id":"2706223","title":"Count Primes","url":"/discuss/topic/2706223/sieve-of-eratosthenes-with-exaplanation","questionTitle":"Count Primes","post":{"creationDate":1665846873},"post_data":{"id":2706223,"title":"Sieve of Eratosthenes with Exaplanation","solutionTags":[{"name":"C++"}],"post":{"id":4355415,"content":"Sieve of Eratosthenes is the well known algorithm for such count/print primes type problems and the algorithm was invented by him ~2200 years ago!\n\n\nThe algorithm is based on following easily verifiable observation:\n**If a number n is not prime then n will have one or more prime factors in the range `[2,sqrt(n)]`**\n```\nclass Solution {\npublic:\n    int countPrimes(int n)\n    {\n        if (n<2) return 0;\n        vector<bool> prime(n+1,true);\n        for (int p=2; p*p<=n; ++p)\n        {\n            if (!prime[p]) continue;\n            for (int i=p*p; i<=n; i+=p)\n                prime[i] = false;\n        }\n        \n        int ctr = 0;\n        for (int p=2; p<n; ++p) ctr += prime[p];\n        return ctr;\n    }\n};\n```\nIf you are wondering about the inner loop why it starts from `p*p` ie we are marking `[p*p, p*p+p, p*p+2p, p*p+3p,..,n]` and so on and why we are not starting from p ie `[p, 2p, 3p,..,n]`, it is because `[p,2p,..,p*p)` will already be marked by some other smaller prime.","creationDate":1665846873}},"acRate":33.077455077513996,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"204","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"count-primes","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"Enumeration","id":"VG9waWNUYWdOb2RlOjYxMDY2","slug":"enumeration"},{"name":"Number Theory","id":"VG9waWNUYWdOb2RlOjYxMDY3","slug":"number-theory"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer <code>n</code>, return <em>the number of prime numbers that are strictly less than</em> <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 5 * 10<sup>6</sup></code></li>\n</ul>\n"},{"id":"2700746","title":"Populating Next Right Pointers in Each Node","url":"/discuss/topic/2700746/bfsqueue-o1-space-on-time","questionTitle":"Populating Next Right Pointers in Each Node","post":{"creationDate":1665719921},"post_data":{"id":2700746,"title":"BFS+Queue O(1) space, O(n) time","solutionTags":[{"name":"C++"}],"post":{"id":4348319,"content":"We will use a queue. The children of the level nodes are stored in queue. Then one by one we go over the queue. \n# Puzzle\nNote that we are iterating in the queue in reverse in the line         `for (int i=Q.size()-1; i>=0; --i)`. Can you tell why?\n\n# Code: \n ```\nNode* connect(Node* root) \n{\n    if (!root) return NULL;\n    queue<Node *> Q;\n    Q.push(root);\n    while (!Q.empty())\n    {\n        Node *curr=NULL, *prev=NULL;\n        for (int i=Q.size()-1; i>=0; --i)\n        {\n            curr = Q.front();\n            if (prev) prev->next = curr;\n            Q.pop();\n            if (curr->left) Q.push(curr->left);\n            if (curr->right) Q.push(curr->right);\n            prev = curr;\n        }\n        curr->next = NULL;\n    }\n    return root;\n}\n```\n\nAnswer to puzzle is that because the queue size is increasing on the go, so we can not iterate forwards or else the loop will not end when we want it to end, so we must iterate in reverse.","creationDate":1665719921}},"acRate":60.16558992080016,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"116","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"populating-next-right-pointers-in-each-node","topicTags":[{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n</pre>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/14/116_sample.png\" style=\"width: 500px; height: 171px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6,7]\n<strong>Output:</strong> [1,#,2,3,#,4,5,6,7,#]\n<strong>Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2<sup>12</sup> - 1]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong></p>\n\n<ul>\n\t<li>You may only use constant extra space.</li>\n\t<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n"},{"id":"2700676","title":"Delete the Middle Node of a Linked List","url":"/discuss/topic/2700676/one-pass-tortoise-and-hare","questionTitle":"Delete the Middle Node of a Linked List","post":{"creationDate":1665718732},"post_data":{"id":2700676,"title":"One pass tortoise and hare","solutionTags":[{"name":"C++"}],"post":{"id":4348226,"content":"```\nListNode* deleteMiddle(ListNode* head) \n{\n    if (!head->next) return NULL;\n    if (!head->next->next) return new ListNode(head->val);\n\n    ListNode *fast = head, *slow = head;\n    while (fast && fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    *slow = *(slow->next);\n    return head;\n}\n```","creationDate":1665718732}},"acRate":59.70925868162077,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"2095","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"delete-the-middle-node-of-a-linked-list","topicTags":[{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given the <code>head</code> of a linked list. <strong>Delete</strong> the <strong>middle node</strong>, and return <em>the</em> <code>head</code> <em>of the modified linked list</em>.</p>\n\n<p>The <strong>middle node</strong> of a linked list of size <code>n</code> is the <code>&lfloor;n / 2&rfloor;<sup>th</sup></code> node from the <b>start</b> using <strong>0-based indexing</strong>, where <code>&lfloor;x&rfloor;</code> denotes the largest integer less than or equal to <code>x</code>.</p>\n\n<ul>\n\t<li>For <code>n</code> = <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code>, the middle nodes are <code>0</code>, <code>1</code>, <code>1</code>, <code>2</code>, and <code>2</code>, respectively.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png\" style=\"width: 500px; height: 77px;\" />\n<pre>\n<strong>Input:</strong> head = [1,3,4,7,1,2,6]\n<strong>Output:</strong> [1,3,4,1,2,6]\n<strong>Explanation:</strong>\nThe above figure represents the given linked list. The indices of the nodes are written below.\nSince n = 7, node 3 with value 7 is the middle node, which is marked in red.\nWe return the new list after removing this node. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png\" style=\"width: 250px; height: 43px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4]\n<strong>Output:</strong> [1,2,4]\n<strong>Explanation:</strong>\nThe above figure represents the given linked list.\nFor n = 4, node 2 with value 3 is the middle node, which is marked in red.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png\" style=\"width: 150px; height: 58px;\" />\n<pre>\n<strong>Input:</strong> head = [2,1]\n<strong>Output:</strong> [2]\n<strong>Explanation:</strong>\nThe above figure represents the given linked list.\nFor n = 2, node 1 with value 1 is the middle node, which is marked in red.\nNode 0 with value 2 is the only node remaining after removing node 1.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n"},{"id":"2698757","title":"Flatten Nested List Iterator","url":"/discuss/topic/2698757/simple-recursion","questionTitle":"Flatten Nested List Iterator","post":{"creationDate":1665670248},"post_data":{"id":2698757,"title":"Simple Recursion","solutionTags":[{"name":"C++"},{"name":"Recursion"}],"post":{"id":4345661,"content":"In the constructor itself, I am linearizing the whole thing and storing the data in an array. We recurse inside the nested integer till we get to an integer.\n\n```\nclass NestedIterator {\n    vector<int> arr;\n    int index = 0;\npublic:\n    void linearize(NestedInteger nestInt, vector<int> &res)\n    {\n        if (nestInt.isInteger())\n            res.push_back(nestInt.getInteger());\n        else\n            for (NestedInteger item: nestInt.getList())\n                linearize(item, res);\n        return;\n    }\n    NestedIterator(vector<NestedInteger> &nestedList) \n    {\n        for (NestedInteger nestInt: nestedList)\n            linearize(nestInt, arr);\n    }\n    \n    int next() \n    {\n        return arr[index++];\n    }\n    \n    bool hasNext() \n    {\n        return index < arr.size();\n    }\n};\n\n```","creationDate":1665670248}},"acRate":61.764700794824556,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"341","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"flatten-nested-list-iterator","topicTags":[{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"},{"name":"Queue","id":"VG9waWNUYWdOb2RlOjM0","slug":"queue"},{"name":"Iterator","id":"VG9waWNUYWdOb2RlOjYxMDY0","slug":"iterator"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p>\n\n<p>Implement the <code>NestedIterator</code> class:</p>\n\n<ul>\n\t<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</li>\n\t<li><code>int next()</code> Returns the next integer in the nested list.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.</li>\n</ul>\n\n<p>Your code will be tested with the following pseudocode:</p>\n\n<pre>\ninitialize iterator with nestedList\nres = []\nwhile iterator.hasNext()\n    append iterator.next() to the end of res\nreturn res\n</pre>\n\n<p>If <code>res</code> matches the expected flattened list, then your code will be judged as correct.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]\n<strong>Output:</strong> [1,1,2,1,1]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nestedList = [1,[4,[6]]]\n<strong>Output:</strong> [1,4,6]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nestedList.length &lt;= 500</code></li>\n\t<li>The values of the integers in the nested list is in the range <code>[-10<sup>6</sup>, 10<sup>6</sup>]</code>.</li>\n</ul>\n"},{"id":"2698602","title":"Word Search","url":"/discuss/topic/2698602/help-needed-for-dfs-solution","questionTitle":"Word Search","post":{"creationDate":1665667761},"post_data":{"id":2698602,"title":"Help needed for DFS solution","solutionTags":[],"post":{"id":4345461,"content":"Like others my solution also uses DFS but I am getting TLE. It uses more memory than other approaches (to store copies of intermediate strings `curr` and  boolean`visited` matrices) but can that lead to TLE?\n\n```\nclass Solution {\npublic:\n    bool dfs(vector<vector<char>>& board, int m, int n, int i,  int j, string word, string curr, vector<vector<bool>> visited)\n    {\n        if (i<0 || i>=m || j<0 || j>=n || visited[i][j] || board[i][j]!=word[curr.length()]) return false;\n        visited[i][j] = true;\n        curr.push_back(board[i][j]);\n        if (word==curr) return true;\n        return dfs(board,m,n,i-1,j,word,curr,visited) ||\n               dfs(board,m,n,i+1,j,word,curr,visited) ||\n               dfs(board,m,n,i,j-1,word,curr,visited) ||\n               dfs(board,m,n,i,j+1,word,curr,visited);\n    }\n\n\tbool exist(vector<vector<char>>& board, string word) \n    {\n        int m = board.size(), n = board[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n,false));\n        for (int i=0; i<m; i++)\n        {\n            for (int j=0; j<n; j++)\n            {\n                if (dfs(board, m, n, i, j, word, \"\", visited))\n                    return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n# EDIT:\nBased on other answers I modified above code to a low memory solution and it gets AC:\n```\nclass Solution {\npublic:\n    bool dfs(vector<vector<char>>& board, int m, int n, int i,  int j, string word, int index)\n    {\n        if (i<0 || i>=m || j<0 || j>=n || board[i][j]!=word[index]) return false;\n        board[i][j] = \"*\";\n        if (index==word.length()-1) return true;\n        bool res =  dfs(board,m,n,i-1,j,word,index+1) ||\n                       dfs(board,m,n,i+1,j,word,index+1) ||\n                       dfs(board,m,n,i,j-1,word,index+1) ||\n                       dfs(board,m,n,i,j+1,word,index+1);\n        board[i][j] = word[index];\n        return res;\n    }\n    bool exist(vector<vector<char>>& board, string word) \n    {\n        int m = board.size(), n = board[0].size();\n        for (int i=0; i<m; i++)\n        {\n            for (int j=0; j<n; j++)\n            {\n                if (dfs(board, m, n, i, j, word, 0))\n                    return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\nNow both of these have same TC (`O(m*n*|word|)`) but SC is lesser (`O(m*n*|word|)`  for the TLE solution vs `O(|word|)` for the AC solution. Can this lead to TLE? Shouldn\"t it be `Memory limited exceeded` or something if it takes too much memory space?","creationDate":1665667761}},"acRate":40.1786034431166,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"79","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"word-search","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Backtracking","id":"VG9waWNUYWdOb2RlOjE0","slug":"backtracking"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p>\n\n<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 6</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 15</code></li>\n\t<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you use search pruning to make your solution faster with a larger <code>board</code>?</p>\n"},{"id":"2697150","title":"Delete Node in a Linked List","url":"/discuss/topic/2697150/3-solutions","questionTitle":"Delete Node in a Linked List","post":{"creationDate":1665640282},"post_data":{"id":2697150,"title":"3 solutions","solutionTags":[{"name":"C++"}],"post":{"id":4343631,"content":"We can move all values one node to the left.\n```\n    void deleteNode(ListNode* node) \n    {\n        ListNode *curr = node, *prev;\n        while (curr->next)\n        {\n            curr->val = curr->next->val;\n            prev = curr;\n            curr = curr->next;\n        }\n        prev->next = NULL;\n    }\n```\nThis solution has O(N) TC and is accepted.\n\nHowever we can do better! We can just update `node->val` and make `node->next` point to `node->next->next`. That should suffice.\n```\n    void deleteNode(ListNode* node) \n    {\n        node->val = node->next->val;\n        node->next = node->next->next;\n    }\n```\n\nThis solution has O(1) TC and has good score.\nWe can make the code shorter! We can achieve the above with just one line:\n```\n    void deleteNode(ListNode* node) \n    {\n        *node = *(node->next);\n    }\n```\nThis is also O(1), same as 2nd one. The one-liner thing is just a flex, you don\"t need it in a real iterview. 2nd solution is best in my opinion.","creationDate":1665640282}},"acRate":75.8098212465717,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"237","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"delete-node-in-a-linked-list","topicTags":[{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>There is a singly-linked list <code>head</code> and we want to delete a node <code>node</code> in it.</p>\n\n<p>You are given the node to be deleted <code>node</code>. You will <strong>not be given access</strong> to the first node of <code>head</code>.</p>\n\n<p>All the values of the linked list are <strong>unique</strong>, and it is guaranteed that the given node <code>node</code> is not the last node in the linked list.</p>\n\n<p>Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:</p>\n\n<ul>\n\t<li>The value of the given node should not exist in the linked list.</li>\n\t<li>The number of nodes in the linked list should decrease by one.</li>\n\t<li>All the values before <code>node</code> should be in the same order.</li>\n\t<li>All the values after <code>node</code> should be in the same order.</li>\n</ul>\n\n<p><strong>Custom testing:</strong></p>\n\n<ul>\n\t<li>For the input, you should provide the entire linked list <code>head</code> and the node to be given <code>node</code>. <code>node</code> should not be the last node of the list and should be an actual node in the list.</li>\n\t<li>We will build the linked list and pass the node to your function.</li>\n\t<li>The output will be the entire list after calling your function.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" style=\"width: 400px; height: 286px;\" />\n<pre>\n<strong>Input:</strong> head = [4,5,1,9], node = 5\n<strong>Output:</strong> [4,1,9]\n<strong>Explanation: </strong>You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" style=\"width: 400px; height: 315px;\" />\n<pre>\n<strong>Input:</strong> head = [4,5,1,9], node = 1\n<strong>Output:</strong> [4,5,9]\n<strong>Explanation: </strong>You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the given list is in the range <code>[2, 1000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>The value of each node in the list is <strong>unique</strong>.</li>\n\t<li>The <code>node</code> to be deleted is <strong>in the list</strong> and is <strong>not a tail</strong> node.</li>\n</ul>\n"},{"id":"2696039","title":"Course Schedule II","url":"/discuss/topic/2696039/two-methods-kahns-algorithm-and-dfs","questionTitle":"Course Schedule II","post":{"creationDate":1665609777},"post_data":{"id":2696039,"title":"[Two methods] Kahn's Algorithm and DFS","solutionTags":[{"name":"C++"}],"post":{"id":4342119,"content":"Construct adjacency list graph and inDegrees array. Then run Kahn\"s algorithm.\n# Kahn\"s algorithm\n- Create two arrays `noIncoming` and `doable` both empty initially\n- Put all courses which have no prerequisites in `noIncoming`\n- While `noIncoming` is not empty \n\t- Pop a node from `noIncoming` and insert in `doable`\n\t- Traverse through adjacency list of this node and for each destination node in this adjacency list:\n\t  - Decrement `inDegree` of this destination node. This is equivalent to breaking an edge\n\t  - if `InDegree` is 0 then insert it into `noIncoming`\n\n```\nclass Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) \n    {\n        unordered_map<int,vector<int>> G;\n        unordered_map<int,int> inDegrees;\n        vector<int> noIncoming, doable;\n        \n        for (auto p: prerequisites)\n        {\n            G[p[1]].push_back(p[0]);\n            inDegrees[p[0]]++;\n        }\n        \n        for (int i=0; i<numCourses; i++)\n            if (inDegrees[i]==0)\n                noIncoming.push_back(i);\n        \n        while (noIncoming.size()>0)\n        {\n            int curr = noIncoming.back();\n            noIncoming.pop_back();\n            doable.push_back(curr);\n            for (int nbd: G[curr])\n            {\n                inDegrees[nbd]--;\n                if (inDegrees[nbd]==0)\n                    noIncoming.push_back(nbd);\n            }\n        }\n        if (doable.size() < numCourses) return {};\n        return doable;\n    }\n};\n```\n\n# DFS\nHere we will need to maintain state of node during DFS. We do it using three colors: White(0) for not visited, Black(1) for visited and completed and Grey(2) for currently visiting and inside recursion.\n```\n// Colors: 0-Not visited, 1-visited and done, 2-visiting and recursion going on\nclass Solution {\n    bool possible = true;\n\npublic:\n    void dfs(unordered_map<int,vector<int>> &G, unordered_map<int,int> &colors, int curr, vector<int> &doable)\n    {\n        if (!this->possible) return;\n        colors[curr] = 2;\n        for (int nbd: G[curr])\n        {\n            if (colors[nbd]==0)\n                dfs(G,colors,nbd,doable);\n            else if (colors[nbd]==2)\n                this->possible = false;\n        }\n        colors[curr] = 1;\n        doable.push_back(curr);\n    }\n\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) \n    {\n        unordered_map<int,vector<int>> G;\n        unordered_map<int,int> colors;\n        vector<int> doable;\n        \n        for (auto p: prerequisites)\n            G[p[1]].push_back(p[0]);\n        for (int i=0; i<numCourses; i++)\n            colors[i] = 0;\n\n        for (int curr=0; curr<numCourses; curr++)\n        {\n            if (colors[curr]==0)\n                dfs(G, colors, curr, doable);\n        }\n        \n        if (!this->possible) return {};\n        reverse(doable.begin(), doable.end());\n        return doable;\n    }\n};\n```","creationDate":1665609777}},"acRate":48.3617409845127,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"210","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"course-schedule-ii","topicTags":[{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Graph","id":"VG9waWNUYWdOb2RlOjI0","slug":"graph"},{"name":"Topological Sort","id":"VG9waWNUYWdOb2RlOjI2","slug":"topological-sort"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>Output:</strong> [0,2,1,3]\n<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 1, prerequisites = []\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>distinct</strong>.</li>\n</ul>\n"},{"id":"2688732","title":"Copy List with Random Pointer","url":"/discuss/topic/2688732/c-hashmap","questionTitle":"Copy List with Random Pointer","post":{"creationDate":1665462983},"post_data":{"id":2688732,"title":"C++ Hashmap","solutionTags":[{"name":"C++"}],"post":{"id":4332504,"content":"```\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) \n    {\n        if (!head) return head;\n        unordered_map<Node*,Node*> H;\n        Node *curr = head;\n        while(curr)\n        {\n            H[curr] = new Node(curr->val);\n            curr = curr->next;\n        }\n        curr = head;\n        while (curr)\n        {\n            H[curr]->next = H[curr->next];\n            H[curr]->random = H[curr->random];\n            curr = curr->next;\n        }\n        return H[head];\n    }\n};\n```","creationDate":1665462983}},"acRate":51.13171306260862,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"138","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"copy-list-with-random-pointer","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>\n\n<p>Construct a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>\n\n<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>\n\n<p>Return <em>the head of the copied linked list</em>.</p>\n\n<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n\n<ul>\n\t<li><code>val</code>: an integer representing <code>Node.val</code></li>\n\t<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n\n<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\" style=\"width: 700px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\" style=\"width: 700px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [[1,1],[2,1]]\n<strong>Output:</strong> [[1,1],[2,1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\" style=\"width: 700px; height: 122px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [[3,null],[3,0],[3,null]]\n<strong>Output:</strong> [[3,null],[3,0],[3,null]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li>\n</ul>\n"},{"id":"2684917","title":"Break a Palindrome","url":"/discuss/topic/2684917/6-liner-simple-logic-simple-solution","questionTitle":"Break a Palindrome","post":{"creationDate":1665387320},"post_data":{"id":2684917,"title":"[6 liner] Simple logic simple solution","solutionTags":[{"name":"C++"}],"post":{"id":4327495,"content":"The idea is to walk till centre and stop if you do not see \"a\". If you have reached centre than the input was either a string of type `aaxaa` (odd `len(input)` and centre is not `a`) or `aaa..a` (only a\"s). In both cases, the solution is to replace last character with a \"b\".\n\n```\nclass Solution {\npublic:\n    string breakPalindrome(string palindrome) \n    {\n        int n = palindrome.length(), i=0;\n        if (n==1) return \"\";\n        while (i<n/2 && palindrome[i]==\"a\") i++;\n        if (i==n/2) palindrome[n-1] = \"b\";\n        else palindrome[i] = \"a\";\n        return palindrome;\n    }\n};\n```","creationDate":1665387320}},"acRate":52.73785344594769,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1328","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"break-a-palindrome","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Greedy","id":"VG9waWNUYWdOb2RlOjE3","slug":"greedy"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a palindromic string of lowercase English letters <code>palindrome</code>, replace <strong>exactly one</strong> character with any lowercase English letter so that the resulting string is <strong>not</strong> a palindrome and that it is the <strong>lexicographically smallest</strong> one possible.</p>\n\n<p>Return <em>the resulting string. If there is no way to replace a character to make it not a palindrome, return an <strong>empty string</strong>.</em></p>\n\n<p>A string <code>a</code> is lexicographically smaller than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, <code>a</code> has a character strictly smaller than the corresponding character in <code>b</code>. For example, <code>&quot;abcc&quot;</code> is lexicographically smaller than <code>&quot;abcd&quot;</code> because the first position they differ is at the fourth character, and <code>&#39;c&#39;</code> is smaller than <code>&#39;d&#39;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> palindrome = &quot;abccba&quot;\n<strong>Output:</strong> &quot;aaccba&quot;\n<strong>Explanation:</strong> There are many ways to make &quot;abccba&quot; not a palindrome, such as &quot;<u>z</u>bccba&quot;, &quot;a<u>a</u>ccba&quot;, and &quot;ab<u>a</u>cba&quot;.\nOf all the ways, &quot;aaccba&quot; is the lexicographically smallest.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> palindrome = &quot;a&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There is no way to replace a single character to make &quot;a&quot; not a palindrome, so return an empty string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= palindrome.length &lt;= 1000</code></li>\n\t<li><code>palindrome</code> consists of only lowercase English letters.</li>\n</ul>\n"},{"id":"2670346","title":"Binary Tree Zigzag Level Order Traversal","url":"/discuss/topic/2670346/bfs-using-queue","questionTitle":"Binary Tree Zigzag Level Order Traversal","post":{"creationDate":1665093676},"post_data":{"id":2670346,"title":"BFS using Queue","solutionTags":[{"name":"C++"},{"name":"Breadth-First Search"},{"name":"Queue"}],"post":{"id":4307787,"content":"This is a standard BFS problem. BFS traversal always will use a queue and the way it works is you add all the adjoining nodes of current node to queue. Then for these newly added nodes traverse and add their children to the queue but remember to not traverse these children ie mark till where we had added the adjoining and traverse only till there. \n\n```\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        if  (!root) return {};\n        queue<TreeNode *> Q;\n        Q.push(root);\n        int level = 1;\n        vector<vector<int>> res;\n        while(!Q.empty())\n        {\n            vector<int> levelVals;\n            for (int i=Q.size()-1; i>=0; --i)\n            {\n                TreeNode *node = Q.front();\n                levelVals.push_back(node->val);\n                if (node->left) Q.push(node->left);\n                if (node->right) Q.push(node->right);\n                Q.pop();\n            }\n            if (level%2 == 0)\n                reverse(levelVals.begin(), levelVals.end());\n            res.push_back(levelVals);\n            level ++;\n        }\n        return res;\n    }\n};\n```\n\n> Then for these newly added nodes traverse and add their children to the queue but remember to not traverse these children ie mark till where we had added the adjoining and traverse only till there.\n\nFor this reason in the inner for loop,\n```\n            for (int i=Q.size()-1; i>=0; --i)\n```\nworks but the following wont work. Although the difference is very subtle.\n```\n            for (int i=0; i<Q.size(); ++i)\n```\nThis is because `Q.size()` is going to change inside for loop so it can be used as initializer but not for termination criterion.","creationDate":1665093676}},"acRate":56.73009286605377,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"103","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"binary-tree-zigzag-level-order-traversal","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes&#39; values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[20,9],[15,7]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"},{"id":"2669117","title":"Plus One","url":"/discuss/topic/2669117/simple-c-solution-with-explanation","questionTitle":"Plus One","post":{"creationDate":1665070125},"post_data":{"id":2669117,"title":"Simple c++ solution with explanation","solutionTags":[{"name":"C++"}],"post":{"id":4306143,"content":"Logic is to start from right end towards left and till you see nine ,change to zero, Now if stopping point is -1 then this means input was of the form `999..9` so answer has to be `1000..0` and if stopping point is somewhere in the middle then we can just increment it like `...2999` becomes `...3000`.\n\n```\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) \n    {\n        int i = digits.size() - 1;\n        while (i>=0 && digits[i]==9) \n        {\n            digits[i]=0; \n            i--;\n        }\n        if (i==-1) digits.insert(digits.begin(), 1);\n        else digits[i]++;\n        return digits;\n    }\n};\n```\n\n\nWe can also do it in the form of a standard addition. This method will also work if instead of 1, we need to add some other number. This uses the standard \"Carry over\" method of addition.\n```\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int carry = 1;\n        for (int i=digits.size()-1; i>=0; --i)\n        {\n            int temp = (carry+digits[i]);\n            digits[i] = temp%10;\n            carry = temp/10;\n        }\n        if (carry>0) digits.insert(digits.begin(), carry);\n        return digits;\n    }\n};\n```","creationDate":1665070125}},"acRate":43.61998983186138,"difficulty":"Easy","freqBar":null,"frontendQuestionId":"66","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"plus-one","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>i<sup>th</sup></code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>&#39;s.</p>\n\n<p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [1,2,3]\n<strong>Output:</strong> [1,2,4]\n<strong>Explanation:</strong> The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [4,3,2,1]\n<strong>Output:</strong> [4,3,2,2]\n<strong>Explanation:</strong> The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [9]\n<strong>Output:</strong> [1,0]\n<strong>Explanation:</strong> The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n\t<li><code>digits</code> does not contain any leading <code>0</code>&#39;s.</li>\n</ul>\n"},{"id":"2668565","title":"Time Based Key-Value Store","url":"/discuss/topic/2668565/hashmap-ordered-map","questionTitle":"Time Based Key-Value Store","post":{"creationDate":1665060273},"post_data":{"id":2668565,"title":"HashMap + Ordered Map","solutionTags":[{"name":"C++"},{"name":"Binary Search"}],"post":{"id":4305397,"content":"The underlying idea is to use HashMap for key-wise storing data and ordered map for (timestamp,value) pairs ordered by timestamp for each key. Then we can do `get` and `set` operations for any key using binary search in its corresponding ordered map. More details in comments:\n\n```\nclass TimeMap \n{\n\tprivate:\n    unordered_map<string, map<int,string>> data;\n\n\tpublic:\n    TimeMap() {}\n    \n    void set(string key, string value, int timestamp) \n    {\n        if (!data.count(key))    // New key insertion\n        {\n            data[key] = {{timestamp, value}};\n            return;\n        }\n\t\t// If the same timestamp repeats for any key, replace it. We dont really need this line because of constraint but no harm\n        if (data[key].count(timestamp)) data[key].erase(timestamp);\n\t\t// Finally insert in ordered map\n        data[key].insert({timestamp, value});\n    }\n    \n    string get(string key, int timestamp) \n    {\n        if (!data.count(key)) return \"\";    // key not found\n        auto it = data[key].lower_bound(timestamp);\n        if (it != data[key].end() && (*it).first==timestamp)    // Exact timestamp found\n            return (*it).second;\n        if (it == data[key].begin()) return \"\";    // timestamp asked is before first time set\n        --it;    // it now points to the last time it was set before \"timestamp\"\n        return (*it).second;    // finally return value\n    }\n};\n ```","creationDate":1665060273}},"acRate":52.56693460786443,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"981","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"time-based-key-value-store","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"},{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key&#39;s value at a certain timestamp.</p>\n\n<p>Implement the <code>TimeMap</code> class:</p>\n\n<ul>\n\t<li><code>TimeMap()</code> Initializes the object of the data structure.</li>\n\t<li><code>void set(String key, String value, int timestamp)</code> Stores the key <code>key</code> with the value <code>value </code>at the given time <code>timestamp</code>.</li>\n\t<li><code>String get(String key, int timestamp)</code> Returns a value such that <code>set</code> was called previously, with <code>timestamp_prev &lt;= timestamp</code>. If there are multiple such values, it returns the value associated with the largest <code>timestamp_prev</code>. If there are no values, it returns <code>&quot;&quot;</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;TimeMap&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;, &quot;set&quot;, &quot;get&quot;, &quot;get&quot;]\n[[], [&quot;foo&quot;, &quot;bar&quot;, 1], [&quot;foo&quot;, 1], [&quot;foo&quot;, 3], [&quot;foo&quot;, &quot;bar2&quot;, 4], [&quot;foo&quot;, 4], [&quot;foo&quot;, 5]]\n<strong>Output</strong>\n[null, null, &quot;bar&quot;, &quot;bar&quot;, null, &quot;bar2&quot;, &quot;bar2&quot;]\n\n<strong>Explanation</strong>\nTimeMap timeMap = new TimeMap();\ntimeMap.set(&quot;foo&quot;, &quot;bar&quot;, 1);  // store the key &quot;foo&quot; and value &quot;bar&quot; along with timestamp = 1.\ntimeMap.get(&quot;foo&quot;, 1);         // return &quot;bar&quot;\ntimeMap.get(&quot;foo&quot;, 3);         // return &quot;bar&quot;, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is &quot;bar&quot;.\ntimeMap.set(&quot;foo&quot;, &quot;bar2&quot;, 4); // store the key &quot;foo&quot; and value &quot;bar2&quot; along with timestamp = 4.\ntimeMap.get(&quot;foo&quot;, 4);         // return &quot;bar2&quot;\ntimeMap.get(&quot;foo&quot;, 5);         // return &quot;bar2&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length, value.length &lt;= 100</code></li>\n\t<li><code>key</code> and <code>value</code> consist of lowercase English letters and digits.</li>\n\t<li><code>1 &lt;= timestamp &lt;= 10<sup>7</sup></code></li>\n\t<li>All the timestamps <code>timestamp</code> of <code>set</code> are strictly increasing.</li>\n\t<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>set</code> and <code>get</code>.</li>\n</ul>\n"},{"id":"2662762","title":"Add One Row to Tree","url":"/discuss/topic/2662762/easy-to-understand-dfs-solution","questionTitle":"Add One Row to Tree","post":{"creationDate":1664949806},"post_data":{"id":2662762,"title":"Easy to understand DFS solution","solutionTags":[],"post":{"id":4297613,"content":"This is a plain DFS problem. Logic in comments.\n```\nclass Solution {\npublic:\n    void dfs(TreeNode *root, int val, int depth, int curDepth)\n    {\n        if (!root) return;\n\t\t// We need to insert as per the rule at this point\n        if (depth==curDepth+1)\n        {\n            root->left = new TreeNode(val, root->left, NULL);\n            root->right = new TreeNode(val, NULL, root->right);\n            return;\n        }\n        dfs(root->left, val, depth, curDepth+1);\n        dfs(root->right, val, depth, curDepth+1);\n    }\n    TreeNode* addOneRow(TreeNode* root, int val, int depth) \n    {\n\t\t// Special case when we have to insert at root\n        if (depth==1) return new TreeNode(val, root, NULL);\n        dfs(root, val, depth, 1);\n        return root;\n    }\n};\n```","creationDate":1664949806}},"acRate":59.47193099619417,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"623","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"add-one-row-to-tree","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the <code>root</code> of a binary tree and two integers <code>val</code> and <code>depth</code>, add a row of nodes with value <code>val</code> at the given depth <code>depth</code>.</p>\n\n<p>Note that the <code>root</code> node is at depth <code>1</code>.</p>\n\n<p>The adding rule is:</p>\n\n<ul>\n\t<li>Given the integer <code>depth</code>, for each not null tree node <code>cur</code> at the depth <code>depth - 1</code>, create two tree nodes with value <code>val</code> as <code>cur</code>&#39;s left subtree root and right subtree root.</li>\n\t<li><code>cur</code>&#39;s original left subtree should be the left subtree of the new left subtree root.</li>\n\t<li><code>cur</code>&#39;s original right subtree should be the right subtree of the new right subtree root.</li>\n\t<li>If <code>depth == 1</code> that means there is no depth <code>depth - 1</code> at all, then create a tree node with value <code>val</code> as the new root of the whole original tree, and the original tree is the new root&#39;s left subtree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg\" style=\"width: 500px; height: 231px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,6,3,1,5], val = 1, depth = 2\n<strong>Output:</strong> [4,1,1,2,null,null,6,3,1,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg\" style=\"width: 500px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,null,3,1], val = 1, depth = 3\n<strong>Output:</strong> [4,2,null,1,1,3,null,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li>The depth of the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= depth &lt;= the depth of tree + 1</code></li>\n</ul>\n"},{"id":"2661424","title":"Group Anagrams","url":"/discuss/topic/2661424/easy-hashmap","questionTitle":"Group Anagrams","post":{"creationDate":1664913723},"post_data":{"id":2661424,"title":"Easy hashmap","solutionTags":[{"name":"C++"},{"name":"Python"}],"post":{"id":4295824,"content":"Basic idea is to match sorted version of string. Note that anagrams will have same result when sorted. So let us use this as a key for Hashmap.\n\nC++:\n```\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> H;\n        for (string str: strs)\n        {\n            string strsorted = str;\n            sort(strsorted.begin(),strsorted.end());\n            if (H.count(strsorted))\n            {\n                H[strsorted].push_back(str);\n                continue;\n            }\n            H[strsorted] = {str};\n        }\n        vector<vector<string>>res;\n        for (auto p: H) res.push_back(p.second);\n        return res;\n    }\n};\n```\n\nPython:\n```\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        H = {}\n        for str in strs:\n            strsorted = \"\".join(sorted(str))\n            if strsorted in H:\n                H[strsorted].append(str)\n                continue\n            H[strsorted] = [str];\n        return list(H.values())\n```","creationDate":1664913723}},"acRate":66.67575893486055,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"49","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"group-anagrams","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n<strong>Output:</strong> [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> strs = [\"\"]\n<strong>Output:</strong> [[\"\"]]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> strs = [\"a\"]\n<strong>Output:</strong> [[\"a\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code> consists of lowercase English letters.</li>\n</ul>\n"},{"id":"2661294","title":"Spiral Matrix","url":"/discuss/topic/2661294/spiral-traversal","questionTitle":"Spiral Matrix","post":{"creationDate":1664911139},"post_data":{"id":2661294,"title":"Spiral traversal","solutionTags":[{"name":"C++"}],"post":{"id":4295658,"content":"Just remember to keep track of start and end indices for x and y directions.\n```\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) \n    {\n        int m=matrix.size(), n=matrix[0].size(), i=0, j=0;\n        int sy=0, sx=0, ey=m, ex=n; // m=ey=3, n=ex=4\n        vector<int> res;\n        while (res.size() < m*n)\n        {\n            while (res.size() < m*n && j<ex)\n            {\n                res.push_back(matrix[i][j]);\n                j++;\n            }\n            j--; i++; ex--;\n            while (res.size() < m*n && i<ey)\n            {\n                res.push_back(matrix[i][j]);\n                i++;\n            }\n            i--; j--; ey--;\n            while (res.size() < m*n && j>=sx)\n            {\n                res.push_back(matrix[i][j]);\n                j--;\n            }\n            j++; i--; sx++;\n            while (res.size() < m*n && i>sy)\n            {\n                res.push_back(matrix[i][j]);\n                i--; \n            }\n            i++; j++; sy++;\n        }\n        return res;\n    }\n};\n```","creationDate":1664911139}},"acRate":44.63284714666784,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"54","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"spiral-matrix","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"},{"name":"Simulation","id":"VG9waWNUYWdOb2RlOjYxMDU1","slug":"simulation"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n"},{"id":"2660855","title":"Count and Say","url":"/discuss/topic/2660855/rle-simulation-of-say","questionTitle":"Count and Say","post":{"creationDate":1664903840},"post_data":{"id":2660855,"title":"RLE Simulation of \"say\"","solutionTags":[{"name":"C++"}],"post":{"id":4295075,"content":"First write and verify \"say\" function that will write a number in RLE notation. Then the problem becomes easy.\n```\nclass Solution {\npublic:\n    string say(string num)\n    {\n        int i=0;\n        string res = \"\";\n        while(i<num.length())\n        {\n            int j=i;\n            while(j<num.length()&&num[j]==num[i]) j++;\n            res.push_back(j-i+\"0\");\n            res.push_back(num[i]);\n            i = j;\n        }\n        return res;\n    }\n    string countAndSay(int n) \n    {\n        vector<string> vec(n);\n        vec[0] = \"1\";\n        for (int i=1; i<n; i++)\n            vec[i] = say(vec[i-1]);\n        return vec[n-1];\n    }\n};\n```\n\n```\nRuntime: 3 ms, faster than 93.66% of C++ online submissions for Count and Say.\nMemory Usage: 7 MB, less than 33.51% of C++ online submissions for Count and Say.\n```","creationDate":1664903840}},"acRate":51.874438488895215,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"38","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"count-and-say","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>The <strong>count-and-say</strong> sequence is a sequence of digit strings defined by the recursive formula:</p>\n\n<ul>\n\t<li><code>countAndSay(1) = &quot;1&quot;</code></li>\n\t<li><code>countAndSay(n)</code> is the way you would &quot;say&quot; the digit string from <code>countAndSay(n-1)</code>, which is then converted into a different digit string.</li>\n</ul>\n\n<p>To determine how you &quot;say&quot; a digit string, split it into the <strong>minimal</strong> number of substrings such that each substring contains exactly <strong>one</strong> unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</p>\n\n<p>For example, the saying and conversion for digit string <code>&quot;3322251&quot;</code>:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg\" style=\"width: 581px; height: 172px;\" />\n<p>Given a positive integer <code>n</code>, return <em>the </em><code>n<sup>th</sup></code><em> term of the <strong>count-and-say</strong> sequence</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> &quot;1&quot;\n<strong>Explanation:</strong> This is the base case.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> &quot;1211&quot;\n<strong>Explanation:</strong>\ncountAndSay(1) = &quot;1&quot;\ncountAndSay(2) = say &quot;1&quot; = one 1 = &quot;11&quot;\ncountAndSay(3) = say &quot;11&quot; = two 1&#39;s = &quot;21&quot;\ncountAndSay(4) = say &quot;21&quot; = one 2 + one 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n"},{"id":"2660501","title":"Search in Rotated Sorted Array","url":"/discuss/topic/2660501/faster-than-100-rotation-pivot-using-binary-search","questionTitle":"Search in Rotated Sorted Array","post":{"creationDate":1664897705},"post_data":{"id":2660501,"title":"Faster than 100% -- Rotation pivot using binary search","solutionTags":[],"post":{"id":4294619,"content":"Firstly find the pivot of rotation ([reference](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/2741593/Iterative-binary-search)).\nThen find out which side the target would lie wrt pivot and search in that side.\n\n\n```\nclass Solution {\npublic:\n    int countRotations(vector<int>& nums) \n    {\n        int n=nums.size(), lo=0, hi=n-1, mid;\n        while (lo<=hi)\n        {\n            mid = lo + (hi-lo)/2;\n            int prev = (mid-1+n)%n, next = (mid+1)%n;\n            if (nums[mid]<=nums[prev] && nums[mid]<=nums[next])\n                break;\n            else if (nums[mid] <= nums[hi])\n                hi = mid-1;\n            else\n                lo = mid+1; // nums[mid]>=nums[0]\n        }\n        return mid;\n    }\n\n    int search(vector<int>& nums, int target) \n    {\n        int pivot = countRotations(nums);\n        vector<int>::iterator it;\n        if (target < nums[0] || pivot==0)\n            it = lower_bound(nums.begin()+pivot, nums.end(), target);\n        else\n            it = lower_bound(nums.begin(), nums.begin()+pivot, target);\n        if (it==nums.end()) return -1;\n        if (*it==target) return it-nums.begin();\n        return -1;\n    }\n};\n```\n```\nTC: O(log(N))\nSC: O(1)\n```\n```\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Search in Rotated Sorted Array.\nMemory Usage: 11.9 MB, less than 28.90% of C++ online submissions for Search in Rotated Sorted Array.\n```","creationDate":1664897705}},"acRate":38.89695254319462,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"33","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"search-in-rotated-sorted-array","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>\n\n<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0\n<strong>Output:</strong> 4\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3\n<strong>Output:</strong> -1\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1], target = 0\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is an ascending array that is possibly rotated.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n"},{"id":"2660003","title":"Largest Divisible Subset","url":"/discuss/topic/2660003/dp-faster-than-95","questionTitle":"Largest Divisible Subset","post":{"creationDate":1664889498},"post_data":{"id":2660003,"title":"DP faster than 95%","solutionTags":[],"post":{"id":4293953,"content":"The solution is similar to O(N^2) solution for LIS except that we also have to do backtracking, so we maintain 2 values per item in DP: the maximum size of sequence ending at that index and the index of the number it is a multiple of.\n\n```\nbool cmp(pair<int,int>a, pair<int,int>b)\n{\n    return a.first<b.first;\n}\n\nclass Solution {\npublic:\n    vector<int> largestDivisibleSubset(vector<int>& nums) \n    {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        vector<pair<int,int>> dp(n,{1,-1});\n        for (int i=1; i<n; i++)            \n            for (int j=0; j<i; j++)\n                if (nums[i]%nums[j]==0 && 1+dp[j].first>dp[i].first)\n                    dp[i] = {1+dp[j].first,j};\n        auto it = max_element(dp.begin(),dp.end(),cmp);\n        auto p = *it;\n        vector<int> res{nums[it-dp.begin()]};\n        while(p.second>=0)\n        {\n            res.push_back(nums[p.second]);\n            p = dp[p.second];\n        }\n        return res;\n    }\n};\n```\nThis is faster than 95% of solutions:\n```\nRuntime: 52 ms, faster than 95.12% of C++ online submissions for Largest Divisible Subset.\nMemory Usage: 8.9 MB, less than 46.13% of C++ online submissions for Largest Divisible Subset.\n```\n\nI\"m reproducing the O(N^2) solution of LIS for clarity:\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n,1);\n        for (int i=0; i<n; i++)\n            for (int j=0; j<i; j++)\n                if (nums[i]>nums[j])\n                    dp[i] = max(dp[j]+1,dp[i]);\n        return *max_element(dp.begin(),dp.end());\n    }\n};\n```\n\nFor more details on LIS algorithm refer [here](https://leetcode.com/problems/longest-increasing-subsequence/discuss/2660000/Two-DP-solutions).","creationDate":1664889498}},"acRate":41.43718987612894,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"368","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"largest-divisible-subset","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a set of <strong>distinct</strong> positive integers <code>nums</code>, return the largest subset <code>answer</code> such that every pair <code>(answer[i], answer[j])</code> of elements in this subset satisfies:</p>\n\n<ul>\n\t<li><code>answer[i] % answer[j] == 0</code>, or</li>\n\t<li><code>answer[j] % answer[i] == 0</code></li>\n</ul>\n\n<p>If there are multiple solutions, return any of them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> [1,3] is also accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,4,8]\n<strong>Output:</strong> [1,2,4,8]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>9</sup></code></li>\n\t<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n"},{"id":"2660000","title":"Longest Increasing Subsequence","url":"/discuss/topic/2660000/two-dp-solutions","questionTitle":"Longest Increasing Subsequence","post":{"creationDate":1664889459},"post_data":{"id":2660000,"title":"Two DP solutions","solutionTags":[{"name":"C++"}],"post":{"id":4293950,"content":"Fastest O(N log N) solution in C++:\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        vector<int> sub;\n        for (int n: nums)\n        {\n            if (sub.size()==0 || n > sub[sub.size()-1])\n                sub.push_back(n);\n            else\n            {\n                vector<int>::iterator it = lower_bound(sub.begin(),sub.end(),n);\n                *it = n;\n            }\n        }\n        return sub.size();\n    }\n};\n```\n\nO(N^2) solution:\nC++:\n```\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> dp(n,1);\n        for(int i=0;i<n;i++) for(int j=0;j<i;j++) if(nums[i]>nums[j]) dp[i]=max(dp[i],dp[j]+1); \n        return *max_element(dp.begin(), dp.end());\n    }\n};\n```\nPython:\n```\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [1 for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                if nums[i]>nums[j]:\n                    dp[i] = max(dp[i], dp[j]+1)\n        return max(dp)\n```\nJava:\n```\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        for(int i=0; i<n; i++)\n        {\n            for (int j=0; j<i; j++)\n            {\n                if(nums[i]>nums[j])\n                {\n                    dp[i] = Math.max(dp[i], dp[j]+1);\n                }\n            }\n        }\n        return Arrays.stream(dp).max().getAsInt();\n    }\n}\n```\nJavaScript:\n```\nvar lengthOfLIS = function(nums) {\n    var n = nums.length;\n    var dp = Array(n);\n    dp.fill(1);\n    for(let i=0; i<n; i++)\n        {\n            for (let j=0; j<i; j++)\n                {\n                    if (nums[i]>nums[j]){\n                        dp[i] = Math.max(dp[i],dp[j]+1);\n                    }\n                }\n        }\n    return Math.max(...dp);\n};\n```","creationDate":1664889459}},"acRate":51.96417447863062,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"300","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"longest-increasing-subsequence","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>strictly increasing </strong></em><span data-keyword=\"subsequence-array\"><em><strong>subsequence</strong></em></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,9,2,5,3,7,101,18]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,0,3,2,3]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,7,7,7,7,7,7]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b>Follow up:</b>&nbsp;Can you come up with an algorithm that runs in&nbsp;<code>O(n log(n))</code> time complexity?</p>\n"},{"id":"2653595","title":"Minimum Time to Make Rope Colorful","url":"/discuss/topic/2653595/easy-approach-on-solution-based-on-rle","questionTitle":"Minimum Time to Make Rope Colorful","post":{"creationDate":1664772466},"post_data":{"id":2653595,"title":"Easy approach O(N) solution based on RLE","solutionTags":[{"name":"C++"}],"post":{"id":4285607,"content":"# Strategy:\nImagine the colors to be written in [RLE](https://en.wikipedia.org/wiki/Run-length_encoding). For eg. \"aabaa\" is written as `{a(2), b(1), a(2)}`. Then when you see a 1, no need to remove anything but when you see anything other than 1, then we have to remove all but the highest time balloon.\n\n```\nclass Solution {\npublic:\n    int minCost(string colors, vector<int>& neededTime) \n    {\n        int i=0, res=0; \n        while (i<colors.length())\n        {\n            int j=i, curSum=0, curMax=INT_MIN;\n            while(j<colors.length() && colors[j]==colors[i])\n            {\n                curSum += neededTime[j];\n                curMax = max(curMax, neededTime[j]);\n                j++;\n            }\n            res += (curSum-curMax);\n            i = j;\n        }\n        return res;\n    }\n};\n```\n\n```\nTC: O(N)\nSC: O(1)\n```","creationDate":1664772466}},"acRate":63.53289444616268,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1578","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"minimum-time-to-make-rope-colorful","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Greedy","id":"VG9waWNUYWdOb2RlOjE3","slug":"greedy"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Alice has <code>n</code> balloons arranged on a rope. You are given a <strong>0-indexed</strong> string <code>colors</code> where <code>colors[i]</code> is the color of the <code>i<sup>th</sup></code> balloon.</p>\n\n<p>Alice wants the rope to be <strong>colorful</strong>. She does not want <strong>two consecutive balloons</strong> to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it <strong>colorful</strong>. You are given a <strong>0-indexed</strong> integer array <code>neededTime</code> where <code>neededTime[i]</code> is the time (in seconds) that Bob needs to remove the <code>i<sup>th</sup></code> balloon from the rope.</p>\n\n<p>Return <em>the <strong>minimum time</strong> Bob needs to make the rope <strong>colorful</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/ballon1.jpg\" style=\"width: 404px; height: 243px;\" />\n<pre>\n<strong>Input:</strong> colors = &quot;abaac&quot;, neededTime = [1,2,3,4,5]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> In the above image, &#39;a&#39; is blue, &#39;b&#39; is red, and &#39;c&#39; is green.\nBob can remove the blue balloon at index 2. This takes 3 seconds.\nThere are no longer two consecutive balloons of the same color. Total time = 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/balloon2.jpg\" style=\"width: 244px; height: 243px;\" />\n<pre>\n<strong>Input:</strong> colors = &quot;abc&quot;, neededTime = [1,2,3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The rope is already colorful. Bob does not need to remove any balloons from the rope.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/balloon3.jpg\" style=\"width: 404px; height: 243px;\" />\n<pre>\n<strong>Input:</strong> colors = &quot;aabaa&quot;, neededTime = [1,2,3,4,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == colors.length == neededTime.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= neededTime[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>colors</code> contains only lowercase English letters.</li>\n</ul>\n"},{"id":"2653407","title":"Number of Dice Rolls With Target Sum","url":"/discuss/topic/2653407/easy-dp-with-examples","questionTitle":"Number of Dice Rolls With Target Sum","post":{"creationDate":1664769940},"post_data":{"id":2653407,"title":"Easy DP with examples","solutionTags":[{"name":"C++"}],"post":{"id":4285368,"content":"Once you ponder over the question, it is easy to find the recurrence relation:\nConsider k (# faces of each die) to be constant. Then, \n```\nrolls(n,target) = rolls(n-1,target-1) + rolls(n-1, target-2) + rolls(n-1, target-3) + ... + rolls(n-1,target-k)\n```\n\nIf you don\"t understand the above equation, consider that first item in the RHS corresponds to the case when last die has value 1 (and so the remaining n-1 dice must sum to target-1), second item corresponds to last die having value 2 (and so the remaining n-1 dice must sum to target-2) and so on such that last item corresponds to last die having value k (and so the remaining n-1 dice must sum to target-k). \n\nWe will create a DP table bottom up. Size of table will be `(n+1, target+1)`. Top row and leftmost column will be zero except `dp[0][0] = 1`.  `dp[i,j]` denotes `rolls(i,j)`\n\nExample of DP table for `numRollsToTarget(1,6,3)`:\n\n| |T=0|T=1|T=2|T=3|\n|--|---|---|---|---|\n| N=0 | 1 | 0 | 0 | 0 |\n| N=1 | 0 | 1 | 1 | 1 |\n\n\nExample of DP table for `numRollsToTarget(2,6,7)`:\n\n| |T=0|T=1|T=2|T=3|T=4|T=5|T=6|T=7\n|--|---|---|---|---|---|---|---|---|\n| N=0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n| N=1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |\n| N=2 | 0 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | \n\nThis gives us the following code:\n```\nclass Solution {\npublic:\n    int numRollsToTarget(int n, int k, int target) \n    {\n        vector<vector<int>> dp(n+1, vector<int>(target+1,0));\n        // dp[i,j] denotes numRollsToTarget(i,k,j)\n        dp[0][0] = 1;\n        for (int i=1; i<=n; i++)\n        {\n            for (int j=1; j<=target; j++)\n            {\n                int temp = 0;\n                for (int p=1; p<=min(k,j); p++) \n                    temp += dp[i-1][j-p];\n                dp[i][j] = temp;\n            }\n        }\n        return dp[n][target];\n    }\n};\n```\n\nThe above code is completely correct and will work (for small input). However we need to also handle large input and do the modulo thing. Hence here is the modified version.\n\n```\nclass Solution {\npublic:\n    int numRollsToTarget(int n, int k, int target) \n    {\n        vector<vector<int>> dp(n+1, vector<int>(target+1,0));\n        // dp[i,j] denotes numRollsToTarget(i,k,j)\n        dp[0][0] = 1;\n        int mod = 1000000007;\n        for (int i=1; i<=n; i++)\n        {\n            for (int j=1; j<=target; j++)\n            {\n                int temp = 0;\n                for (int p=1; p<=min(k,j); p++) \n                {\n                    temp = (temp%mod) + ( dp[i-1][j-p]%mod);\n                    temp %= mod;\n                }\n                dp[i][j] = temp;\n            }\n        }\n        return dp[n][target];\n    }\n};\n```","creationDate":1664769940}},"acRate":53.79807030688543,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1155","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"number-of-dice-rolls-with-target-sum","topicTags":[{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You have <code>n</code> dice, and each die has <code>k</code> faces numbered from <code>1</code> to <code>k</code>.</p>\n\n<p>Given three integers <code>n</code>, <code>k</code>, and <code>target</code>, return <em>the number of possible ways (out of the </em><code>k<sup>n</sup></code><em> total ways) </em><em>to roll the dice, so the sum of the face-up numbers equals </em><code>target</code>. Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 6, target = 3\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You throw one die with 6 faces.\nThere is only one way to get a sum of 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, k = 6, target = 7\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> You throw two dice, each with 6 faces.\nThere are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 30, k = 30, target = 500\n<strong>Output:</strong> 222616187\n<strong>Explanation:</strong> The answer must be returned modulo 10<sup>9</sup> + 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, k &lt;= 30</code></li>\n\t<li><code>1 &lt;= target &lt;= 1000</code></li>\n</ul>\n"},{"id":"2646120","title":"Decode Ways","url":"/discuss/topic/2646120/dp-easy-way","questionTitle":"Decode Ways","post":{"creationDate":1664632502},"post_data":{"id":2646120,"title":"DP Easy Way","solutionTags":[{"name":"C++"}],"post":{"id":4275144,"content":"Let `n = length(s)`\nNow let `dp` be an array of length `n+1`. Define `dp[i]` as the answer for the string `s[0:i]` that is first `i` characters. Hence `dp[n]` will contain the final answer.\n\nConstructing `dp` array.\n- `dp[0] = 1`\n- `dp[1] = 1` if `s[0] > \"0\"`  else `0`.\n- `dp[i] = (condition1) ? dp[i-2]  : 0   +   (condition2) ? dp[i-1] : 0`\n`condition1` states that the last two characters at` i` form a valid alphabet (b/w [10,26]) and `condtition 2` states that the last character at `i` forms a valid alphabet (b/w [1,9]).\n\n```\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        int n = s.length();\n        // dp[i] = Answer for s[:i]\n        vector<int> dp(n+1,-1);\n        dp[0] = 1;\n        dp[1] = (s[0]>\"0\")?1:0;\n        for (int i=2; i<=n; i++)\n        {\n            int a = (s[i-2]==\"1\" || (s[i-2]==\"2\" && s[i-1]<=\"6\")) ? dp[i-2] : 0;\n            int b = (s[i-1]>\"0\") ? dp[i-1] : 0;\n            dp[i] = a + b;\n        }\n        return dp[n];\n    }\n};\n```","creationDate":1664632502}},"acRate":32.60929679644373,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"91","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"decode-ways","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:</p>\n\n<pre>\n&#39;A&#39; -&gt; &quot;1&quot;\n&#39;B&#39; -&gt; &quot;2&quot;\n...\n&#39;Z&#39; -&gt; &quot;26&quot;\n</pre>\n\n<p>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:</p>\n\n<ul>\n\t<li><code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code></li>\n\t<li><code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code></li>\n</ul>\n\n<p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.</p>\n\n<p>Given a string <code>s</code> containing only digits, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.</p>\n\n<p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;12&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;226&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;06&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> &quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> contains only digits and may contain leading zero(s).</li>\n</ul>\n"},{"id":"2632544","title":"Count Sub Islands","url":"/discuss/topic/2632544/dfs-solution","questionTitle":"Count Sub Islands","post":{"creationDate":1664321877},"post_data":{"id":2632544,"title":"DFS solution","solutionTags":[{"name":"C++"}],"post":{"id":4257088,"content":"Run DFS for entire table. Create a vector for each island in `grid2`. If all the cells are also 1 in `grid1`, then this island is a sub-island.\n```\nclass Solution {\npublic:\n    void dfs(vector<vector<int>>&grid, int i, int j, int m, int n, vector<pair<int,int>>&isle)\n    {\n        if(i<0 || i>=m || j<0 || j>=n || grid[i][j]!=1) return;\n        grid[i][j] = 2;\n        isle.push_back({i,j});\n        dfs(grid,i-1,j,m,n,isle);\n        dfs(grid,i+1,j,m,n,isle);\n        dfs(grid,i,j-1,m,n,isle);\n        dfs(grid,i,j+1,m,n,isle);\n    }\n\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\n        int m = grid1.size(), n = grid1[0].size(), res=0;\n        vector<vector<int>> cells;\n        for (int i=0; i<m; i++)\n        {\n            for (int j=0; j<n; j++)\n            {\n                if (grid2[i][j]==1)\n                {\n                    vector<pair<int,int>> isle;\n                    dfs(grid2,i,j,m,n,isle);\n                    bool covered = true;\n                    for (auto p: isle)\n                    {\n                        if (grid1[p.first][p.second] != 1)\n                        {\n                            covered = false;\n                            break;\n                        }\n                    }\n                    if (covered) res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n```","creationDate":1664321877}},"acRate":67.61176687769441,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1905","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"count-sub-islands","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Union Find","id":"VG9waWNUYWdOb2RlOjIz","slug":"union-find"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>You are given two <code>m x n</code> binary matrices <code>grid1</code> and <code>grid2</code> containing only <code>0</code>&#39;s (representing water) and <code>1</code>&#39;s (representing land). An <strong>island</strong> is a group of <code>1</code>&#39;s connected <strong>4-directionally</strong> (horizontal or vertical). Any cells outside of the grid are considered water cells.</p>\n\n<p>An island in <code>grid2</code> is considered a <strong>sub-island </strong>if there is an island in <code>grid1</code> that contains <strong>all</strong> the cells that make up <strong>this</strong> island in <code>grid2</code>.</p>\n\n<p>Return the <em><strong>number</strong> of islands in </em><code>grid2</code> <em>that are considered <strong>sub-islands</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/test1.png\" style=\"width: 493px; height: 205px;\" />\n<pre>\n<strong>Input:</strong> grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]\n<strong>Output:</strong> 3\n<strong>Explanation: </strong>In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\nThe 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png\" style=\"width: 491px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\n<strong>Output:</strong> 2 \n<strong>Explanation: </strong>In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\nThe 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid1.length == grid2.length</code></li>\n\t<li><code>n == grid1[i].length == grid2[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>grid1[i][j]</code> and <code>grid2[i][j]</code> are either <code>0</code> or <code>1</code>.</li>\n</ul>\n"},{"id":"2632484","title":"Swap Nodes in Pairs","url":"/discuss/topic/2632484/recursion","questionTitle":"Swap Nodes in Pairs","post":{"creationDate":1664318260},"post_data":{"id":2632484,"title":"Recursion","solutionTags":[],"post":{"id":4256992,"content":"```\nListNode* swapPairs(ListNode* head) \n{\n\tif (head==NULL || head->next==NULL) return head;\n\tListNode *res = new ListNode(head->next->val);\n\tres->next = new ListNode(head->val);\n\tres->next->next = swapPairs(head->next->next);\n\treturn res;\n}\n```","creationDate":1664318260}},"acRate":61.08588421435655,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"24","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"swap-nodes-in-pairs","topicTags":[{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Recursion","id":"VG9waWNUYWdOb2RlOjMx","slug":"recursion"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a&nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&nbsp;modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4]\n<strong>Output:</strong> [2,1,4,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the&nbsp;list&nbsp;is in the range <code>[0, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"},{"id":"2632475","title":"3Sum Closest","url":"/discuss/topic/2632475/two-pointers-in-sorted-array","questionTitle":"3Sum Closest","post":{"creationDate":1664317728},"post_data":{"id":2632475,"title":"Two pointers in sorted array","solutionTags":[],"post":{"id":4256979,"content":"Any 3 sum problem is best solved by sorting the array and then doing the two pointer method (`O(n^2)`).\n```\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) \n    {\n        int n = nums.size(), closest=nums[0]+nums[1]+nums[2];\n        sort(nums.begin(), nums.end());\n        for (int i=0; i<n-2; i++)\n        {\n            int lo=i+1, hi=n-1;\n            while (lo<hi)\n            {\n                int curr = nums[i]+nums[lo]+nums[hi];\n                if (curr==target) return target;\n                if (abs(target-curr)<abs(target-closest)) closest = curr;\n                if (curr<target) lo ++;\n                else hi--;\n            }\n        }\n        return closest;\n    }\n};\n```","creationDate":1664317728}},"acRate":45.85090195980879,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"16","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"3sum-closest","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.</p>\n\n<p>Return <em>the sum of the three integers</em>.</p>\n\n<p>You may assume that each input would have exactly one solution.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,2,1,-4], target = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0], target = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n"},{"id":"2632452","title":"3Sum","url":"/discuss/topic/2632452/two-pointers-hashmap","questionTitle":"3Sum","post":{"creationDate":1664316761},"post_data":{"id":2632452,"title":"Two pointers + Hashmap","solutionTags":[],"post":{"id":4256950,"content":"The question would be very easy if not for the unique triplet thing. All we need to do is sort the array and for each element `A[i]` solve the `2Sum for sorted array` using the two pointer approach in the subarray `{A[i+1]..A[n-1]}`. \n```\nvector<vector<int>> threeSum(vector<int>& nums, int target=0) {\n\tsort(nums.begin(),nums.end());\n\tint n = nums.size();\n\tvector<vector<int>>res;\n\tfor (int i=0; i<n-2; i++)\n\t{\n\t\tint lo=i+1, hi=n-1;\n\t\twhile (lo<hi)\n\t\t{\n\t\t\tif (nums[i]+nums[lo]+nums[hi]==target) \n\t\t\t{\n\t\t\t\tres.push_back({nums[i],nums[lo],nums[hi]});\n\t\t\t\tlo++;hi--;\n\t\t\t}\n\t\t\telse if (nums[i]+nums[lo]+nums[hi]<target) lo++;\n\t\t\telse hi--;\n\t\t}\n\t}\n\treturn res;\n}\n```\nHowever this will give us duplicate triplets. \n\nTo incorporate the unique triplet thing, we use Hashmaps to store results and before inserting a new result check if it exists already. We use the lowest of the triplet as key and the remaining two are inserted as a pair of ints. There is no particular logic for this choice. You could choose another schema as well.\n```\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums, int target=0) {\n        sort(nums.begin(),nums.end());\n        int n = nums.size();\n        unordered_map<int,vector<pair<int,int>>>H;\n        for (int i=0; i<n-2; i++)\n        {\n            int lo=i+1, hi=n-1;\n            while (lo<hi)\n            {\n                if (nums[i]+nums[lo]+nums[hi]==target) \n                {\n                    bool ok = true;\n                    for (auto p: H[nums[i]])\n                    {\n                        if(nums[lo]==p.first && nums[hi]==p.second)\n                        {\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if (ok) \n                        H[nums[i]].push_back({nums[lo],nums[hi]}); \n                    lo++;hi--;\n                }\n                else if (nums[i]+nums[lo]+nums[hi]<target) lo++;\n                else hi--;\n            }\n        }\n        vector<vector<int>>res;\n        for (auto kv: H)\n            for (auto p: kv.second)\n                res.push_back({kv.first,p.first,p.second});\n        return res;\n    }\n};\n```","creationDate":1664316761}},"acRate":32.48190078496583,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"15","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"3sum","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>\n\n<p>Notice that the solution set must not contain duplicate triplets.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,1,2,-1,-4]\n<strong>Output:</strong> [[-1,-1,2],[-1,0,1]]\n<strong>Explanation:</strong> \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,1]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The only possible triplet does not sum up to 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0]\n<strong>Output:</strong> [[0,0,0]]\n<strong>Explanation:</strong> The only possible triplet sums up to 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"},{"id":"2630910","title":"Shortest Common Supersequence ","url":"/discuss/topic/2630910/dp-lcs-variations","questionTitle":"Shortest Common Supersequence ","post":{"creationDate":1664287683},"post_data":{"id":2630910,"title":"DP LCS variations","solutionTags":[{"name":"C++"}],"post":{"id":4254935,"content":"First solve LCS https://leetcode.com/problems/longest-common-subsequence/\nThen use the DP table and backtrack to construct the answer in reverse.\n- Start at bottom right\n- Case 1: If same as upper left corner of current cell, then `LCS(i,j)=LCS(i-1,j-1)`, hence just copy both the characters. Order will not matter.\n- Case 2.1: If not find out whether the current character is common in both the strings. Hence `LCS(i,j)=LCS(i-1,j-1)+1`. So copy this character but only once.\n- Case 2.2: This is the case when `LCS(i,j)` has come from either `LCS(i-1,j)` (Case 2.2.1) or `LCS(i,j-1)` (Case 2.2.2). Find out which one it is and copy that character and advance the pointer (Only of the two pointers will be advanced).\n- When you reach `i=0` or `j=0`, then just copy the remaining characters.\n\n```\nclass Solution {\npublic:\n    string shortestCommonSupersequence(string str1, string str2) {\n        int n1=str1.length(), n2=str2.length();\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1,0));\n        for (int i=1; i<=n1; i++)\n        {\n            for (int j=1; j<=n2; j++)\n            {\n                int a = dp[i-1][j];\n                int b = dp[i][j-1];\n                int c = dp[i-1][j-1];\n                if (str1[i-1]==str2[j-1]) c++;\n                dp[i][j] = max({a,b,c});\n            }\n        }\n        string res;\n        // cout << \"LCS\" << dp[n1][n2] << endl;\n        int i=n1, j=n2;\n        while (i>0 && j > 0)\n        {\n            if (dp[i][j]==dp[i-1][j-1])\n            {\n                // cout << \"case1\" << endl;\n                res += str1[i-1];\n                res += str2[j-1];\n                --i;--j;\n            }\n            else\n            {\n                if (str1[i-1]==str2[j-1])\n                {\n                    // cout << \"case 2.1\" << endl;\n                    res += str1[i-1];\n                    --i; --j;\n                }\n                else\n                {\n                    if (dp[i-1][j]==dp[i][j])\n                    {\n                        // cout << \"case 2.2.1\" << endl;\n                        res += str1[i-1];\n                        --i;\n                    }\n                    else if(dp[i][j-1]==dp[i][j])\n                    {\n                        // cout << \"case 2.2.2\" << endl;\n                        res += str2[j-1];\n                        --j;\n                    }\n                }\n            }\n        }\n        while(i>0)\n        {\n            res += str1[i-1];\n            --i;\n        }\n        while(j>0)\n        {\n            res += str2[j-1];\n            --j;\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\nAnother variation of this problem can to find the LCS substring. To solve this, only case 2.2.1 will count.","creationDate":1664287683}},"acRate":58.03125077465895,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"1092","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"shortest-common-supersequence","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>Given two strings <code>str1</code> and <code>str2</code>, return <em>the shortest string that has both </em><code>str1</code><em> and </em><code>str2</code><em> as <strong>subsequences</strong></em>. If there are multiple valid strings, return <strong>any</strong> of them.</p>\n\n<p>A string <code>s</code> is a <strong>subsequence</strong> of string <code>t</code> if deleting some number of characters from <code>t</code> (possibly <code>0</code>) results in the string <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> str1 = &quot;abac&quot;, str2 = &quot;cab&quot;\n<strong>Output:</strong> &quot;cabac&quot;\n<strong>Explanation:</strong> \nstr1 = &quot;abac&quot; is a subsequence of &quot;cabac&quot; because we can delete the first &quot;c&quot;.\nstr2 = &quot;cab&quot; is a subsequence of &quot;cabac&quot; because we can delete the last &quot;ac&quot;.\nThe answer provided is the shortest such string that satisfies these properties.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> str1 = &quot;aaaaaaaa&quot;, str2 = &quot;aaaaaaaa&quot;\n<strong>Output:</strong> &quot;aaaaaaaa&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li>\n\t<li><code>str1</code> and <code>str2</code> consist of lowercase English letters.</li>\n</ul>\n"},{"id":"2630532","title":"Two Sum II - Input Array Is Sorted","url":"/discuss/topic/2630532/three-solutions","questionTitle":"Two Sum II - Input Array Is Sorted","post":{"creationDate":1664280310},"post_data":{"id":2630532,"title":"Three solutions","solutionTags":[],"post":{"id":4254452,"content":"HashSet:\n```\nvector<int> twoSum(vector<int>& numbers, int target) \n{\n\tunordered_map<int,int> comps;\n\tfor (int i=0; i<numbers.size(); i++)\n\t{\n\t\tif (comps.count(numbers[i])) return {comps[numbers[i]]+1,i+1};\n\t\tcomps[target-numbers[i]] = i;\n\t}\n\treturn {};\n}\n```\n\nLinear search using two pointers:\n```\nvector<int> twoSum(vector<int>& numbers, int target) \n    {\n        int lo=0, hi=numbers.size()-1;\n        while (lo<hi)\n        {\n            int curr = numbers[lo]+numbers[hi];\n            if (curr==target) return {lo+1,hi+1};\n            else if (curr<target) lo++;\n            else hi--;\n        }\n        return {};\n    }\n```\n\nLinear traversal + Binary search\n```\nvector<int> twoSum(vector<int>& numbers, int target) \n    {\n        for (int i=0; i<numbers.size(); i++)\n        {\n            if (i>0 && numbers[i]==numbers[i-1]) continue;\n            int tmp = target-numbers[i], lo=i+1, hi=numbers.size()-1;\n            while (lo<=hi)\n            {\n                int mid = lo + (hi-lo)/2;\n                if (numbers[mid]==tmp) return {i+1,mid+1};\n                else if (numbers[mid]<tmp) lo=mid+1;\n                else hi=mid-1;\n            }\n        }\n        return {};\n    }\n```","creationDate":1664280310}},"acRate":60.040481614454876,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"167","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"two-sum-ii-input-array-is-sorted","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code>.</p>\n\n<p>Return<em> the indices of the two numbers, </em><code>index<sub>1</sub></code><em> and </em><code>index<sub>2</sub></code><em>, <strong>added by one</strong> as an integer array </em><code>[index<sub>1</sub>, index<sub>2</sub>]</code><em> of length 2.</em></p>\n\n<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>\n\n<p>Your solution must use only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,<u>7</u>,11,15], target = 9\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,3,<u>4</u>], target = 6\n<strong>Output:</strong> [1,3]\n<strong>Explanation:</strong> The sum of 2 and 4 is 6. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>-1</u>,<u>0</u>], target = -1\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of -1 and 0 is -1. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> is sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li>The tests are generated such that there is <strong>exactly one solution</strong>.</li>\n</ul>\n"},{"id":"2630000","title":"Push Dominoes","url":"/discuss/topic/2630000/nearest-domino-on-each-side","questionTitle":"Push Dominoes","post":{"creationDate":1664269931},"post_data":{"id":2630000,"title":"Nearest domino on each side","solutionTags":[{"name":"C++"}],"post":{"id":4253778,"content":"Consider example\n```\n\".L.R...LR..L..\"\n```\nNow any domino which is pushed at t = 0 will remain as it is and we only need to worry about the standing ones (dots).\nNow a domino falls towards right if the nearest non-dot domino in the left side is pushed rightwards. (Situation A). This means the pattern `R....`\nAnd a domino falls towards left if the nearest non-dot domino in the right side is pushed leftwards. (Situation B). This means the pattern `...L`\n\n**How do we do this?**\nCreate a data structure `nearest_left` which denotes for any dot, the nearest non-dot character in its left side along with the distance from itself.\n```\n0: NULL\n2: (L,1)\n4: (R,1)\n5: (R,2)\n6: (R,3)\n9: (R,1)\n10: (R,2)\n12: (L,1)\n13: (L,2)\n```\nSimilarly we have `nearest_right`.\n```\n0: (L,1)\n2: (R,1)\n4: (L,3)\n5: (L,2)\n6: (L,1)\n9: (L,2)\n10: (L,1)\n12: NULL\n13: NULL\n```\n\nNow situation A means `nearest_left` for that dot is a `R` and situation B means `nearest_right` for that dot is a `L`.\n\nNow for any dot we can have:\n- Neither A nor B ==> Remains standing\n- A only ==> falls towards right\n-  B only ==> falls toward left\n- Both A and B. In this case the direction of fall is decided by the nearer of the two. Remain standing if distances same.\n\nFor our example: \n```\n0: B only\n2: Neither A nor B\n4: Both A and B, A wins\n5: Both A and B, Tie.\n6: Both A and B, B wins\n9: Both A and B, A wins\n10: Both A and B, B wins\n12: Neither A nor B\n13: Neither A nor B\n```\n\nThis gives us the answer:\n```\n\"LL.RR.LLRRLL..\"\n```\n\n\n\nNow let us implement this logic\n```\nclass Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        int n = dominoes.length();\n        vector<pair<int,pair<char,int>>> nearest_left, nearest_right;\n        int left_idx=-1;\n        char left_ch=\"X\";\n        for (int i=0; i<n; i++)\n        {\n            if (dominoes[i]!=\".\")\n            {\n                left_idx = i;\n                left_ch = dominoes[i];\n            }\n            if (dominoes[i]==\".\")\n                nearest_left.push_back({i,{left_ch,i-left_idx}});\n        }\n        int right_idx=n;\n        char right_ch=\"X\";\n        for (int i=n-1; i>=0; i--)\n        {\n            if (dominoes[i]!=\".\")\n            {\n                right_idx = i;\n                right_ch = dominoes[i];\n            }\n            if (dominoes[i]==\".\")\n                nearest_right.push_back({i,{right_ch,right_idx-i}});\n        }\n        reverse(nearest_right.begin(),nearest_right.end());\n        for (int i=0; i<nearest_left.size(); i++)\n        {\n            auto nl = nearest_left[i], nr = nearest_right[i];\n            int dom_idx = nl.first; // this wil be same as nr.first\n            auto nls = nl.second, nrs = nr.second;\n            if (nls.first==\"R\" && nrs.first==\"L\")\n            {\n                if (nls.second<nrs.second) dominoes[dom_idx] = \"R\";\n                if (nrs.second<nls.second) dominoes[dom_idx] = \"L\";\n                continue;\n            }\n            if (nls.first==\"R\")\n            {\n                dominoes[dom_idx] = \"R\";\n                continue;\n            }    \n            if (nrs.first==\"L\") \n            {\n                dominoes[dom_idx] = \"L\";\n                continue;\n            }\n        }\n        return dominoes;\n    }\n};\n```","creationDate":1664269931}},"acRate":56.964898227452906,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"838","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"push-dominoes","topicTags":[{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>There are <code>n</code> dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.</p>\n\n<p>After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.</p>\n\n<p>When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.</p>\n\n<p>For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.</p>\n\n<p>You are given a string <code>dominoes</code> representing the initial state where:</p>\n\n<ul>\n\t<li><code>dominoes[i] = &#39;L&#39;</code>, if the <code>i<sup>th</sup></code> domino has been pushed to the left,</li>\n\t<li><code>dominoes[i] = &#39;R&#39;</code>, if the <code>i<sup>th</sup></code> domino has been pushed to the right, and</li>\n\t<li><code>dominoes[i] = &#39;.&#39;</code>, if the <code>i<sup>th</sup></code> domino has not been pushed.</li>\n</ul>\n\n<p>Return <em>a string representing the final state</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> dominoes = &quot;RR.L&quot;\n<strong>Output:</strong> &quot;RR.L&quot;\n<strong>Explanation:</strong> The first domino expends no additional force on the second domino.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png\" style=\"height: 196px; width: 512px;\" />\n<pre>\n<strong>Input:</strong> dominoes = &quot;.L.R...LR..L..&quot;\n<strong>Output:</strong> &quot;LL.RR.LLRRLL..&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == dominoes.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>dominoes[i]</code> is either <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, or <code>&#39;.&#39;</code>.</li>\n</ul>\n"},{"id":"2409263","title":"Validate Binary Search Tree","url":"/discuss/topic/2409263/iterative-inorder-c","questionTitle":"Validate Binary Search Tree","post":{"creationDate":1660187537},"post_data":{"id":2409263,"title":"Iterative InOrder C++","solutionTags":[],"post":{"id":3948907,"content":"```\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        stack<TreeNode *> st;\n        TreeNode *prev; prev = NULL;\n        while (root || !st.empty())\n        {\n            while (root)\n            {\n                st.push(root);\n                root = root->left;\n            }\n            root = st.top();\n            st.pop();\n            if (prev && root->val <= prev->val) return false;\n            prev = root;\n            root = root->right;\n        }\n        return true;\n    }\n};\n```\nThe above is the best solution for this as it requires O(1) space. \n\nA simpler O(N) space solution is to just do recursive  inorder traversal, store all elements in array and check that the array is sorted.  But this is not so impressive though it still does the job.\n```\nclass Solution {\npublic:\n    void inOrderTraversal(TreeNode *root, int *arr, int *n){\n        if (root==NULL) return;\n        inOrderTraversal(root->left, arr, n);\n        *(arr+*n) = root->val;\n        *n = *n+1;\n        inOrderTraversal(root->right, arr, n);\n    }\n    bool isSorted(int arr[], int n){\n        for (int i=1; i<n; i++){if (arr[i]<=arr[i-1]) return 0;} return 1; \n    }\n    bool isValidBST(TreeNode* root) {\n        int *arr = new int[10000000];\n        int n=0;\n        inOrderTraversal(root, arr, &n);\n        return isSorted(arr, n);\n    }\n};\n```","creationDate":1660187537}},"acRate":31.923127201643492,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"98","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"validate-binary-search-tree","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Binary Search Tree","id":"VG9waWNUYWdOb2RlOjMw","slug":"binary-search-tree"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>\n\n<p>A <strong>valid BST</strong> is defined as follows:</p>\n\n<ul>\n\t<li>The left <span data-keyword=\"subtree\">subtree</span> of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" />\n<pre>\n<strong>Input:</strong> root = [5,1,4,null,null,3,6]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The root node&#39;s value is 5 but its right child&#39;s value is 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"},{"id":"2317200","title":"Partition List","url":"/discuss/topic/2317200/easy-one-pass-o1-space-solution","questionTitle":"Partition List","post":{"creationDate":1658486331},"post_data":{"id":2317200,"title":"Easy One pass O(1) space solution","solutionTags":[{"name":"C++"}],"post":{"id":3821976,"content":"Basically create two linked lists: one with nodes less than x and another with nodes greater than or equal to x. After that put 2nd LL at the tail of 1st LL. \n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode *curr=head, *head1=new ListNode, *head2=new ListNode;\n        ListNode *curr1 = head1, *curr2=head2;\n        while (curr)\n        {\n            if (curr->val<x)\n            {\n                curr1->next = new ListNode(curr->val);\n                curr1 = curr1->next;\n            }\n            else\n            {\n                curr2->next = new ListNode(curr->val);\n                curr2 = curr2->next;\n            }\n            curr = curr->next;\n        }\n        curr1->next = head2->next;\n        return head1->next;\n    }\n};\n```\n\n```\nTC: O(N)\nSC: O(1)\n```","creationDate":1658486331}},"acRate":51.83705513116248,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"86","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"partition-list","topicTags":[{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes <strong>less than</strong> <code>x</code> come before nodes <strong>greater than or equal</strong> to <code>x</code>.</p>\n\n<p>You should <strong>preserve</strong> the original relative order of the nodes in each of the two partitions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/partition.jpg\" style=\"width: 662px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,4,3,2,5,2], x = 3\n<strong>Output:</strong> [1,2,2,4,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [2,1], x = 2\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 200]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-200 &lt;= x &lt;= 200</code></li>\n</ul>\n"},{"id":"2161426","title":"Non-overlapping Intervals","url":"/discuss/topic/2161426/greedy-cpppython","questionTitle":"Non-overlapping Intervals","post":{"creationDate":1655451772},"post_data":{"id":2161426,"title":"Greedy cpp+python","solutionTags":[],"post":{"id":3606398,"content":"```\nbool mycomp(vector<int>&a, vector<int>&b)\n{\n    return a[1]<b[1];\n}\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) \n    {\n        if (intervals.size()==1) return 0;\n        sort(intervals.begin(), intervals.end(), mycomp);\n        int n=intervals.size(), curr=intervals[0][1], res=0;\n        for (int i=1; i<n; i++)\n        {\n            if (intervals[i][0]>=curr) curr = intervals[i][1];\n            else res ++;\n        }\n        return res;\n    }\n};\n```\n\n```\nclass Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals = sorted(intervals, key=lambda k: k[1])\n        n, res, curr = len(intervals), 0, intervals[0][1]\n        for i in range(1,n):\n            if intervals[i][0]>=curr:\n                curr = intervals[i][1]\n\t\t\telse:\n\t\t\t    res += 1\n        return res\n```","creationDate":1655451772}},"acRate":50.15261011395472,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"435","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"non-overlapping-intervals","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Greedy","id":"VG9waWNUYWdOb2RlOjE3","slug":"greedy"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an array of intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[2,3],[3,4],[1,3]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> [1,3] can be removed and the rest of the intervals are non-overlapping.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[1,2],[1,2]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[2,3]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>-5 * 10<sup>4</sup> &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 5 * 10<sup>4</sup></code></li>\n</ul>\n"},{"id":"2153932","title":"Longest String Chain","url":"/discuss/topic/2153932/very-easy-hashmap-solution-analysis","questionTitle":"Longest String Chain","post":{"creationDate":1655276777},"post_data":{"id":2153932,"title":"Very Easy Hashmap solution + Analysis","solutionTags":[{"name":"C++"}],"post":{"id":3595916,"content":"# Algorithm:\n- Sort words by word length in ascending order\n- Initialize Hashmap H of type `string->int`\n- For each word find subwords (word-1 char) and check if subword is in H. Find the maximum possible value of `H[subword]`  out of all subwords. Call it `ctr`. If there is no subword in H then `ctr=0`\n- `H[word] = ctr+1`\n- Finally answer is the maximum of all values in `H`.\n\n```\nbool complen(string s1, string s2)\n{\n    return s1.length() < s2.length();\n}\n\nclass Solution {\npublic:\n    int longestStrChain(vector<string>& words) {\n        unordered_map<string,int> H;\n        int res=0;\n        sort(words.begin(), words.end(), complen);\n        for (string word: words)\n        {\n            int wn = word.length(), ctr=0;\n            for (int i=0; i<wn; i++)\n            {\n                string sub = string(word.begin(),word.begin()+i) + \n                             string(word.begin()+i+1, word.end());\n                if (H.count(sub)) ctr=max(ctr,H[sub]);\n            }\n            H[word]=ctr+1;\n            res = max(res, H[word]);\n        }\n        return res;\n    }\n};\n```\n```\nTC: O(N*|S| + N*log(N))\nSC: O(N)\n```\nwhere `N=#(words)`, `|S|=max length of word`\n\nReasoning for TC:\n`N*|S|` term comes because for each word we are finding all the subwords\n`N*log(N)` term comes because we are doing a sorting operation in the beginning\n\nReasoning for SC:\nSize of HashMap is N.\n\nPLEASE UPVOTE.","creationDate":1655276777}},"acRate":59.21669608801186,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1048","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"longest-string-chain","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given an array of <code>words</code> where each word consists of lowercase English letters.</p>\n\n<p><code>word<sub>A</sub></code> is a <strong>predecessor</strong> of <code>word<sub>B</sub></code> if and only if we can insert <strong>exactly one</strong> letter anywhere in <code>word<sub>A</sub></code> <strong>without changing the order of the other characters</strong> to make it equal to <code>word<sub>B</sub></code>.</p>\n\n<ul>\n\t<li>For example, <code>&quot;abc&quot;</code> is a <strong>predecessor</strong> of <code>&quot;ab<u>a</u>c&quot;</code>, while <code>&quot;cba&quot;</code> is not a <strong>predecessor</strong> of <code>&quot;bcad&quot;</code>.</li>\n</ul>\n\n<p>A <strong>word chain</strong><em> </em>is a sequence of words <code>[word<sub>1</sub>, word<sub>2</sub>, ..., word<sub>k</sub>]</code> with <code>k &gt;= 1</code>, where <code>word<sub>1</sub></code> is a <strong>predecessor</strong> of <code>word<sub>2</sub></code>, <code>word<sub>2</sub></code> is a <strong>predecessor</strong> of <code>word<sub>3</sub></code>, and so on. A single word is trivially a <strong>word chain</strong> with <code>k == 1</code>.</p>\n\n<p>Return <em>the <strong>length</strong> of the <strong>longest possible word chain</strong> with words chosen from the given list of </em><code>words</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]\n<strong>Output:</strong> 4\n<strong>Explanation</strong>: One of the longest word chains is [&quot;a&quot;,&quot;<u>b</u>a&quot;,&quot;b<u>d</u>a&quot;,&quot;bd<u>c</u>a&quot;].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> All the words can be put in a word chain [&quot;xb&quot;, &quot;xb<u>c</u>&quot;, &quot;<u>c</u>xbc&quot;, &quot;<u>p</u>cxbc&quot;, &quot;pcxbc<u>f</u>&quot;].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abcd&quot;,&quot;dbqca&quot;]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The trivial word chain [&quot;abcd&quot;] is one of the longest word chains.\n[&quot;abcd&quot;,&quot;dbqca&quot;] is not a valid word chain because the ordering of the letters is changed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 16</code></li>\n\t<li><code>words[i]</code> only consists of lowercase English letters.</li>\n</ul>\n"},{"id":"2153759","title":"All Paths From Source to Target","url":"/discuss/topic/2153759/easy-dfs-solution","questionTitle":"All Paths From Source to Target","post":{"creationDate":1655273851},"post_data":{"id":2153759,"title":"Easy DFS solution","solutionTags":[{"name":"C++"}],"post":{"id":3595676,"content":"```\nclass Solution {\npublic:\n    void dfs(vector<vector<int>> graph, int u, int n, vector<int>&path,\n            vector<vector<int>> &paths)\n    {\n        path.push_back(u);\n        if (u==n-1) paths.push_back(path);\n        for (int v: graph[u]) dfs(graph,v,n,path,paths);\n        path.pop_back();\n    }\n    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {\n        int n=graph.size();\n        vector<int>path;\n        vector<vector<int>> paths;\n        dfs(graph,0,n,path,paths);\n        return paths;\n    }\n};\n```","creationDate":1655273851}},"acRate":82.233292227957,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"797","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"all-paths-from-source-to-target","topicTags":[{"name":"Backtracking","id":"VG9waWNUYWdOb2RlOjE0","slug":"backtracking"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Graph","id":"VG9waWNUYWdOb2RlOjI0","slug":"graph"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a directed acyclic graph (<strong>DAG</strong>) of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, find all possible paths from node <code>0</code> to node <code>n - 1</code> and return them in <strong>any order</strong>.</p>\n\n<p>The graph is given as follows: <code>graph[i]</code> is a list of all nodes you can visit from node <code>i</code> (i.e., there is a directed edge from node <code>i</code> to node <code>graph[i][j]</code>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> graph = [[1,2],[3],[3],[]]\n<strong>Output:</strong> [[0,1,3],[0,2,3]]\n<strong>Explanation:</strong> There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg\" style=\"width: 423px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> graph = [[4,3,1],[3,2,4],[3],[4],[]]\n<strong>Output:</strong> [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt; n</code></li>\n\t<li><code>graph[i][j] != i</code> (i.e., there will be no self-loops).</li>\n\t<li>All the elements of <code>graph[i]</code> are <strong>unique</strong>.</li>\n\t<li>The input graph is <strong>guaranteed</strong> to be a <strong>DAG</strong>.</li>\n</ul>\n"},{"id":"2150834","title":"Delete Operation for Two Strings","url":"/discuss/topic/2150834/edit-distance-lcs-dp-solutions","questionTitle":"Delete Operation for Two Strings","post":{"creationDate":1655202594},"post_data":{"id":2150834,"title":"Edit Distance + LCS DP solutions","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":3591450,"content":"# Solution using Edit Distance Algorithm\n```\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n1=word1.length(), n2=word2.length();\n        vector<vector<int>> dp (n1+1, vector<int>(n2+1,0));\n        for (int i=1; i<=n1; i++) dp[i][0]=i;\n        for (int j=1; j<=n2; j++) dp[0][j]=j;\n        for (int i=1; i<=n1; i++)\n        {\n            for (int j=1; j<=n2; j++)\n            {\n                int a = dp[i-1][j]+1;\n                int b = dp[i][j-1]+1;\n                int c = dp[i-1][j-1];\n                if (word1[i-1]!=word2[j-1]) c+=2;\n                dp[i][j]=min({a,b,c});\n            }\n        }\n        return dp[n1][n2];\n    }\n};\n```\n\nThe only change we made from edit distance algorithm is that we replaced `c++` to `c+=2` inside the `if` condition. This is because now we are not allowed to do substitution but rather we should be deleting on both sides. Everything else is exactly the same.\nReference:https://leetcode.com/problems/edit-distance/\n\n# Solution using LCS algorithm\n## DP using recursion with memoization\n```\nclass Solution {\npublic:\n    int getLCS(string word1, string word2, int n1, int n2, int i, int j, \n               vector<vector<int>>&L)\n    {\n        if (L[i][j]<0)\n        {\n            if (i==n1 || j==n2) L[i][j]=0;\n            else if (word1[i]==word2[j]) \n                L[i][j] = 1 + getLCS(word1,word2,n1,n2,i+1,j+1,L);\n            else L[i][j] = max(getLCS(word1,word2,n1,n2,i+1,j,L), \n                               getLCS(word1,word2,n1,n2,i,j+1,L)\n                              );\n        }\n        return L[i][j];\n    }\n    int minDistance(string word1, string word2) {\n        int n1=word1.length(), n2=word2.length();\n        vector<vector<int>> L(n1+1, vector<int>(n2+1,-1));\n        int lcs = getLCS(word1, word2, n1, n2, 0, 0, L);\n        return n1+n2-2*lcs;\n    }\n};\n```\n## DP using iteration\n```\nclass Solution {\npublic:\n    int getLCS(string word1, string word2, int n1, int n2)\n    {\n        vector<vector<int>> L(n1+1, vector<int>(n2+1,-1));\n        for (int i=n1; i>=0; i--)\n        {\n            for (int j=n2; j>=0; j--)\n            {\n                if (i==n1 || j==n2) L[i][j]=0;\n                else if (word1[i]==word2[j]) L[i][j] = 1+L[i+1][j+1];\n                else L[i][j] = max(L[i+1][j], L[i][j+1]);\n            }\n        }\n        return L[0][0];\n    }\n    int minDistance(string word1, string word2) {\n        int n1=word1.length(), n2=word2.length();\n        int lcs = getLCS(word1, word2, n1, n2);\n        return n1+n2-2*lcs;\n    }\n};\n```","creationDate":1655202594}},"acRate":59.665915802569046,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"583","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"delete-operation-for-two-strings","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of <strong>steps</strong> required to make</em> <code>word1</code> <em>and</em> <code>word2</code> <em>the same</em>.</p>\n\n<p>In one <strong>step</strong>, you can delete exactly one character in either string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;sea&quot;, word2 = &quot;eat&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code> and <code>word2</code> consist of only lowercase English letters.</li>\n</ul>\n"},{"id":"2108684","title":"Next Greater Element II","url":"/discuss/topic/2108684/nge-using-stack-on-repeated-array","questionTitle":"Next Greater Element II","post":{"creationDate":1654327063},"post_data":{"id":2108684,"title":"NGE using stack on repeated array","solutionTags":[{"name":"C++"},{"name":"Stack"},{"name":"Monotonic Stack"}],"post":{"id":3532471,"content":"The solution is based on NGE. Except that we repeat the input array twice and return the first n elements as the answer.\n\nFirst let us solve an easier prolem without the circular thing.\nNGE problem for an array\n----------------\n\nConsider you have an array. The problem is that for each element in the array find the first element to the right of that element which is larger than it. If there is none output -1.\nFor example , `A=[2,3,1,4]`. Then output is `{2:3,  3:4,  1:-1,  4:-1}`\nHOW DO YOU SOLVE THIS?\nAnswer is to use a monotonically decreasing stack.  Here is the general strategy\n1. Start with appending `A[0]` to the stack.\n2. As you traverse the array, if you see that `A[i] <= stack top`, push it to the stack making it the new stack top. Thus you will notice that this results in a monotonically decreasing stack.\n2. If ever `A[i]` is greater than the stack top, it means you have found NGE for the number which was at the top of the stack (also the smallest). So pop it and add this pair (`stack top` --> `A[i]`) to your answer. Now check for the new stack top. Continue this till this `A[i]` is the NGE for the stack members.\n3. After you are done, only those which are greater or equal to `A[i]` will remain in the stack. Now push `A[i]` to the stack as well.\n4. At the end, NGE for all elements which remained in the stack is -1.\n```\nvector<int> nextGreaterElements(vector<int> nums) {\n\tint n=nums.size();\n\tstack<pair<int,int>> S;\n\tvector<int> res (n,-1);\n\t\n\tfor (int i=0; i<n; i++)\n\t{\n\t\twhile (!S.empty() && nums[i] > S.top().first)\n\t\t{\n\t\t\tres[S.top().second] = nums[i];\n\t\t\tS.pop();\n\t\t}\n\t\tS.push({nums[i],i});\n\t}\n\treturn res;\n}\n```\n\n---\n\n\nNow for the circular array we just repeat the array twice and run the exact same algorithm.\n\n```\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n=nums.size();\n        for (int i=0; i<n; i++) nums.push_back(nums[i]);\n\n        stack<pair<int,int>> S;\n        vector<int> res (2*n,-1);\n        \n        for (int i=0; i<2*n; i++)\n        {\n            while (!S.empty() && nums[i] > S.top().first)\n            {\n                res[S.top().second] = nums[i];\n                S.pop();\n            }\n            S.push({nums[i],i});\n        }\n        return vector<int>(res.begin(), res.begin()+n);\n    }\n};\n```\n","creationDate":1654327063}},"acRate":63.176389140647004,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"503","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"next-greater-element-ii","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Monotonic Stack","id":"VG9waWNUYWdOb2RlOjYxMDU0","slug":"monotonic-stack"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a circular integer array <code>nums</code> (i.e., the next element of <code>nums[nums.length - 1]</code> is <code>nums[0]</code>), return <em>the <strong>next greater number</strong> for every element in</em> <code>nums</code>.</p>\n\n<p>The <strong>next greater number</strong> of a number <code>x</code> is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn&#39;t exist, return <code>-1</code> for this number.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1]\n<strong>Output:</strong> [2,-1,2]\nExplanation: The first 1&#39;s next greater number is 2; \nThe number 2 can&#39;t find next greater number. \nThe second 1&#39;s next greater number needs to search circularly, which is also 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,3]\n<strong>Output:</strong> [2,3,4,-1,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"},{"id":"2100813","title":"Next Greater Element I","url":"/discuss/topic/2100813/stack-hashmap-on1n2-solution","questionTitle":"Next Greater Element I","post":{"creationDate":1654146196},"post_data":{"id":2100813,"title":"Stack + HashMap O(N1+N2) solution","solutionTags":[{"name":"C++"},{"name":"Stack"}],"post":{"id":3521427,"content":"Firstly it is not an easy problem by any stretch. You need to know about both monotonic stacks and hashmaps and use them in a correct way.\nHere is how I did it:\n1. Forget about `nums1`. Solve the NGE (Next Greater Element) problem for `nums2` array and store results in a hashmap\n2. Traverse through `nums1` and append result for each element from the hashmap (they will all be present because it is a subset of `nums2`) into an array and finally return this array.\n\nThe first part is not obvious just like that. So I will explain\n\n---\nNGE problem for an array\n----------------\n\nConsider you have an array. The problem is that for each element in the array find the first element to the right of that element which is larger than it. If there is none output -1.\nFor example , `A=[2,3,1,4]`. Then output is `{2:3,  3:4,  1:-1,  4:-1}`\nHOW DO YOU SOLVE THIS?\nAnswer is to use a monotonically decreasing stack.  Here is the general strategy\n1. Start with appending `A[0]` to the stack.\n2. As you traverse the array, if you see that `A[i] <= stack top`, push it to the stack making it the new stack top. Thus you will notice that this results in a monotonically decreasing stack.\n2. If ever `A[i]` is greater than the stack top, it means you have found NGE for the number which was at the top of the stack (also the smallest). So pop it and add this pair (`stack top` --> `A[i]`) to your answer. Now check for the new stack top. Continue this till this `A[i]` is the NGE for the stack members.\n3. After you are done, only those which are greater or equal to `A[i]` will remain in the stack. Now push `A[i]` to the stack as well.\n4. At the end, NGE for all elements which remained in the stack is -1.\n\n---\n\nIf you get this part, then the other part of question (checking for each item in `nums1`) is very easy. Just check the hashmap you have obtained.\n\nMy code has the exact same logic I have given above.\n```\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        unordered_map<int,int> H;\n        stack<int>S;\n        int n1=nums1.size(), n2=nums2.size();\n        for (int i=0; i<n2; i++)\n        {\n            while (!S.empty() && nums2[i]>S.top())\n            {\n                H[S.top()] = nums2[i];\n                S.pop();\n            }\n            S.push(nums2[i]);\n        }\n        while (!S.empty())\n        {\n            H[S.top()]=-1;\n            S.pop();\n        }\n        // We have solved NGE problem for nums2. Now we do 2nd part\n        vector<int>res;\n        for (int num: nums1) res.push_back(H[num]);\n        return res;\n    }\n};\n```\n```\nTC: O(N1+N2)\nSC: O(N2)\n```","creationDate":1654146196}},"acRate":71.44570142275836,"difficulty":"Easy","freqBar":null,"frontendQuestionId":"496","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"next-greater-element-i","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Monotonic Stack","id":"VG9waWNUYWdOb2RlOjYxMDU0","slug":"monotonic-stack"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>The <strong>next greater element</strong> of some element <code>x</code> in an array is the <strong>first greater</strong> element that is <strong>to the right</strong> of <code>x</code> in the same array.</p>\n\n<p>You are given two <strong>distinct 0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, where <code>nums1</code> is a subset of <code>nums2</code>.</p>\n\n<p>For each <code>0 &lt;= i &lt; nums1.length</code>, find the index <code>j</code> such that <code>nums1[i] == nums2[j]</code> and determine the <strong>next greater element</strong> of <code>nums2[j]</code> in <code>nums2</code>. If there is no next greater element, then the answer for this query is <code>-1</code>.</p>\n\n<p>Return <em>an array </em><code>ans</code><em> of length </em><code>nums1.length</code><em> such that </em><code>ans[i]</code><em> is the <strong>next greater element</strong> as described above.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,1,2], nums2 = [1,3,4,2]\n<strong>Output:</strong> [-1,3,-1]\n<strong>Explanation:</strong> The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,<u>4</u>,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [<u>1</u>,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,<u>2</u>]. There is no next greater element, so the answer is -1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [2,4], nums2 = [1,2,3,4]\n<strong>Output:</strong> [3,-1]\n<strong>Explanation:</strong> The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,<u>2</u>,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,<u>4</u>]. There is no next greater element, so the answer is -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All integers in <code>nums1</code> and <code>nums2</code> are <strong>unique</strong>.</li>\n\t<li>All the integers of <code>nums1</code> also appear in <code>nums2</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you find an <code>O(nums1.length + nums2.length)</code> solution?"},{"id":"2041331","title":"Deepest Leaves Sum","url":"/discuss/topic/2041331/easy-dfs-solution","questionTitle":"Deepest Leaves Sum","post":{"creationDate":1652609930},"post_data":{"id":2041331,"title":"Easy DFS solution","solutionTags":[],"post":{"id":3436641,"content":"```\nclass Solution {\npublic:\n    int height(TreeNode *root)\n    {\n        if (!root) return 0;\n        return 1+max(height(root->left),height(root->right));\n    }\n    void util(TreeNode *root, int h, int &res)\n    {\n        if (!root) return;\n        if (h==0) res+=root->val;\n        util(root->left, h-1, res);\n        util(root->right, h-1, res);\n    }\n    int deepestLeavesSum(TreeNode* root) {\n        int H = height(root);\n        int res=0;\n        util(root, H-1, res);\n        return res;\n    }\n};\n```","creationDate":1652609930}},"acRate":86.71420246583774,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1302","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"deepest-leaves-sum","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"Given the <code>root</code> of a binary tree, return <em>the sum of values of its deepest leaves</em>.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png\" style=\"width: 273px; height: 265px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\n<strong>Output:</strong> 15\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n<strong>Output:</strong> 19\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"},{"id":"2041034","title":"Network Delay Time","url":"/discuss/topic/2041034/dijkstra-method","questionTitle":"Network Delay Time","post":{"creationDate":1652603793},"post_data":{"id":2041034,"title":"Dijkstra method","solutionTags":[],"post":{"id":3436213,"content":"**Dijsktra\"s Algorithm**: Maintain visited nodes in an array Q. Also maintain the distances from source in an array `dist`. Initially `Q = {source}` and `dist={INT_MAX,INT_MAX,INT_MAX...}`  and `dist[source]=0]`. Then while Q is not empty you do the following\n- Find which node in Q has the minimum value in `dist` array. Call it `u`.\n- For all nodes adjacent to `u`, check if `dist` value can be updated for them. If you update `dist` for any node `v`, then also add `v` to `Q`.\n\nThe standard implementation uses a min-heap.\n```\nclass Solution {\npublic:\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        vector<vector<pair<int,int>>> graph (n);\n        for (auto item: times)\n        {\n            int u=item[0]-1, v=item[1]-1, w=item[2];\n            graph[u].push_back({v,w});\n        }\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> Q;\n        Q.push({0, k-1});\n        vector<int> dist(n, INT_MAX);\n        dist[k-1] = 0;\n        while (!Q.empty())\n        {\n            auto top = Q.top();\n            Q.pop();\n            int u=top.second, d=top.first;\n            for (auto edge: graph[u])\n            {\n                int v=edge.first, w=edge.second;\n                if (d+w < dist[v])\n                {\n                    dist[v] = d+w;\n                    Q.push({d+w, v});\n                }\n            }\n        }\n        int res = *max_element(dist.begin(), dist.end());\n        return (res==INT_MAX)?-1:res;\n    }\n};\n```\nIf you dont know about heap, the same logic can be implemented without heap as well with some additional cost but still gets an AC.\n```\nclass Solution {\npublic:\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        vector<vector<pair<int,int>>> graph(n);\n        for (auto edge: times)\n        {\n            int u=edge[0]-1, v=edge[1]-1, w=edge[2];\n            graph[u].push_back({v,w});\n        }\n        vector<int> Q {k-1};\n        vector<int> dist(n, INT_MAX);\n        dist[k-1] = 0;\n        while (Q.size()>0)\n        {\n            int u, minStart=INT_MAX;\n            for (int node: Q)\n            {\n                if (dist[node]<minStart)\n                {\n                    minStart=dist[node];\n                    u = node;\n                }\n            }\n            // u has the min distance out of all nodes in Q\n            Q.erase(find(Q.begin(),Q.end(),u));\n            for (auto edge: graph[u])\n            {\n                int v=edge.first, w=edge.second;\n                if (dist[u]+w < dist[v])\n                {\n                    dist[v] = dist[u]+w;\n                    Q.push_back(v);\n                }\n            }\n        }\n        int res = *max_element(dist.begin(),dist.end());\n        return (res==INT_MAX)?-1:res;\n    }\n};\n```","creationDate":1652603793}},"acRate":51.74622630541773,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"743","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"network-delay-time","topicTags":[{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Graph","id":"VG9waWNUYWdOb2RlOjI0","slug":"graph"},{"name":"Heap (Priority Queue)","id":"VG9waWNUYWdOb2RlOjYxMDUw","slug":"heap-priority-queue"},{"name":"Shortest Path","id":"VG9waWNUYWdOb2RlOjYxMDc2","slug":"shortest-path"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given a network of <code>n</code> nodes, labeled from <code>1</code> to <code>n</code>. You are also given <code>times</code>, a list of travel times as directed edges <code>times[i] = (u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>)</code>, where <code>u<sub>i</sub></code> is the source node, <code>v<sub>i</sub></code> is the target node, and <code>w<sub>i</sub></code> is the time it takes for a signal to travel from source to target.</p>\n\n<p>We will send a signal from a given node <code>k</code>. Return <em>the <strong>minimum</strong> time it takes for all the</em> <code>n</code> <em>nodes to receive the signal</em>. If it is impossible for all the <code>n</code> nodes to receive the signal, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png\" style=\"width: 217px; height: 239px;\" />\n<pre>\n<strong>Input:</strong> times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> times = [[1,2,1]], n = 2, k = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> times = [[1,2,1]], n = 2, k = 2\n<strong>Output:</strong> -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= times.length &lt;= 6000</code></li>\n\t<li><code>times[i].length == 3</code></li>\n\t<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li><code>0 &lt;= w<sub>i</sub> &lt;= 100</code></li>\n\t<li>All the pairs <code>(u<sub>i</sub>, v<sub>i</sub>)</code> are <strong>unique</strong>. (i.e., no multiple edges.)</li>\n</ul>\n"},{"id":"2034170","title":"Populating Next Right Pointers in Each Node II","url":"/discuss/topic/2034170/connections-using-level-wise-traversal-dfs","questionTitle":"Populating Next Right Pointers in Each Node II","post":{"creationDate":1652427190},"post_data":{"id":2034170,"title":"Connections using Level Wise Traversal DFS","solutionTags":[{"name":"C++"}],"post":{"id":3426060,"content":"If you do not know [level order traversal problem](https://leetcode.com/problems/binary-tree-level-order-traversal/), refere here:\n[Level Order Traversal - Two DFS solutions](https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/2034163/Two-DFS-solutions)\n<br>\nNow we can immediately think of a solution:\nInstead of storing the keys, sotre the node pointers and then make required connections.\n```\nclass Solution {\npublic:\n    void dfs(Node *root, vector<vector<Node *>> &lvn, int level)\n    {\n        if (!root) return;\n        if (level==lvn.size()) lvn.push_back({});\n        lvn[level].push_back(root);\n        dfs(root->left, lvn, level+1);\n        dfs(root->right, lvn, level+1);\n    }\n    Node* connect(Node* root) {\n        vector<vector<Node *>> levelWiseNodes;\n        dfs(root, levelWiseNodes, 0);\n        for (int i=0; i<levelWiseNodes.size(); i++)\n        {\n            if (levelWiseNodes[i].size()<2) continue;\n            for (int j=0; j<=levelWiseNodes[i].size()-2; j++)\n            {\n               levelWiseNodes[i][j]->next = levelWiseNodes[i][j+1];\n            }\n        }\n        return root;\n    }\n};\n```\n","creationDate":1652427190}},"acRate":50.121271157077196,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"117","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"populating-next-right-pointers-in-each-node-ii","topicTags":[{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a binary tree</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n</pre>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/15/117_sample.png\" style=\"width: 500px; height: 171px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,null,7]\n<strong>Output:</strong> [1,#,2,3,#,4,5,7,#]\n<strong>Explanation: </strong>Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 6000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong></p>\n\n<ul>\n\t<li>You may only use constant extra space.</li>\n\t<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n"},{"id":"2034163","title":"Binary Tree Level Order Traversal","url":"/discuss/topic/2034163/three-methods-two-dfs-one-bfs","questionTitle":"Binary Tree Level Order Traversal","post":{"creationDate":1652426983},"post_data":{"id":2034163,"title":"Three methods - Two DFS + One BFS","solutionTags":[{"name":"C++"}],"post":{"id":3426050,"content":"Method 1 is to get height of tree, then for each number less than tree height, traverse the tree and get all keys at that level using DFS.\n```\nclass Solution {\npublic:\n    int height(TreeNode *root)\n    {\n        if (!root) return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n    void dfs(TreeNode *root, vector<int>&levelVals, int h)\n    {\n        if (!root || h<0) return;\n        if (h==0) levelVals.push_back(root->val);\n        dfs(root->left, levelVals, h-1);\n        dfs(root->right, levelVals, h-1);\n    }\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        int H = height(root);\n        vector<vector<int>> res;\n        for (int h=0; h<H; h++)\n        {\n            vector<int> levelVals;\n            dfs(root, levelVals, h);\n            res.push_back(levelVals);\n        }\n        return res;\n    }\n};\n```\nMethod 2 is to do DFS without getting height. Use the logic that if while going down from top, we are at same level as the size of keys array we append a new array and store keys of lower level in new array. \n```\nclass Solution {\npublic:\n    void dfs(TreeNode *root, vector<vector<int>>&res, int level)\n    {\n        if (!root) return;\n        if (res.size()==level) res.push_back({});\n        res[level].push_back(root->val);\n        dfs(root->left, res, level+1);\n        dfs(root->right, res, level+1);\n    }\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        dfs(root, res, 0);\n        return res;\n    }\n};\n```\n\nBFS Solution:\nHere we will need a queue. The children of the level nodes are stored in queue. Then one by one we go over the queue.\n```\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) \n    {\n        if (!root) return {};\n        vector<vector<int>>res;\n        queue<TreeNode *> Q;\n        Q.push(root);\n        while (!Q.empty())\n        {\n            vector<int> levelVals;\n\t\t\t// We cant go from 0 to Q.size() because Q.size() changes inside for loop\n\t\t\t// Hence we initialize i once using Q.size() and iterate in reverse.\n            for (int i=Q.size()-1; i>=0; i--)\n            {\n                TreeNode *node = Q.front();\n                Q.pop();\n                levelVals.push_back(node->val);\n                if (node->left) Q.push(node->left);\n                if (node->right) Q.push(node->right);\n            }\n            res.push_back(levelVals);\n        }\n        return res;\n    }\n};\n```","creationDate":1652426983}},"acRate":64.05825301409665,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"102","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"binary-tree-level-order-traversal","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[9,20],[15,7]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n"},{"id":"2030957","title":"Count Sorted Vowel Strings","url":"/discuss/topic/2030957/dp-solution","questionTitle":"Count Sorted Vowel Strings","post":{"creationDate":1652334132},"post_data":{"id":2030957,"title":"DP solution","solutionTags":[{"name":"C++"}],"post":{"id":3421489,"content":"```\nclass Solution {\npublic:\n    int countVowelStrings(int n) {\n        int a=1, b=1, c=1, d=1, e=1;\n        for (int i=2; i<=n; i++)\n        {\n            d+=e;\n            c+=d;\n            b+=c;\n            a+=b;\n        }\n        return a+b+c+d+e;\n    }\n};\n```","creationDate":1652334132}},"acRate":77.32694964749706,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1641","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"count-sorted-vowel-strings","topicTags":[{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Combinatorics","id":"VG9waWNUYWdOb2RlOjYxMDU2","slug":"combinatorics"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer <code>n</code>, return <em>the number of strings of length </em><code>n</code><em> that consist only of vowels (</em><code>a</code><em>, </em><code>e</code><em>, </em><code>i</code><em>, </em><code>o</code><em>, </em><code>u</code><em>) and are <strong>lexicographically sorted</strong>.</em></p>\n\n<p>A string <code>s</code> is <strong>lexicographically sorted</strong> if for all valid <code>i</code>, <code>s[i]</code> is the same as or comes before <code>s[i+1]</code> in the alphabet.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The 5 sorted strings that consist of vowels only are <code>[&quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;].</code>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> The 15 sorted strings that consist of vowels only are\n[&quot;aa&quot;,&quot;ae&quot;,&quot;ai&quot;,&quot;ao&quot;,&quot;au&quot;,&quot;ee&quot;,&quot;ei&quot;,&quot;eo&quot;,&quot;eu&quot;,&quot;ii&quot;,&quot;io&quot;,&quot;iu&quot;,&quot;oo&quot;,&quot;ou&quot;,&quot;uu&quot;].\nNote that &quot;ea&quot; is not a valid string since &#39;e&#39; comes after &#39;a&#39; in the alphabet.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 33\n<strong>Output:</strong> 66045\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code>&nbsp;</li>\n</ul>\n"},{"id":"2025591","title":"Linked List Cycle II","url":"/discuss/topic/2025591/floyds-tortoise-and-hare-algorithm","questionTitle":"Linked List Cycle II","post":{"creationDate":1652183016},"post_data":{"id":2025591,"title":"Floyd's Tortoise and Hare Algorithm","solutionTags":[],"post":{"id":3413908,"content":"Consider a situation like this.\n![](https://i.imgur.com/jGtHiGq.png)\n\nConsider two pointers `tortoise` and `hare` which move at 1x and 2x respectively.\nWe know that `d(hare)=2d(tortoise)`. So, when they meet we have:\n```\nF+nC+a = 2(F+a)\n```\nLHS is for hare and RHS is for tortoise.\nThen we make the tortoise start again from the beginning and hare from the meeting position itself but both at 1x. Then they meet exactly at the cycle start point because after F steps, tortoise is at `F` and hare is at `F+a+F`. But we know that `F+a=nC` from earlier equation. Hence hare is also at `F` and this node is the answer.\n\n```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *tortoise=head, *hare=head;\n        while(1)\n        {\n            if (!hare||!hare->next) return NULL;\n            tortoise = tortoise->next;\n            hare = hare->next->next;\n            if (tortoise==hare) break;\n        }\n        tortoise = head;\n        while (tortoise!=hare)\n        {\n            tortoise = tortoise->next;\n            hare = hare->next;\n        }\n        return hare;\n    }\n};\n```\n\nThere is obviously also an easier O(N) space HashSet solution that gives you an AC but I think the Floyd\"s algo solution is more useful in real life interview. For the sake of completion here is the HashSet solution:\n```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_set<ListNode *> S;\n        while (head)\n        {\n            if (S.count(head)) return head;\n            S.insert(head);\n            head = head->next;\n        }\n        return NULL;        \n    }\n};\n```\n\n","creationDate":1652183016}},"acRate":47.34921398780879,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"142","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"linked-list-cycle-ii","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return </em><code>null</code>.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>\n\n<p><strong>Do not modify</strong> the linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 145px; width: 450px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> tail connects to node index 1\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 105px; width: 201px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> tail connects to node index 0\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 65px; width: 65px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> no cycle\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n"},{"id":"2024027","title":"Combination Sum III","url":"/discuss/topic/2024027/dfs-and-all-combinations","questionTitle":"Combination Sum III","post":{"creationDate":1652144091},"post_data":{"id":2024027,"title":"DFS and All combinations","solutionTags":[],"post":{"id":3411719,"content":"We can do DFS and check for current sum. If meets the condition add to result.\nC++ solution:\n```\nclass Solution {\npublic:\n    void combn(int curr, int target, int count,  vector<vector<int>> &res, vector<int> &v)\n    {\n        if (count<0 || target<0) return;\n        if (count==0 && target==0)\n        {\n            res.push_back(v);\n            return;\n        }\n        for (int i=curr; i<=9; i++)\n        {\n            v.push_back(i);\n            combn(i+1, target-i, count-1, res, v);\n            v.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum3(int k, int n) {\n        vector<vector<int>> res;\n        vector<int>v;\n        combn(1,n,k,res,v);\n        return res;\n    }\n};\n```\nWe can also do all combinations and get an AC:\nPython solution:\n```\nclass Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        res = []\n        for cb in combinations(range(1,10),k):\n            if sum(cb)==n:\n                res.append(list(cb))\n        return res\n```","creationDate":1652144091}},"acRate":67.50739053316175,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"216","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"combination-sum-iii","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Backtracking","id":"VG9waWNUYWdOb2RlOjE0","slug":"backtracking"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>\n\n<ul>\n\t<li>Only numbers <code>1</code> through <code>9</code> are used.</li>\n\t<li>Each number is used <strong>at most once</strong>.</li>\n</ul>\n\n<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 7\n<strong>Output:</strong> [[1,2,4]]\n<strong>Explanation:</strong>\n1 + 2 + 4 = 7\nThere are no other valid combinations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 9\n<strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]\n<strong>Explanation:</strong>\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 4, n = 1\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n"},{"id":"2023987","title":"132 Pattern","url":"/discuss/topic/2023987/on3-on2-on-log-n-and-on-solutions","questionTitle":"132 Pattern","post":{"creationDate":1652142151},"post_data":{"id":2023987,"title":"O(N^3), O(N^2), O(N log N) and O(N) solutions","solutionTags":[{"name":"C++"}],"post":{"id":3411668,"content":"# O(N^3)  solution\nBrute force to test all triplets for the required condition. This requires a triple for loop.\nPseudocode:\n```\nfor i in 0..n\n\tfor j in in i+1..n\n\t\tfor k in  j+1..n\n\t\t  if nums[i]<nums[k]<nums[j]\n\t\t    return true\nreturn false\n```\nThis is trivial to implement and guaranteed to be TLE so no need to code this.\n\n# O(N^2) solution\nWe can eliminate one for loop!\nWe can do this by keeping track of min element to the left as `minLeft`. If `minLeft==nums[i]`, we need not test for the condition and if not, we try to find an appropriate item in the right side.\n```\nclass Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        int n=nums.size();\n        if (n<3) return false;\n        int minLeft=nums[0];\n        for (int j=0; j<n; j++)\n        {\n            minLeft = min(minLeft, nums[j]);\n            if (minLeft==nums[j]) continue;\n            for (int k=n-1; k>j; k--)\n                if (nums[k]>minLeft && nums[k]<nums[j])\n                    return true;\n        }\n        return false;\n    }\n};\n```\nUnfortunately this gives TLE on the last test case. So, we need to improve.\n\n# O(N log N) solution\nWe can replace the 2nd for loop that we use to find the right element by a binary search heuristic.\nWe traverse the array right to left and maintain a sorted array by inserting at the appropriate location obtained using binary search. We also maintain a very important array `largestSmaller` such that `largestSmaller[i] =`  `largest of the items to the right of nums[i] which are all smaller than nums[i]`. Essentially this is the `2` in the `132` that we need. Now if we get anything less than this element in the left side, we have a triplet.\n```\nclass Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        int n=nums.size(), minLeft=INT_MAX, minRight=INT_MAX;\n        if (n<3) return false;\n        vector<int> largestSmaller(n,0), sortedRight;\n        for (int i=n-1;i>=0;i--)\n        {\n            minRight = min(minRight, nums[i]);\n            if (nums[i]==minRight){\n                sortedRight.insert(sortedRight.begin(),nums[i]);\n                largestSmaller[i]=nums[i];\n            }\n            else\n            {\n                vector<int>::iterator low=lower_bound(sortedRight.begin(), sortedRight.end(), nums[i]);\n                int pos=low-sortedRight.begin();\n                largestSmaller[i] = sortedRight[pos-1];\n                sortedRight.insert(sortedRight.begin()+pos, nums[i]);\n            }\n        }\n        for (int i=0; i<n; i++)\n        {\n            minLeft = min(minLeft, nums[i]);\n            if (minLeft<nums[i] && minLeft<largestSmaller[i] && nums[i]>largestSmaller[i]) return true;\n        }\n        return false;\n    }\n};\n```\n\nSadly this O(N log N) solution also gives a TLE.\nHowever, [I knew of a bug in LC where it accepts python but says TLE for cpp](https://leetcode.com/discuss/general-discussion/1743011/c-tle-vs-python-ac-issue) and decided to try coding the exact same logic in python\n```\nclass Solution:\n    def find132pattern(self, nums: List[int]) -> bool:\n        n, minLeft, minRight = len(nums), 10**9+1, 10**9+1\n        if n<3: return False\n        largestSmaller, sortedRight = [0 for _ in range(n)],[]\n        for i in range(n-1,-1,-1):\n            minRight = min(minRight, nums[i])\n            if nums[i]==minRight:\n                sortedRight.insert(0, nums[i])\n                largestSmaller[i] = nums[i]\n            else:\n                pos = bisect_left(sortedRight, nums[i])\n                largestSmaller[i] = sortedRight[pos-1]\n                sortedRight.insert(pos, nums[i])\n        for i in range(n):\n            minLeft = min(minLeft, nums[i])\n            if minLeft<largestSmaller[i]<nums[i]:\n                return True\n        return False\n```\nWith this, we get an AC !!\nHowever this may not work in a real life coding test, so we need to get an O(N) solution\n\n# O(N) solution\nThe idea is similar as above. The only trick is that instead of using a sorted array to find the right element, we can use a stack. We traverse right to left and store all elements smaller than the current element in a monotonically decreasing stack. Then later if ever we find that the current element is less than the element at the top of the stack, we have found a triplet.\n\n```\nclass Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        int n=nums.size();\n        if (n<3) return false;\n        stack<int> rightNums;\n        int largestSmaller = INT_MIN;\n        for (int i=n-1; i>=0; i--)\n        {\n            if (nums[i]<largestSmaller) return true;\n            else\n            {\n                while (rightNums.size()>0 && nums[i]>rightNums.top())\n                {\n                    largestSmaller = rightNums.top();\n                    rightNums.pop();\n                }\n            }\n            rightNums.push(nums[i]);\n        }\n        return false;\n    }\n};\n```\nExample:\n`[1,8,5,6,7,9,10]`\nThen right to left we get a stream 10,9,7,6,5,8,1\nSo, we get `stack=10,9,7,6,5`\nThen when we see 8: `stack=10,9,8` (5,6,7 are popped in that order) and `largestSmaller=7`. This means from now on we can look for a potential triplet if we see anything less than 7 (like 1) and the triplet is (1,8,7)\n\n\nThis solution gives us an AC and also places us at the top 5%.","creationDate":1652142151}},"acRate":32.41887135433946,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"456","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"132-pattern","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Monotonic Stack","id":"VG9waWNUYWdOb2RlOjYxMDU0","slug":"monotonic-stack"},{"name":"Ordered Set","id":"VG9waWNUYWdOb2RlOjYxMDcw","slug":"ordered-set"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>Given an array of <code>n</code> integers <code>nums</code>, a <strong>132 pattern</strong> is a subsequence of three integers <code>nums[i]</code>, <code>nums[j]</code> and <code>nums[k]</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[k] &lt; nums[j]</code>.</p>\n\n<p>Return <code>true</code><em> if there is a <strong>132 pattern</strong> in </em><code>nums</code><em>, otherwise, return </em><code>false</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no 132 pattern in the sequence.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,4,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a 132 pattern in the sequence: [1, 4, 2].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,3,2,0]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"},{"id":"2021432","title":"Letter Combinations of a Phone Number","url":"/discuss/topic/2021432/iterative-solution","questionTitle":"Letter Combinations of a Phone Number","post":{"creationDate":1652073393},"post_data":{"id":2021432,"title":"Iterative solution","solutionTags":[{"name":"C++"},{"name":"Python"}],"post":{"id":3408090,"content":"# Method:\nCreate a string array. In the beginning it has only one member which is empty string. Then when you see a digit, create a new array which is each member of old array plus each letter of new digit. Then replace the old array with the new one. Then go to next digit and so on.\nExample:\nInput: \"23\"\nArray in the process:\n```\nstart=> [\"\"]\ndigit=\"2\"=> [\"a\", \"b\", \"c\"]\ndigit=\"3\"=> [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n```\n\nc++:\n```\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        if (digits.size()==0) return {};\n        unordered_map<char,vector<char>> mapping;\n        mapping[\"2\"]={\"a\",\"b\",\"c\"};\n        mapping[\"3\"]={\"d\",\"e\",\"f\"};\n        mapping[\"4\"]={\"g\",\"h\",\"i\"};\n        mapping[\"5\"]={\"j\",\"k\",\"l\"};\n        mapping[\"6\"]={\"m\",\"n\",\"o\"};\n        mapping[\"7\"]={\"p\",\"q\",\"r\",\"s\"};\n        mapping[\"8\"]={\"t\",\"u\",\"v\"};\n        mapping[\"9\"]={\"w\",\"x\",\"y\",\"z\"};\n        vector<string>words {\"\"};\n        for (char digit: digits)\n        {\n            vector<string> new_words;\n            for (string word: words)\n                for (char letter: mapping[digit])\n                    new_words.push_back(word+letter);\n            words=new_words;\n        }\n        return words;\n    }\n};\n```\n\npython:\n```\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if len(digits) == 0: return []\n        mapping = {\"2\": \"abc\", \"3\": \"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\", \"8\":\"tuv\", \"9\":\"wxyz\"}\n        words = [\"\"]\n        for digit in digits:\n            letters = mapping[digit]\n            new_words = []\n            for word in words:\n                for letter in letters:\n                    new_words.append(word+letter)\n            words = new_words\n        return words\n```","creationDate":1652073393}},"acRate":56.297723566718524,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"17","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"letter-combinations-of-a-phone-number","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Backtracking","id":"VG9waWNUYWdOb2RlOjE0","slug":"backtracking"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>\n\n<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png\" style=\"width: 300px; height: 243px;\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;23&quot;\n<strong>Output:</strong> [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;&quot;\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;2&quot;\n<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= digits.length &lt;= 4</code></li>\n\t<li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li>\n</ul>\n"},{"id":"2012656","title":"Remove All Adjacent Duplicates in String II","url":"/discuss/topic/2012656/solution-using-stack","questionTitle":"Remove All Adjacent Duplicates in String II","post":{"creationDate":1651815104},"post_data":{"id":2012656,"title":"Solution using stack","solutionTags":[{"name":"C++"},{"name":"Stack"}],"post":{"id":3395168,"content":"Maintain a stack of (char, frequency) pair.\nHere is how it works for a test case.\n#### Input:\n```\ns = \"deeedbbcccbdaa\", k = 3\n```\n#### Dry run:\nFirst column is where you are at. Second column is the stack at that time\n```\nd : [[\"d\", 1]] \ne : [[\"d\", 1], [\"e\", 1]] \ne : [[\"d\", 1], [\"e\", 2]] \ne : [[\"d\", 1]] #You popped here\nd : [[\"d\", 2]] \nb : [[\"d\", 2], [\"b\", 1]] \nb : [[\"d\", 2], [\"b\", 2]] \nc : [[\"d\", 2], [\"b\", 2], [\"c\", 1]] \nc : [[\"d\", 2], [\"b\", 2], [\"c\", 2]] \nc : [[\"d\", 2], [\"b\", 2]] #You popped here\nb : [[\"d\", 2]] #You popped here\nd : [] #You popped here\na : [[\"a\", 1]] \na : [[\"a\", 2]] \n```\n#### Answer:\nJust join the elements in stack:\n```\n\"aa\"\n```\n\nNow we are ready to code!\n# Code:\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s, int k) {\n        stack<pair<char,int>> H;\n        for (char ch: s)\n        {\n            if (H.empty() || H.top().first!=ch) H.push({ch,1});\n            else\n            {\n                H.top().second++;\n                if (H.top().second==k) H.pop();\n            }\n        }\n        string t=\"\";\n        while (!H.empty())\n        {\n            auto p=H.top(); \n            t+=string(p.second,p.first);\n            H.pop();\n        }\n        reverse(t.begin(),t.end());\n        return t;\n    }\n};\n```","creationDate":1651815104}},"acRate":56.1195112207323,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1209","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"remove-all-adjacent-duplicates-in-string-ii","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given a string <code>s</code> and an integer <code>k</code>, a <code>k</code> <strong>duplicate removal</strong> consists of choosing <code>k</code> adjacent and equal letters from <code>s</code> and removing them, causing the left and the right side of the deleted substring to concatenate together.</p>\n\n<p>We repeatedly make <code>k</code> <strong>duplicate removals</strong> on <code>s</code> until we no longer can.</p>\n\n<p>Return <em>the final string after all such duplicate removals have been made</em>. It is guaranteed that the answer is <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcd&quot;, k = 2\n<strong>Output:</strong> &quot;abcd&quot;\n<strong>Explanation: </strong>There&#39;s nothing to delete.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;deeedbbcccbdaa&quot;, k = 3\n<strong>Output:</strong> &quot;aa&quot;\n<strong>Explanation: \n</strong>First delete &quot;eee&quot; and &quot;ccc&quot;, get &quot;ddbbbdaa&quot;\nThen delete &quot;bbb&quot;, get &quot;dddaa&quot;\nFinally delete &quot;ddd&quot;, get &quot;aa&quot;</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pbbcggttciiippooaais&quot;, k = 2\n<strong>Output:</strong> &quot;ps&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> only contains lowercase English letters.</li>\n</ul>\n"},{"id":"2008732","title":"Max Number of K-Sum Pairs","url":"/discuss/topic/2008732/two-sum-approach","questionTitle":"Max Number of K-Sum Pairs","post":{"creationDate":1651695022},"post_data":{"id":2008732,"title":"Two Sum Approach","solutionTags":[{"name":"C++"}],"post":{"id":3389554,"content":"We use a HashMap based standard two sum approach.\n```\nclass Solution {\npublic:\n    int maxOperations(vector<int>& nums, int target) {\n        unordered_map<int,int> comps;\n        int ctr=0;\n        for (int n: nums)\n        {\n            if (comps.count(n) && comps[n]>0)\n            {\n                ctr++;\n                comps[n]--;\n            } else comps[target-n]++;\n        }\n        return ctr;\n    }\n};\n```\n\n```\nTC: O(n)\nSC: O(n)\n```","creationDate":1651695022}},"acRate":57.28924632265774,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1679","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"max-number-of-k-sum-pairs","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given an integer array <code>nums</code> and an integer <code>k</code>.</p>\n\n<p>In one operation, you can pick two numbers from the array whose sum equals <code>k</code> and remove them from the array.</p>\n\n<p>Return <em>the maximum number of operations you can perform on the array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4], k = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Starting with nums = [1,2,3,4]:\n- Remove numbers 1 and 4, then nums = [2,3]\n- Remove numbers 2 and 3, then nums = []\nThere are no more pairs that sum up to 5, hence a total of 2 operations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,3,4,3], k = 6\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Starting with nums = [3,1,3,4,3]:\n- Remove the first two 3&#39;s, then nums = [1,4,3]\nThere are no more pairs that sum up to 6, hence a total of 1 operation.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n"},{"id":"1986727","title":"Smallest String With Swaps","url":"/discuss/topic/1986727/dfs-solution","questionTitle":"Smallest String With Swaps","post":{"creationDate":1651071296},"post_data":{"id":1986727,"title":"DFS solution","solutionTags":[{"name":"C++"},{"name":"Depth-First Search"}],"post":{"id":3357673,"content":"- Create graph using `pairs` as adjancency list.\n- Start with a node. Do DFS traversal. Sort the node ids (string indices) and characters both. Then put the characters in order.\n- Repeat for all nodes. Do not do for already visited nodes.\n\n```\nclass Solution {\npublic:\n    int n;\n    vector<vector<int>> edges;\n    vector<bool> visited;\n    \n    void DFS(int src, vector<int>&visited_nodes)\n    {\n        visited[src]=true;\n        visited_nodes.push_back(src);\n        for (int dest: edges[src])\n            if (!visited[dest]) DFS(dest, visited_nodes);\n    }\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) \n    {\n        n = s.size();\n        edges =  vector<vector<int>>(n, vector<int>{});\n        for (auto p: pairs)\n        {\n            int u=p[0], v=p[1];\n            edges[u].push_back(v);\n            edges[v].push_back(u);\n        }\n        visited = vector<bool>(n, false);\n        for (int u=0; u<n; u++)\n        {\n            if (!visited[u])\n            {\n                vector<int> visited_nodes;\n                DFS(u, visited_nodes);\n                vector<char> visited_chars;\n                for (int i: visited_nodes) visited_chars.push_back(s[i]);\n                sort(visited_chars.begin(), visited_chars.end());\n                sort(visited_nodes.begin(), visited_nodes.end());\n                for (int i=0; i<visited_nodes.size(); i++)\n                    s[visited_nodes[i]]=visited_chars[i];\n            }\n        }\n        return s;\n    }\n};\n```","creationDate":1651071296}},"acRate":57.624945324249666,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1202","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"smallest-string-with-swaps","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Union Find","id":"VG9waWNUYWdOb2RlOjIz","slug":"union-find"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given a string <code>s</code>, and an array of pairs of indices in the string&nbsp;<code>pairs</code>&nbsp;where&nbsp;<code>pairs[i] =&nbsp;[a, b]</code>&nbsp;indicates 2 indices(0-indexed) of the string.</p>\n\n<p>You can&nbsp;swap the characters at any pair of indices in the given&nbsp;<code>pairs</code>&nbsp;<strong>any number of times</strong>.</p>\n\n<p>Return the&nbsp;lexicographically smallest string that <code>s</code>&nbsp;can be changed to after using the swaps.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]\n<strong>Output:</strong> &quot;bacd&quot;\n<strong>Explaination:</strong> \nSwap s[0] and s[3], s = &quot;bcad&quot;\nSwap s[1] and s[2], s = &quot;bacd&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]\n<strong>Output:</strong> &quot;abcd&quot;\n<strong>Explaination: </strong>\nSwap s[0] and s[3], s = &quot;bcad&quot;\nSwap s[0] and s[2], s = &quot;acbd&quot;\nSwap s[1] and s[2], s = &quot;abcd&quot;</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cba&quot;, pairs = [[0,1],[1,2]]\n<strong>Output:</strong> &quot;abc&quot;\n<strong>Explaination: </strong>\nSwap s[0] and s[1], s = &quot;bca&quot;\nSwap s[1] and s[2], s = &quot;bac&quot;\nSwap s[0] and s[1], s = &quot;abc&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= pairs.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt;&nbsp;s.length</code></li>\n\t<li><code>s</code>&nbsp;only contains lower case English letters.</li>\n</ul>\n"},{"id":"1975633","title":"3Sum With Multiplicity","url":"/discuss/topic/1975633/3-sum-over-keys","questionTitle":"3Sum With Multiplicity","post":{"creationDate":1650727946},"post_data":{"id":1975633,"title":"3 Sum over keys","solutionTags":[{"name":"C++"}],"post":{"id":3341455,"content":"```\nclass Solution {\npublic:\n    int threeSumMulti(vector<int>& arr, int target) {\n        int n = arr.size(), MAX=101, res=0, MOD=1000000007;\n        vector<int> frequencies(MAX, 0);\n        for (int k: arr) frequencies[k]++;\n        for (int x=0; x<MAX; x++)\n        {\n            for (int y=x+1; y<MAX; y++)\n            {\n                int z=target-x-y;\n                if (z>y && z<MAX)\n                {\n                    long long a=frequencies[x], b=frequencies[y], c=frequencies[z];\n                    long long d = a*b*c;\n                    res += d%MOD;\n                    res %= MOD;\n                }\n            }\n        }\n        for (int x=0; x<MAX; x++)\n        {\n            int y = target-2*x; //x,x,y\n            if (y>x && y<MAX)\n            {\n                long long a=frequencies[x], b=frequencies[y];\n                long long c = b * a * (a-1)/2;\n                res += c%MOD;\n                res %= MOD;\n            }\n        }\n        for (int x=0; x<MAX; x++)\n        {\n            int y = (target-x)/2; // x,y,y\n            if (y>x && (target-x)%2==0 && y<MAX)\n            {\n                long long a=frequencies[x], b=frequencies[y];\n                long long c = a * b * (b-1)/2;\n                res += c%MOD;\n                res %= MOD;\n            }\n        }\n        if (target%3==0)\n        {\n            int x=target/3;\n            long long a=frequencies[x];\n            long long b = a * (a-1) * (a-2)/6;\n            res += b%MOD;\n            res %= MOD;\n        }\n        return res;\n    }\n};\n```\n\n```\nTC: O(MAX^2)\nSC: O(MAX)\n```\nwhere `MAX` is the maximum value in the array (here 100).\nNotice that the complexities do not depend on the length of `arr`.","creationDate":1650727946}},"acRate":45.323864448787,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"923","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"3sum-with-multiplicity","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"},{"name":"Counting","id":"VG9waWNUYWdOb2RlOjYxMDYy","slug":"counting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer array <code>arr</code>, and an integer <code>target</code>, return the number of tuples <code>i, j, k</code> such that <code>i &lt; j &lt; k</code> and <code>arr[i] + arr[j] + arr[k] == target</code>.</p>\n\n<p>As the answer can be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,1,2,2,3,3,4,4,5,5], target = 8\n<strong>Output:</strong> 20\n<strong>Explanation: </strong>\nEnumerating by the values (arr[i], arr[j], arr[k]):\n(1, 2, 5) occurs 8 times;\n(1, 3, 4) occurs 8 times;\n(2, 2, 4) occurs 2 times;\n(2, 3, 3) occurs 2 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,1,2,2,2,2], target = 5\n<strong>Output:</strong> 12\n<strong>Explanation: </strong>\narr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:\nWe choose one 1 from [1,1] in 2 ways,\nand two 2s from [2,2,2,2] in 6 ways.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,1,3], target = 6\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> (1, 2, 3) occured one time in the array so we return 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 3000</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= target &lt;= 300</code></li>\n</ul>\n"},{"id":"1974704","title":"Encode and Decode TinyURL","url":"/discuss/topic/1974704/easy-hashmap-solution","questionTitle":"Encode and Decode TinyURL","post":{"creationDate":1650704215},"post_data":{"id":1974704,"title":"Easy HashMap solution","solutionTags":[{"name":"C++"}],"post":{"id":3340200,"content":"```\nclass Solution {\npublic:\n    unordered_map<int,string> int2url;\n    unordered_map<string,int> url2int;\n    string base_url = \"http://tiny.io/\";\n    // Encodes a URL to a shortened URL.\n    string encode(string longUrl) {\n        if (url2int.find(longUrl)==url2int.end())\n        {\n            int ctr=url2int.size();\n            url2int[longUrl] = ctr;\n            int2url[ctr] = longUrl;\n        }\n        return base_url+to_string(url2int[longUrl]);\n    }\n\n    // Decodes a shortened URL to its original URL.\n    string decode(string shortUrl) {\n        string nstr = string(shortUrl.begin()+15,shortUrl.end());\n        int n = stoi(nstr);\n        return int2url[n];\n    }\n};\n```","creationDate":1650704215}},"acRate":85.90344647959614,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"535","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"encode-and-decode-tinyurl","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"},{"name":"Hash Function","id":"VG9waWNUYWdOb2RlOjYxMDY1","slug":"hash-function"}],"hasSolution":true,"hasVideoSolution":false,"content":"<blockquote>Note: This is a companion problem to the <a href=\"https://leetcode.com/discuss/interview-question/system-design/\" target=\"_blank\">System Design</a> problem: <a href=\"https://leetcode.com/discuss/interview-question/124658/Design-a-URL-Shortener-(-TinyURL-)-System/\" target=\"_blank\">Design TinyURL</a>.</blockquote>\n\n<p>TinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>. Design a class to encode a URL and decode a tiny URL.</p>\n\n<p>There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution()</code> Initializes the object of the system.</li>\n\t<li><code>String encode(String longUrl)</code> Returns a tiny URL for the given <code>longUrl</code>.</li>\n\t<li><code>String decode(String shortUrl)</code> Returns the original long URL for the given <code>shortUrl</code>. It is guaranteed that the given <code>shortUrl</code> was encoded by the same object.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> url = &quot;https://leetcode.com/problems/design-tinyurl&quot;\n<strong>Output:</strong> &quot;https://leetcode.com/problems/design-tinyurl&quot;\n\n<strong>Explanation:</strong>\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // returns the encoded tiny url.\nstring ans = obj.decode(tiny); // returns the original url after deconding it.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= url.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>url</code> is guranteed to be a valid URL.</li>\n</ul>\n"},{"id":"1968608","title":"Design HashMap","url":"/discuss/topic/1968608/hashing-using-modulo","questionTitle":"Design HashMap","post":{"creationDate":1650517815},"post_data":{"id":1968608,"title":"Hashing using modulo","solutionTags":[{"name":"C++"}],"post":{"id":3331398,"content":"We learn this in college. It is good to get a chance to implement.\nHere we use modulo operator as the hashing function and M is chosen to be a big enough prime.\n```\nclass Node {\n    public:\n    int key;\n    int val;\n    Node *next;\n    Node(int k, int v, Node *n){key=k;val=v;next=n;}\n};\n\nclass MyHashMap {\npublic:\n    vector<Node *>nodes;\n    int N;\n    MyHashMap(int n=99991) {\n        nodes = vector<Node *>(n,NULL);\n        N = n;        \n    }\n    \n    void put(int key, int value) {\n        int h = key%N;\n        if (nodes[h]==NULL)\n        {\n            nodes[h]=new Node(key,value,NULL);\n            return;\n        }\n        Node *curr=nodes[h];\n        while (curr!=NULL)\n        {\n            if (curr->key==key)\n            {\n                curr->val=value;\n                return;\n            }\n            curr=curr->next;\n        }\n        while (curr->next!=NULL) curr=curr->next;\n        curr->next=new Node(key,value,NULL);\n    }\n    \n    int get(int key) {\n        int h = key%N;\n        if (nodes[h]==NULL) return -1;\n        Node *curr = nodes[h];\n        while (curr!=NULL)\n        {\n            if (curr->key==key) return curr->val;\n            curr=curr->next;\n        }\n        return -2;\n    }\n    \n    void remove(int key) {\n        int h=key%N;\n        if (nodes[h]==NULL) return;\n        if (nodes[h]->key==key) \n        {\n            nodes[h]=nodes[h]->next;\n            return;\n        }\n        Node *curr=nodes[h];\n        while (curr->next!=NULL && curr->next->key!=key) curr=curr->next;\n        curr->next = curr->next->next;        \n    }\n};\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj = new MyHashMap();\n * obj->put(key,value);\n * int param_2 = obj->get(key);\n * obj->remove(key);\n */\n```\n\nI solved the HashSet problem too using similar method: <https://leetcode.com/problems/design-hashset/discuss/1968599/Hashing-using-modulo>","creationDate":1650517815}},"acRate":64.78233391212565,"difficulty":"Easy","freqBar":null,"frontendQuestionId":"706","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"design-hashmap","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"},{"name":"Hash Function","id":"VG9waWNUYWdOb2RlOjYxMDY1","slug":"hash-function"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Design a HashMap without using any built-in hash table libraries.</p>\n\n<p>Implement the <code>MyHashMap</code> class:</p>\n\n<ul>\n\t<li><code>MyHashMap()</code> initializes the object with an empty map.</li>\n\t<li><code>void put(int key, int value)</code> inserts a <code>(key, value)</code> pair into the HashMap. If the <code>key</code> already exists in the map, update the corresponding <code>value</code>.</li>\n\t<li><code>int get(int key)</code> returns the <code>value</code> to which the specified <code>key</code> is mapped, or <code>-1</code> if this map contains no mapping for the <code>key</code>.</li>\n\t<li><code>void remove(key)</code> removes the <code>key</code> and its corresponding <code>value</code> if the map contains the mapping for the <code>key</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n<strong>Output</strong>\n[null, null, null, 1, -1, null, 1, null, -1]\n\n<strong>Explanation</strong>\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // The map is now [[1,1]]\nmyHashMap.put(2, 2); // The map is now [[1,1], [2,2]]\nmyHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]\nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]\nmyHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)\nmyHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]\nmyHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]\nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key, value &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>put</code>, <code>get</code>, and <code>remove</code>.</li>\n</ul>\n"},{"id":"1968599","title":"Design HashSet","url":"/discuss/topic/1968599/hashing-using-modulo","questionTitle":"Design HashSet","post":{"creationDate":1650517735},"post_data":{"id":1968599,"title":"Hashing using modulo","solutionTags":[{"name":"C++"}],"post":{"id":3331387,"content":"Here we use modulo operator as the hashing function and M is chosen to be a big enough prime.\n```\nclass Node {\n    public:\n    int val;\n    Node *next;\n    Node(int v, Node *n){val=v;next=n;}\n};\nclass MyHashSet {\npublic:\n    vector<Node *>nodes;\n    int N;\n    MyHashSet(int n=99991) {\n        nodes = vector<Node *>(n,NULL);\n        N = n;\n    }\n    \n    void add(int key) {\n        if (contains(key)) return;\n        int h = key%N;\n        if (nodes[h]==NULL) nodes[h]=new Node(key,NULL);\n        else\n        {\n            Node *curr=nodes[h];\n            while (curr->next!=NULL) curr=curr->next;\n            curr->next=new Node(key,NULL);\n        }\n    }\n    \n    void remove(int key) {\n        if (!contains(key)) return;\n        int h=key%N;\n        if (nodes[h]->val==key) \n        {\n            nodes[h]=nodes[h]->next;\n            return;\n        }\n        Node *curr=nodes[h];\n        while (curr->next!=NULL && curr->next->val!=key) curr=curr->next;\n        curr->next = curr->next->next;\n    }\n    \n    bool contains(int key) {\n        int h=key%N;\n        if (nodes[h]==NULL) return false;\n        Node *curr=nodes[h];\n        while (curr!=NULL) \n        {\n            if (curr->val==key) return true;\n            curr=curr->next;\n        }\n        return false;\n    }\n};\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet* obj = new MyHashSet();\n * obj->add(key);\n * obj->remove(key);\n * bool param_3 = obj->contains(key);\n */\n```","creationDate":1650517735}},"acRate":65.69950951315786,"difficulty":"Easy","freqBar":null,"frontendQuestionId":"705","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"design-hashset","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"},{"name":"Hash Function","id":"VG9waWNUYWdOb2RlOjYxMDY1","slug":"hash-function"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Design a HashSet without using any built-in hash table libraries.</p>\n\n<p>Implement <code>MyHashSet</code> class:</p>\n\n<ul>\n\t<li><code>void add(key)</code> Inserts the value <code>key</code> into the HashSet.</li>\n\t<li><code>bool contains(key)</code> Returns whether the value <code>key</code> exists in the HashSet or not.</li>\n\t<li><code>void remove(key)</code> Removes the value <code>key</code> in the HashSet. If <code>key</code> does not exist in the HashSet, do nothing.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n<strong>Output</strong>\n[null, null, null, true, false, null, true, null, false]\n\n<strong>Explanation</strong>\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // return False, (already removed)</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>, <code>remove</code>, and <code>contains</code>.</li>\n</ul>\n"},{"id":"1966446","title":"Game of Life","url":"/discuss/topic/1966446/o1-space-solution","questionTitle":"Game of Life","post":{"creationDate":1650453097},"post_data":{"id":1966446,"title":"O(1) space solution","solutionTags":[],"post":{"id":3328214,"content":"**TC of both solutions is O(M\\*N)**\n# O(1) Space solution\nUse 2 bits to maintain board. Left bit to store new values and right bit for original values.\n```\nclass Solution {\npublic:\n    int getNumNeighbors(vector<vector<int>>board,int m,int n, int i, int j)\n    {\n        int ctr=0;\n        for (int x=max(i-1,0);x<min(i+2,m);x++)\n            for (int y=max(j-1,0);y<min(j+2,n);y++) ctr+=board[x][y]&1;\n        ctr-=board[i][j]&1;\n        return ctr;\n    }\n    void gameOfLife(vector<vector<int>>& board) {\n        int m=board.size(), n=board[0].size();\n        for (int i=0;i<m;i++)\n        {\n            for (int j=0;j<n;j++)\n            {\n                int num_neighbors=getNumNeighbors(board,m,n,i,j);\n                if (board[i][j]==1 && num_neighbors<2) board[i][j]=1;\n                if (board[i][j]==1 && num_neighbors>3) board[i][j]=1;\n                if (board[i][j]==0 && num_neighbors==3)board[i][j]=2;\n                if (board[i][j]==1 && (num_neighbors==2 || num_neighbors==3))board[i][j]=3;\n            }\n        }\n        for (int i=0;i<m;i++) for (int j=0;j<n;j++) board[i][j]>>=1;\n    }\n};\n```\n\n# O(M\\*N) space solution\nUse auxiliary board variable to store new board values. Finally replace original with auxiliary.\n```\nclass Solution {\npublic:\n    int getNumNeighbors(vector<vector<int>>board,int m,int n, int i, int j)\n    {\n        int ctr=0;\n        for (int x=max(i-1,0);x<min(i+2,m);x++)\n            for (int y=max(j-1,0);y<min(j+2,n);y++) ctr+=board[x][y];\n        ctr-=board[i][j];\n        return ctr;\n    }\n\n    void gameOfLife(vector<vector<int>>& board) {\n        int m=board.size(), n=board[0].size();\n        vector<vector<int>> board_c(m,vector<int>(n,0));\n        for (int i=0;i<m;i++)\n        {\n            for (int j=0;j<n;j++)\n            {\n                int num_neighbors=getNumNeighbors(board,m,n,i,j);\n                if (board[i][j]==1 && num_neighbors<2) board_c[i][j]=0;\n                if (board[i][j]==1 && num_neighbors>3) board_c[i][j]=0;\n                if (board[i][j]==0 && num_neighbors==3)board_c[i][j]=1;\n                if (board[i][j]==1 && (num_neighbors==2 || num_neighbors==3))board_c[i][j]=1;\n            }\n        }\n        board = board_c;\n    }\n};\n```","creationDate":1650453097}},"acRate":67.05561488368197,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"289","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"game-of-life","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"},{"name":"Simulation","id":"VG9waWNUYWdOb2RlOjYxMDU1","slug":"simulation"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>According to&nbsp;<a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\" target=\"_blank\">Wikipedia&#39;s article</a>: &quot;The <b>Game of Life</b>, also known simply as <b>Life</b>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&quot;</p>\n\n<p>The board is made up of an <code>m x n</code> grid of cells, where each cell has an initial state: <b>live</b> (represented by a <code>1</code>) or <b>dead</b> (represented by a <code>0</code>). Each cell interacts with its <a href=\"https://en.wikipedia.org/wiki/Moore_neighborhood\" target=\"_blank\">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>\n\n<ol>\n\t<li>Any live cell with fewer than two live neighbors dies as if caused by under-population.</li>\n\t<li>Any live cell with two or three live neighbors lives on to the next generation.</li>\n\t<li>Any live cell with more than three live neighbors dies, as if by over-population.</li>\n\t<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>\n</ol>\n\n<p><span>The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the <code>m x n</code> grid <code>board</code>, return <em>the next state</em>.</span></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg\" style=\"width: 562px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n<strong>Output:</strong> [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg\" style=\"width: 402px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> board = [[1,1],[1,0]]\n<strong>Output:</strong> [[1,1],[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 25</code></li>\n\t<li><code>board[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.</li>\n\t<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?</li>\n</ul>\n"},{"id":"1966261","title":"Binary Search Tree Iterator","url":"/discuss/topic/1966261/two-solutions-easy-and-medium","questionTitle":"Binary Search Tree Iterator","post":{"creationDate":1650447965},"post_data":{"id":1966261,"title":"Two solutions: Easy and Medium","solutionTags":[{"name":"C++"}],"post":{"id":3327930,"content":"# Easy Solution\nJust traverse the array and store keys in an array. Then return answer from array.\n```\nclass BSTIterator {\npublic:\n    vector<int>keys;\n    int idx;\n    void traverse(TreeNode *root, vector<int>&keys_v)\n    {\n        if (root==NULL) return;\n        traverse(root->left, keys_v);\n        keys_v.push_back(root->val);\n        traverse(root->right, keys_v);\n    }\n    BSTIterator(TreeNode* root) {\n        traverse(root, keys);\n        idx=0;\n    }\n    \n    int next() {\n        return keys[idx++];\n    }\n    \n    bool hasNext() {\n        return idx < keys.size();\n    }\n};\n```\n```\nTC: O(1)\nSC: O(n)\n```\n# Medium Solution\nUse stack to go as left as possible accumulating the nodes. Then return from bottom left and move to right (Accumulate nodes from right node to left-wards).\n```\nclass BSTIterator {\npublic:\n    stack<TreeNode *>nodes;\n    void pushLeft(TreeNode *root)\n    {\n        while (root!=NULL)\n        {\n            nodes.push(root);\n            root=root->left;\n        }\n    }\n    BSTIterator(TreeNode* root) {\n        pushLeft(root);\n    }\n    \n    int next() {\n        if (nodes.size()>0)\n        {\n            TreeNode *leftBottom = nodes.top();\n            nodes.pop();\n            pushLeft(leftBottom->right);\n            return leftBottom->val;\n        }\n        else return -1;\n        \n    }\n    \n    bool hasNext() {\n        return nodes.size()>0;\n    }\n};\n\n```\n```\nTC: \\u03B8(1) \nSC: O(h)\n```","creationDate":1650447965}},"acRate":69.56423531208311,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"173","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"binary-search-tree-iterator","topicTags":[{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"},{"name":"Binary Search Tree","id":"VG9waWNUYWdOb2RlOjMw","slug":"binary-search-tree"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"},{"name":"Iterator","id":"VG9waWNUYWdOb2RlOjYxMDY0","slug":"iterator"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\" target=\"_blank\">in-order traversal</a></strong> of a binary search tree (BST):</p>\n\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>\n\t<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>\n</ul>\n\n<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>\n\n<p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style=\"width: 189px; height: 178px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n<strong>Output</strong>\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n<strong>Explanation</strong>\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made to <code>hasNext</code>, and <code>next</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you implement <code>next()</code> and <code>hasNext()</code> to run in average <code>O(1)</code> time and use&nbsp;<code>O(h)</code> memory, where <code>h</code> is the height of the tree?</li>\n</ul>\n"},{"id":"1963699","title":"Spiral Matrix II","url":"/discuss/topic/1963699/two-approaches","questionTitle":"Spiral Matrix II","post":{"creationDate":1650371889},"post_data":{"id":1963699,"title":"Two approaches","solutionTags":[{"name":"C++"}],"post":{"id":3324167,"content":"# Approach1\nThis approach is based on using min, max for x and y carefully. Basically. You go in cycles of \n```\nIncrement Y\nIncreement X\nDecrement Y\nDecrement X\n```\nThe bounds also have to change so that we traverse the spiral.\n```\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> M(n, vector<int>(n,0));\n        int x=0, y=0, curr=1, x_min=0, x_max=n-1, y_min=0, y_max=n-1;\n        while (x>x_min||x<x_max||y>y_min||y<y_max)\n        {\n            while (y<y_max) M[x][y++]=curr++; x_min++;\n            while (x<x_max) M[x++][y]=curr++; y_max--;\n            while (y>y_min) M[x][y--]=curr++; x_max--;\n            while (x>x_min) M[x--][y]=curr++; y_min++;     \n        }\n        M[x][y]=curr;\n        return M;\n    }\n};\n```\n\n```\nTC: O(n^2)\nSC: O(1)\n```\n\nVerdict:\nFaster than 100% solutions\nMemory less than 90% solutions\n# Approach 2\nThis approach uses an observation:\nFor N=3 ie 9 elements, we see the pattern `v=[3,2,2,1,1]` (Total 9) ie 3 numbers from Left to Right => then 2 from Top to Bottom ==> then 2 from Right to Left ==> then 1 from Bottom to Top ==> then 1 from Left to Right.\nSimilarly for N=4 ie 16 elements, the pattern is `v=[4,3,3,2,2,1,1]`.\nSimilarly for N=5 ie 25 elements we have `v=[5,4,4,3,3,2,2,1,1]`\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> M(n, vector<int>(n,0));\n        vector<int>v;\n        for (int i=1;i<n;i++){v.push_back(i);v.push_back(i);} v.push_back(n-1);\n        reverse(v.begin(),v.end());\n        // 2,2,2,1,1\n        int curr=1;\n        int x=0,y=0;\n        for (int i=0; i<v.size(); i++)\n        {\n            for (int j=0; j<v[i]; j++)\n            {\n                M[x][y]=curr;\n                curr++;\n                if (i%4==0) y++;\n                if (i%4==1) x++;\n                if (i%4==2) y--;\n                if (i%4==3) x--;\n            }\n        }\n        M[x][y]=curr;\n        return M;\n    }\n};\n```\n\n```\nTC: O(n^2)\nSC: O(n)\n```\n\nVerdict:\nFaster than 100% solutions\nMemory less than 30% solutions\n\n","creationDate":1650371889}},"acRate":67.1831104328832,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"59","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"spiral-matrix-ii","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"},{"name":"Simulation","id":"VG9waWNUYWdOb2RlOjYxMDU1","slug":"simulation"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n<sup>2</sup></code> in spiral order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> [[1,2,3],[8,9,4],[7,6,5]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n"},{"id":"1953374","title":"Trapping Rain Water","url":"/discuss/topic/1953374/easy-method","questionTitle":"Trapping Rain Water","post":{"creationDate":1650118517},"post_data":{"id":1953374,"title":"Easy method","solutionTags":[{"name":"C++"}],"post":{"id":3309721,"content":"Water trapped at any point is equal to `min(max_to_the_left, max_to_the_right) - h` where `h` is its own height.\nSo all we need to do is find out that for each point, what is the maximum height to its left and maximum height to its right. This can be achieved in a fairly easy way: Just traverse through the array Left to Right and keep track of the max element seen. Similarly do the same but from Right to Left.\nFinally, we do one last traversal to find the total water accumulated but this time from `1 to n-2` because the elements `0` and `n-1` (first and last) cannot hold water.\n\n```\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        int curr=0;\n        vector<int> maxLtoR(n,0), maxRtoL(n,0);\n        for (int i=0; i<n; i++)\n        {\n            curr = max(curr, height[i]);\n            maxLtoR[i] = curr;\n        }\n        curr = 0;\n        for (int i=n-1; i>=0; i--)\n        {\n            curr = max(curr, height[i]);\n            maxRtoL[i] = curr;\n        }\n        int amt_here, total_amt=0;\n        for (int i=1; i<n-1; i++)\n        {\n            amt_here =  min(maxLtoR[i], maxRtoL[i]) - height[i];\n            total_amt += amt_here;\n        }\n        return total_amt;\n    }\n};\n```\n\n```\nTC: O(n)\nSC: O(n)\n```","creationDate":1650118517}},"acRate":59.12329459118356,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"42","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"trapping-rain-water","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Monotonic Stack","id":"VG9waWNUYWdOb2RlOjYxMDU0","slug":"monotonic-stack"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png\" style=\"width: 412px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> height = [4,2,0,3,2,5]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"},{"id":"1952298","title":"Convert BST to Greater Tree","url":"/discuss/topic/1952298/easy-hashmap-solution","questionTitle":"Convert BST to Greater Tree","post":{"creationDate":1650092614},"post_data":{"id":1952298,"title":"Easy HashMap solution","solutionTags":[{"name":"C++"}],"post":{"id":3308287,"content":"Given that all keys in the tree are unique we can use a HashMap of the structure `unordered_map<int,TreeNode*>` to store the tree. Then we can do the operations asked and substitute appropriate values as the new keys.\n```\nclass Solution {\npublic:\n    void traverse(TreeNode *root, unordered_map<int, TreeNode *>&H)\n    {\n        if (root==NULL) return;\n        H[root->val] = root;\n        traverse(root->left, H);\n        traverse(root->right, H);\n    }\n    TreeNode* bstToGst(TreeNode* root) {\n        unordered_map<int, TreeNode *> H;\n        traverse(root, H);\n        vector<int> v1, v2;\n        for (auto item: H) v1.push_back(item.first);\n        sort(v1.begin(),v1.end(), greater<int>());\n        int curr=0;\n        for (int i: v1)\n        {\n            v2.push_back(curr+i);\n            curr+=i;\n        }\n        for (int i=0; i<v1.size(); i++) H[v1[i]]->val = v2[i];\n        return root;\n    }\n};\n```","creationDate":1650092614}},"acRate":67.68292368931938,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"538","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"convert-bst-to-greater-tree","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Binary Search Tree","id":"VG9waWNUYWdOb2RlOjMw","slug":"binary-search-tree"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>\n\n<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>\n\n<ul>\n\t<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/02/tree.png\" style=\"width: 500px; height: 341px;\" />\n<pre>\n<strong>Input:</strong> root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>Output:</strong> [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0,null,1]\n<strong>Output:</strong> [1,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>All the values in the tree are <strong>unique</strong>.</li>\n\t<li><code>root</code> is guaranteed to be a valid binary search tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 1038: <a href=\"https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\" target=\"_blank\">https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/</a></p>\n"},{"id":"1952288","title":"Binary Search Tree to Greater Sum Tree","url":"/discuss/topic/1952288/easy-hashmap-solution","questionTitle":"Binary Search Tree to Greater Sum Tree","post":{"creationDate":1650092283},"post_data":{"id":1952288,"title":"Easy HashMap solution","solutionTags":[{"name":"C++"}],"post":{"id":3308274,"content":"Given that all keys in the tree are unique we can use a HashMap of the structure `unordered_map<int,TreeNode*>` to store the tree. Then we can do the operations asked and substitute appropriate values as the new keys.\n```\nclass Solution {\npublic:\n    void traverse(TreeNode *root, unordered_map<int, TreeNode *>&H)\n    {\n        if (root==NULL) return;\n        H[root->val] = root;\n        traverse(root->left, H);\n        traverse(root->right, H);\n    }\n    TreeNode* bstToGst(TreeNode* root) {\n        unordered_map<int, TreeNode *> H;\n        traverse(root, H);\n        vector<int> v1, v2;\n        for (auto item: H) v1.push_back(item.first);\n        sort(v1.begin(),v1.end(), greater<int>());\n        int curr=0;\n        for (int i: v1)\n        {\n            v2.push_back(curr+i);\n            curr+=i;\n        }\n        for (int i=0; i<v1.size(); i++) H[v1[i]]->val = v2[i];\n        return root;\n    }\n};\n```","creationDate":1650092283}},"acRate":85.49931680770337,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1038","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"binary-search-tree-to-greater-sum-tree","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Binary Search Tree","id":"VG9waWNUYWdOb2RlOjMw","slug":"binary-search-tree"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>\n\n<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>\n\n<ul>\n\t<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/02/tree.png\" style=\"width: 400px; height: 273px;\" />\n<pre>\n<strong>Input:</strong> root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>Output:</strong> [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0,null,1]\n<strong>Output:</strong> [1,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li>All the values in the tree are <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 538: <a href=\"https://leetcode.com/problems/convert-bst-to-greater-tree/\" target=\"_blank\">https://leetcode.com/problems/convert-bst-to-greater-tree/</a></p>\n"},{"id":"1950731","title":"Trim a Binary Search Tree","url":"/discuss/topic/1950731/recursive-c-solution","questionTitle":"Trim a Binary Search Tree","post":{"creationDate":1650047409},"post_data":{"id":1950731,"title":"Recursive C++ solution","solutionTags":[{"name":"C++"}],"post":{"id":3306181,"content":"The important observation is that:\n**If  parent<low => parent->left < low**\nSimilarly\n**If  parent>high => parent->right> high**\nThus we can reject the entire subtree depending on this condition.\n\nWe can build the tree recursively and return `root`.\n\n```\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if (root==NULL) return root;\n        if (root->val < low) return trimBST(root->right, low, high);\n        if (root->val > high) return trimBST(root->left, low, high);\n        root->left = trimBST(root->left, low, high);\n        root->right = trimBST(root->right, low, high);\n        return root;\n    }\n};\n```","creationDate":1650047409}},"acRate":66.35737650667583,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"669","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"trim-a-binary-search-tree","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Binary Search Tree","id":"VG9waWNUYWdOb2RlOjMw","slug":"binary-search-tree"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node&#39;s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p>\n\n<p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg\" style=\"width: 450px; height: 126px;\" />\n<pre>\n<strong>Input:</strong> root = [1,0,2], low = 1, high = 2\n<strong>Output:</strong> [1,null,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg\" style=\"width: 450px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n<strong>Output:</strong> [3,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The value of each node in the tree is <strong>unique</strong>.</li>\n\t<li><code>root</code> is guaranteed to be a valid binary search tree.</li>\n\t<li><code>0 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code></li>\n</ul>\n"},{"id":"1894572","title":"Find Median from Data Stream","url":"/discuss/topic/1894572/classical-solution-two-heaps","questionTitle":"Find Median from Data Stream","post":{"creationDate":1648562933},"post_data":{"id":1894572,"title":"Classical solution two heaps","solutionTags":[{"name":"C++"},{"name":"Heap (Priority Queue)"}],"post":{"id":3226257,"content":"This is a classical heaps question.\nThe solution is to maintain two heaps, a max heap of lower than median values and a min heap of higher than median values. On querying for median, you return from the top of whichever heap as an extra element or in case both have same number of elements (size of array is even), then avarage of top of both heaps.\n\n```\nclass MedianFinder {\npublic:\n    priority_queue<int> q1; //lower half is a max heap\n    priority_queue<int, vector<int>, greater<int>> q2; // upper half is a min heap\n    MedianFinder() {        \n    }\n    \n    void addNum(int num) {\n        if (q1.size()==0 || num < q1.top()) q1.push(num);\n        else q2.push(num);\n        if (q1.size() > q2.size()+1)\n        {\n            q2.push(q1.top());\n            q1.pop();\n        } else if (q2.size() > q1.size()+1)\n        {\n            q1.push(q2.top());\n            q2.pop();\n        }\n    }\n    \n    double findMedian() {\n        int n1=q1.size(), n2=q2.size();\n        if (n1 > n2) return q1.top();\n        else if (n2 > n1) return q2.top();\n        else if (n1==n2) return .5 * (double)q1.top() + .5 * (double)q2.top();\n        return -1;\n    }\n};\n```","creationDate":1648562933}},"acRate":51.46239906212416,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"295","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"find-median-from-data-stream","topicTags":[{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"},{"name":"Heap (Priority Queue)","id":"VG9waWNUYWdOb2RlOjYxMDUw","slug":"heap-priority-queue"},{"name":"Data Stream","id":"VG9waWNUYWdOb2RlOjYxMDYz","slug":"data-stream"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p>\n\n<ul>\n\t<li>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</li>\n\t<li>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>\n</ul>\n\n<p>Implement the MedianFinder class:</p>\n\n<ul>\n\t<li><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</li>\n\t<li><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</li>\n\t<li><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]\n[[], [1], [2], [], [3], []]\n<strong>Output</strong>\n[null, null, null, 1.5, null, 2.0]\n\n<strong>Explanation</strong>\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>5</sup> &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li>\n\t<li>At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>If all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>\n\t<li>If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>\n</ul>\n"},{"id":"1889353","title":"Top K Frequent Words","url":"/discuss/topic/1889353/3-line-simplest-on-log-n-solution-by-sorting","questionTitle":"Top K Frequent Words","post":{"creationDate":1648400347},"post_data":{"id":1889353,"title":"3 line simplest O(n log n ) solution by sorting","solutionTags":[{"name":"Python"}],"post":{"id":3218710,"content":"We need the answer in decreasing order of frequency but increasing order lexicographically. To take both into account we make the frequencies negative and use both in increasing order with desired priority for sorting.\n\n```\nclass Solution:\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        counter = Counter(words)\n        sorted_words = sorted(counter.keys(),  key=lambda i: (-counter[i], i))\n        return sorted_words[:k]\n```\nI used python because it has a inbuilt counter. If you are using another language you can use hashmap to create a counter yourself.","creationDate":1648400347}},"acRate":57.08482396964837,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"692","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"top-k-frequent-words","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Trie","id":"VG9waWNUYWdOb2RlOjI3","slug":"trie"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"},{"name":"Heap (Priority Queue)","id":"VG9waWNUYWdOb2RlOjYxMDUw","slug":"heap-priority-queue"},{"name":"Bucket Sort","id":"VG9waWNUYWdOb2RlOjYxMDYw","slug":"bucket-sort"},{"name":"Counting","id":"VG9waWNUYWdOb2RlOjYxMDYy","slug":"counting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an array of strings <code>words</code> and an integer <code>k</code>, return <em>the </em><code>k</code><em> most frequent strings</em>.</p>\n\n<p>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;i&quot;,&quot;love&quot;,&quot;coding&quot;], k = 2\n<strong>Output:</strong> [&quot;i&quot;,&quot;love&quot;]\n<strong>Explanation:</strong> &quot;i&quot; and &quot;love&quot; are the two most frequent words.\nNote that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;the&quot;,&quot;day&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;the&quot;,&quot;the&quot;,&quot;the&quot;,&quot;sunny&quot;,&quot;is&quot;,&quot;is&quot;], k = 4\n<strong>Output:</strong> [&quot;the&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;day&quot;]\n<strong>Explanation:</strong> &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li><code>k</code> is in the range <code>[1, The number of <strong>unique</strong> words[i]]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Could you solve it in <code>O(n log(k))</code> time and <code>O(n)</code> extra space?</p>\n"},{"id":"1889288","title":"Number of Steps to Reduce a Number in Binary Representation to One","url":"/discuss/topic/1889288/simply-simulate-the-steps","questionTitle":"Number of Steps to Reduce a Number in Binary Representation to One","post":{"creationDate":1648399039},"post_data":{"id":1889288,"title":"Simply simulate the steps","solutionTags":[{"name":"C++"}],"post":{"id":3218628,"content":"**How do you add 1 to a binary string**\nA: Go from right to left, if you see a one, make it zero. If you see a zero, make it one and stop. If you could not find zero then create a string like `1000` for `111`.\n\n**How do you divide a binary string by 2**\nA: Just right shift by  1.\n\nNow that we have both of these pieces, we can simulate the steps:\n\n\n```\nstring add_one(string s, int l)\n{\n    int i=l-1;\n    while (i>=0 && s[i]!=\"0\")\n    {\n        s[i]=\"0\";\n        i--;\n    }\n    if (i>=0) s[i]=\"1\";\n    else s=\"1\"+s;\n    return s;\n}\n\nstring divide_by_two(string s)\n{\n    return string(s.begin(), s.end()-1);\n}\n\nclass Solution {\npublic:\n    int numSteps(string s) {\n        int ctr=0;\n        while (s!=\"1\")\n        {\n            int l = s.length();\n            if (s[l-1]==\"0\") s = divide_by_two(s);\n            else s = add_one(s, l);\n            ctr ++;\n        }\n        return ctr;\n    }\n};\n```","creationDate":1648399039}},"acRate":52.5220910197436,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1404","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"number-of-steps-to-reduce-a-number-in-binary-representation-to-one","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Bit Manipulation","id":"VG9waWNUYWdOb2RlOjE5","slug":"bit-manipulation"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>Given the binary representation of an integer as a string <code>s</code>, return <em>the number of steps to reduce it to </em><code>1</code><em> under the following rules</em>:</p>\n\n<ul>\n\t<li>\n\t<p>If the current number is even, you have to divide it by <code>2</code>.</p>\n\t</li>\n\t<li>\n\t<p>If the current number is odd, you have to add <code>1</code> to it.</p>\n\t</li>\n</ul>\n\n<p>It is guaranteed that you can always reach one for all test cases.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1101&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> &quot;1101&quot; corressponds to number 13 in their decimal representation.\nStep 1) 13 is odd, add 1 and obtain 14.&nbsp;\nStep 2) 14 is even, divide by 2 and obtain 7.\nStep 3) 7 is odd, add 1 and obtain 8.\nStep 4) 8 is even, divide by 2 and obtain 4.&nbsp; \nStep 5) 4 is even, divide by 2 and obtain 2.&nbsp;\nStep 6) 2 is even, divide by 2 and obtain 1.&nbsp; \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;10&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> &quot;10&quot; corressponds to number 2 in their decimal representation.\nStep 1) 2 is even, divide by 2 and obtain 1.&nbsp; \n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 500</code></li>\n\t<li><code>s</code> consists of characters &#39;0&#39; or &#39;1&#39;</li>\n\t<li><code>s[0] == &#39;1&#39;</code></li>\n</ul>\n"},{"id":"1820603","title":"Delete and Earn","url":"/discuss/topic/1820603/house-robber","questionTitle":"Delete and Earn","post":{"creationDate":1646457622},"post_data":{"id":1820603,"title":"House Robber","solutionTags":[{"name":"C++"},{"name":"Dynamic Programming"}],"post":{"id":3118401,"content":"Notice that whichever number you choose to earn, you can earn all instances of that number and none of the number to the left or right.\nHence, we need to find the frequency or rather the total points possible for earning each number and then run a House Robber on that.\n\nHouse robber can be solved using DP. Here I have given two ways to solve it: using a DP array or using just two integer variables.\n\n```\nclass Solution {\npublic:\n    int rob_v1(vector<int> money)\n    {\n        int n=money.size();\n        if (n==1) return money[0];\n        vector<int> dp(n,0);\n        dp[0] = money[0]; dp[1] = max(money[0], money[1]);\n        for (int i=2; i<n; i++) dp[i] = max(dp[i-2]+money[i], dp[i-1]);\n        return dp[n-1];\n    }\n    \n    int rob_v2(vector<int>  money)\n    {\n        int n=money.size();\n        if (n==1) return money[0];\n        int a=money[0], b=max(money[0], money[1]), b_old;\n        for (int i=2; i<n; i++)\n        {\n            b_old = b;\n            b = max(a+money[i], b);\n            a = b_old;\n        }\n        return b;\n    }\n    int deleteAndEarn(vector<int>& nums) {\n        int maxNum = 10000;\n        vector<int> points(maxNum, 0);\n        for (int n: nums) points[n-1]+=n;\n        return rob_v2(points);\n    }\n};\n```","creationDate":1646457622}},"acRate":57.107857369382565,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"740","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"delete-and-earn","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given an integer array <code>nums</code>. You want to maximize the number of points you get by performing the following operation any number of times:</p>\n\n<ul>\n\t<li>Pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points. Afterwards, you must delete <b>every</b> element equal to <code>nums[i] - 1</code> and <strong>every</strong> element equal to <code>nums[i] + 1</code>.</li>\n</ul>\n\n<p>Return <em>the <strong>maximum number of points</strong> you can earn by applying the above operation some number of times</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,2]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> You can perform the following operations:\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].\n- Delete 2 to earn 2 points. nums = [].\nYou earn a total of 6 points.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,3,3,3,4]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> You can perform the following operations:\n- Delete a 3 to earn 3 points. All 2&#39;s and 4&#39;s are also deleted. nums = [3,3].\n- Delete a 3 again to earn 3 points. nums = [3].\n- Delete a 3 once more to earn 3 points. nums = [].\nYou earn a total of 9 points.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"},{"id":"1816829","title":"Arithmetic Slices","url":"/discuss/topic/1816829/faster-than-100-c-solutions-and-also-very-easy-to-understand","questionTitle":"Arithmetic Slices","post":{"creationDate":1646327700},"post_data":{"id":1816829,"title":"Faster than 100% C++ solutions and also very easy to understand","solutionTags":[{"name":"C++"}],"post":{"id":3112710,"content":"Given you have a arithmetic sequence (AS) of length 4 as in the example, you can quickly see that:\n- Number of AS of length 3 = (4-3+1)=2\n- Number of AS of length 4 = (4-4+1)=1\n\nHence, Number of AS = 2+1 = 3\n\nYou can extend this logic to this:\n**Given an AS of maximum length L, `total number of AS=1+2+3+..+L-2 = 1/2*(L-2)*(L-1)`**\n\nSo, what we need to do is as we traverse through the array, find out the AS (we keep moving the 2nd pointer till the AS is finished) and then calculate the total number of AS using above formula. \n\nNow for the fun part:\n\n```\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& nums) {\n        int n=nums.size(), i=0, res=0;\n        while (i<n-2)\n        {\n            int start=i;\n            while (i<n-2 && nums[i+1]-nums[i]==nums[i+2]-nums[i+1]) i++;\n            int L = i+2-start;\n            int num_subs = (L-2)*(L-1)/2;\n            res += num_subs;\n            i++;\n        }\n        return res;\n    }\n};\n```","creationDate":1646327700}},"acRate":65.08566845699565,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"413","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"arithmetic-slices","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>An integer array is called arithmetic if it consists of <strong>at least three elements</strong> and if the difference between any two consecutive elements is the same.</p>\n\n<ul>\n\t<li>For example, <code>[1,3,5,7,9]</code>, <code>[7,7,7,7]</code>, and <code>[3,-1,-5,-9]</code> are arithmetic sequences.</li>\n</ul>\n\n<p>Given an integer array <code>nums</code>, return <em>the number of arithmetic <strong>subarrays</strong> of</em> <code>nums</code>.</p>\n\n<p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n"},{"id":"1768336","title":"Check If a String Contains All Binary Codes of Size K","url":"/discuss/topic/1768336/hashset-2-solutions-on-and-onk","questionTitle":"Check If a String Contains All Binary Codes of Size K","post":{"creationDate":1644763363},"post_data":{"id":1768336,"title":"HashSet 2 solutions O(n) and O(nk)","solutionTags":[{"name":"C++"}],"post":{"id":3037180,"content":"# Sol1: HashSet of int: O(n)\n\n```\nclass Solution {\npublic:\n    bool hasAllCodes(string s, int k) {\n        unordered_set<int> S;\n        int curr = 0, n=s.size(), useful=(1<<(k-1))-1;\n        if (n<k) return false;\n        for (int i=0; i<k; i++) curr = curr*2 + (s[i]-\"0\");\n        S.insert(curr);\n        for (int i=k; i<n; i++)\n        {\n            curr = curr&useful;\n            curr = curr << 1;\n            curr = curr + (s[i]-\"0\");\n            S.insert(curr);\n        }\n        return S.size()==(1<<k);\n    }\n};\n```\n\n# Sol2: HashSet of string: O(nk)\n```\nclass Solution {\npublic:\n    bool hasAllCodes(string s, int k) {\n        unordered_set<string> S;\n        int n=s.size();\n        for (int i=0; i<n-k+1; i++) S.insert(string(s.begin()+i,s.begin()+i+k));\n        return S.size()==(1<<k);\n    }\n};\n```\n","creationDate":1644763363}},"acRate":56.63938656639387,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1461","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"check-if-a-string-contains-all-binary-codes-of-size-k","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Bit Manipulation","id":"VG9waWNUYWdOb2RlOjE5","slug":"bit-manipulation"},{"name":"Rolling Hash","id":"VG9waWNUYWdOb2RlOjU2NTk4","slug":"rolling-hash"},{"name":"Hash Function","id":"VG9waWNUYWdOb2RlOjYxMDY1","slug":"hash-function"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a binary string <code>s</code> and an integer <code>k</code>, return <code>true</code> <em>if every binary code of length</em> <code>k</code> <em>is a substring of</em> <code>s</code>. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;00110110&quot;, k = 2\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The binary codes of length 2 are &quot;00&quot;, &quot;01&quot;, &quot;10&quot; and &quot;11&quot;. They can be all found as substrings at indices 0, 1, 3 and 2 respectively.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0110&quot;, k = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The binary codes of length 1 are &quot;0&quot; and &quot;1&quot;, it is clear that both exist as a substring. \n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0110&quot;, k = 2\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The binary code &quot;00&quot; is of length 2 and does not exist in the array.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n\t<li><code>1 &lt;= k &lt;= 20</code></li>\n</ul>\n"},{"id":"1767153","title":"Subsets","url":"/discuss/topic/1767153/simple-iterative-solution","questionTitle":"Subsets","post":{"creationDate":1644728709},"post_data":{"id":1767153,"title":"Simple Iterative solution","solutionTags":[{"name":"C++"}],"post":{"id":3035273,"content":"- Start with `curr = [[]]`\n- Iterate over `nums`. At each iteration, double the size of subsets.\n- To do this just take all current elements of `curr`. Append last seen element `nums[i]` to these arrays and push them back to `curr`.\n```\n#define pb push_back\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> curr;\n        curr.pb({});\n        for (int n: nums)\n        {\n            int sz=curr.size();\n            for (int i=0; i<sz; i++){auto v = curr[i]; v.pb(n); curr.pb(v);}\n        }\n        return curr;\n    }\n};\n```","creationDate":1644728709}},"acRate":74.65478243973408,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"78","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"subsets","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Backtracking","id":"VG9waWNUYWdOb2RlOjE0","slug":"backtracking"},{"name":"Bit Manipulation","id":"VG9waWNUYWdOb2RlOjE5","slug":"bit-manipulation"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span> <em>(the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>All the numbers of&nbsp;<code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n"},{"id":"1762374","title":"Permutation in String","url":"/discuss/topic/1762374/sliding-window","questionTitle":"Permutation in String","post":{"creationDate":1644559117},"post_data":{"id":1762374,"title":"Sliding window","solutionTags":[{"name":"C++"}],"post":{"id":3027622,"content":"# Algorithm\n- Create an array of size 26 storing letter frequencis of  `s1`.\n- Similarly do it for `s2` but just upto `n1` where `n1=s1.size()`\n- Slide winow in `s2` and add the upcoming letter and subtract the outgoing letter\n- If the frequency table matches return True\n- Finally return false if it never matched\n\n\n```\nclass Solution {\npublic:\n    bool checkInclusion(string s1, string s2) {\n        int n1=s1.size(), n2=s2.size();\n        if (n1>n2) return false;\n        vector<int> v1(26,0), v2(26,0);\n        for (char ch: s1) v1[ch-\"a\"]++;\n        for (int i=0; i<n2; i++)\n        {\n            v2[s2[i]-\"a\"]++;\n            if (i>=n1) v2[s2[i-n1]-\"a\"]--;\n            if (v1==v2) return true;\n        }\n        return false;\n    }\n};\n```","creationDate":1644559117}},"acRate":44.40268481585232,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"567","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"permutation-in-string","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Sliding Window","id":"VG9waWNUYWdOb2RlOjU1ODIx","slug":"sliding-window"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given two strings <code>s1</code> and <code>s2</code>, return <code>true</code><em> if </em><code>s2</code><em> contains a permutation of </em><code>s1</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>In other words, return <code>true</code> if one of <code>s1</code>&#39;s permutations is the substring of <code>s2</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;ab&quot;, s2 = &quot;eidbaooo&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s2 contains one permutation of s1 (&quot;ba&quot;).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;ab&quot;, s2 = &quot;eidboaoo&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n</ul>\n"},{"id":"1762334","title":"Subarray Sum Equals K","url":"/discuss/topic/1762334/on-hashmap-cummulative-sum","questionTitle":"Subarray Sum Equals K","post":{"creationDate":1644558330},"post_data":{"id":1762334,"title":"O(N) HashMap cummulative sum","solutionTags":[{"name":"C++"}],"post":{"id":3027573,"content":"# Algorithm:\n- Maintain a HashMap of cummulative sum of array using variable `curr`\n- If you see that `curr-k` is in HashMap, add it to the count of contiguous subarrays\n- Add `curr` to the HashMap.\n\n```\n#define ll long long\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        int n=nums.size(), res=0; ll curr=0;\n        unordered_map<ll,int> H;\n        H[0] = 1; // At i=-1 we have seen 0\n        for (int i=0; i<n; i++)\n        {\n            curr+=nums[i];\n            if (H.count(curr-k)) res+=H[curr-k];\n            H[curr]++;\n        }\n        return res;\n    }\n};\n```","creationDate":1644558330}},"acRate":43.76598902219702,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"560","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"subarray-sum-equals-k","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Prefix Sum","id":"VG9waWNUYWdOb2RlOjYxMDY4","slug":"prefix-sum"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of subarrays whose sum equals to</em> <code>k</code>.</p>\n\n<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,1], k = 2\n<strong>Output:</strong> 2\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3], k = 3\n<strong>Output:</strong> 2\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n"},{"id":"1759029","title":"Valid Triangle Number","url":"/discuss/topic/1759029/on2-logn-binary-search-ac","questionTitle":"Valid Triangle Number","post":{"creationDate":1644437020},"post_data":{"id":1759029,"title":"O(N^2) log(N) Binary Search [AC]","solutionTags":[{"name":"C++"},{"name":"Binary Tree"}],"post":{"id":3022456,"content":"Firstly sort `nums`.\nNow chose 1st two sides of triangle in for loop. \nSay `a=nums[i], b=nums[j]` where `i<j`. \nFor the 3rd side of the triangle, check the lowest index where `a+b` or any number greater than that occurs in case `a+b` is absent. Call this index as `k`.\nThen, valid triangles can be with chosen `a`, `b` and  `c` can be chosen from index between indices `j` and `k`.\n\n\n```\nclass Solution {\npublic:\n    int triangleNumber(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int n=nums.size(), res=0;\n        for (int i=0; i<n; i++)\n        {\n            for (int j=i+1; j<n; j++)\n            {\n                auto it = lower_bound(nums.begin(), nums.end(), nums[i]+nums[j]);\n                int pos = it-nums.begin();\n                if (pos-j-1>0) res+=(pos-j-1);\n            }\n        }\n        return res;\n    }\n};\n```","creationDate":1644437020}},"acRate":50.494411797180746,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"611","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"valid-triangle-number","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"Binary Search","id":"VG9waWNUYWdOb2RlOjEx","slug":"binary-search"},{"name":"Greedy","id":"VG9waWNUYWdOb2RlOjE3","slug":"greedy"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an integer array <code>nums</code>, return <em>the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,3,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Valid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,2,3,4]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n"},{"id":"1750340","title":"Minimum Falling Path Sum","url":"/discuss/topic/1750340/dp-solution-very-straightforward-seam-carving","questionTitle":"Minimum Falling Path Sum","post":{"creationDate":1644162652},"post_data":{"id":1750340,"title":"DP Solution very straightforward | Seam Carving","solutionTags":[{"name":"Python"},{"name":"Dynamic Programming"}],"post":{"id":3008760,"content":"- Create a `dp` matrix of size (nxn)\n- Copy last row of `matrix` to last row of `dp`\n- Iteratively go up from `r=n-2` to `r=0`. For element `(r,c)` the expression we have is: `dp[r,c] = min(dp[r+1,c-1], dp[r+1,c], dp[r+1,c+1])`\n- For `c=0` and `c=n-1` take min of only two elements rather than 3. These are left and right edges\n- After reaching top row, check which element in top row is the minimum.\n- Done!\n\n\n```\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        vector<vector<int>> dp(n, vector<int>(n,0));\n        for (int c=0; c<n; c++) dp[n-1][c] = matrix[n-1][c];\n        for (int r=n-2; r>=0; r--)\n        {\n            for (int c=0; c<n; c++)\n            {\n                if (c==0) dp[r][c] = min(dp[r+1][c], dp[r+1][c+1]) + matrix[r][c];\n                else if (c==n-1) dp[r][c] = min(dp[r+1][c], dp[r+1][c-1]) + matrix[r][c];\n                else dp[r][c] = min(min(dp[r+1][c-1], dp[r+1][c]), dp[r+1][c+1]) + matrix[r][c];\n            }\n        }\n        int res=INT_MAX;\n        for (int c=0; c<n; c++) res = min(res, dp[0][c]);\n        return res;\n    }\n};\n```\n\nBTW, this algorithm is used in a smart image resizing method known as [Seam Carving](https://en.wikipedia.org/wiki/Seam_carving).","creationDate":1644162652}},"acRate":69.11278813753735,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"931","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"minimum-falling-path-sum","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an <code>n x n</code> array of integers <code>matrix</code>, return <em>the <strong>minimum sum</strong> of any <strong>falling path</strong> through</em> <code>matrix</code>.</p>\n\n<p>A <strong>falling path</strong> starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position <code>(row, col)</code> will be <code>(row + 1, col - 1)</code>, <code>(row + 1, col)</code>, or <code>(row + 1, col + 1)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/failing1-grid.jpg\" style=\"width: 499px; height: 500px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[2,1,3],[6,5,4],[7,8,9]]\n<strong>Output:</strong> 13\n<strong>Explanation:</strong> There are two falling paths with a minimum sum as shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/failing2-grid.jpg\" style=\"width: 164px; height: 365px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[-19,57],[-40,-5]]\n<strong>Output:</strong> -59\n<strong>Explanation:</strong> The falling path with a minimum sum is shown.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n"},{"id":"1747252","title":"Merge k Sorted Lists","url":"/discuss/topic/1747252/min-heap-solution","questionTitle":"Merge k Sorted Lists","post":{"creationDate":1644078281},"post_data":{"id":1747252,"title":"Min heap solution","solutionTags":[{"name":"Python"},{"name":"C"},{"name":"Heap (Priority Queue)"}],"post":{"id":3003531,"content":"Algorithm:\n- Create a min heap of the first item of each LL.\n- While min heap is not empty pop the top of heap and check which LL it is coming from.\n- Move ahead one step on that particular LL.\n- When heap is empty stop.\n\nC++ Version:\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n#define pi pair<int,int>\n#define mp make_pair\n\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) \n    {\n        int n=lists.size();\n        if (n==0) return NULL;\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\n        for (int i=0; i<n; i++)\n        {\n            auto list = lists[i];\n            if (list==NULL) continue;\n            pq.push(mp(list->val, i));\n            lists[i] = list->next;\n        }\n        ListNode *res = new ListNode;\n        ListNode *curr = res;\n        while (pq.size()>0)\n        {\n            pi p = pq.top();\n            pq.pop();\n            int val=p.first, idx=p.second;\n            curr->next = new ListNode(val);\n            curr = curr->next;\n            if (lists[idx] != NULL)\n            {\n                pq.push(mp(lists[idx]->val,idx));\n                lists[idx] = lists[idx]->next;                \n            }            \n        }\n        return res->next;\n    }\n};\n```\nPython version:\n```\nclass Solution:\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if lists is None or len(lists) == 0:\n            return None\n        lists = [lst for lst in lists if lst is not None]\n        import heapq\n        H = []\n        for i, lst in enumerate(lists):\n            heapq.heappush(H, (lst.val, i))\n            lst = lst.next\n        # print(H)\n        mylst = ListNode(None)\n        curr = mylst\n        while len(H) > 0:\n            # print(\"Heap\", H)\n            listval, listidx = heapq.heappop(H)\n            # print(listval, listidx)\n            curr.next = ListNode(listval)\n            if lists[listidx].next is not None:\n                lists[listidx] = lists[listidx].next\n                heapq.heappush(H, (lists[listidx].val, listidx))\n            curr = curr.next\n        return mylst.next\n```","creationDate":1644078281}},"acRate":48.932823286972074,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"23","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"merge-k-sorted-lists","topicTags":[{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Divide and Conquer","id":"VG9waWNUYWdOb2RlOjEy","slug":"divide-and-conquer"},{"name":"Heap (Priority Queue)","id":"VG9waWNUYWdOb2RlOjYxMDUw","slug":"heap-priority-queue"},{"name":"Merge Sort","id":"VG9waWNUYWdOb2RlOjYxMDUx","slug":"merge-sort"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>\n\n<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>Output:</strong> [1,1,2,3,4,4,5,6]\n<strong>Explanation:</strong> The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[]]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= lists[i][j] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li>\n\t<li>The sum of <code>lists[i].length</code> will not exceed <code>10<sup>4</sup></code>.</li>\n</ul>\n"},{"id":"1743683","title":"Contiguous Array","url":"/discuss/topic/1743683/well-explained-hashmap-concise-with-pseudocode","questionTitle":"Contiguous Array","post":{"creationDate":1643955881},"post_data":{"id":1743683,"title":"Well-explained HashMap concise with pseudocode","solutionTags":[{"name":"C"}],"post":{"id":2997601,"content":"The key idea is to track how many ones and zeros we have seen from the beginning at any point. Let us keep an array that stores how many 1s and 0s we have seen at any point.\nSo, we start with counter=0 at the left end and then we can keep increase counter when we see 1 and decrease when we see 0. \nSo, for `[1,0,0,1,1]`, this will be `[1,0,-1,0,1]`.\nNow at any index if we want to find which all previous indexes we can find answers with, the answer is all the numbers which have the same number in this array. However we only want the smallest index to find the longest subarray. So, we don\"t need to actully go through the array. We can do better! Let use a hash map to store the min index for the counter. \nRunning through the same example, we will have the following hashmap:\nThe hashmap contains the first index where you achieve any value:\n`H={1:0, 0:1, -1:2}`\n\nThe candidate answer at any index is `i-H[ctr]`.\n\nOne tiny issue is if you think about `H` we have in fact seen 0 even before starting going trough the array. So `H[0]` will always be -1. For example if we later see at `i=5` that `ctr=0` then the possible answer is `5-(-1)`\n\nSo, H will actually be:\n`H={0:-1, 1:0, , -1:2}`\n\nNow we are ready for coding it up:\n```\nclass Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        int ctr=0, res=0, n=nums.size();\n        unordered_map<int,int> H;\n        H[0]=-1;\n        for (int i=0; i<n; i++)\n        {\n            if (nums[i]==1) ctr++;\n            else ctr--;\n            if (H.count(ctr)) res = max(res, i-H[ctr]);\n            else H[ctr]=i;\n        }\n        return res;\n    }\n};\n```","creationDate":1643955881}},"acRate":46.83580383094872,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"525","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"contiguous-array","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Prefix Sum","id":"VG9waWNUYWdOb2RlOjYxMDY4","slug":"prefix-sum"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given a binary array <code>nums</code>, return <em>the maximum length of a contiguous subarray with an equal number of </em><code>0</code><em> and </em><code>1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,0]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n"},{"id":"1743094","title":"Max Area of Island","url":"/discuss/topic/1743094/dfs-solution","questionTitle":"Max Area of Island","post":{"creationDate":1643930023},"post_data":{"id":1743094,"title":"DFS solution","solutionTags":[{"name":"Python"},{"name":"C"},{"name":"Depth-First Search"}],"post":{"id":2996655,"content":"```\nclass Solution {\npublic:\n    int util(int r, int c, vector<vector<int>> &grid, int m, int n, unordered_set<int> &visited)\n    {\n        if (r<0 || r>=m || c<0 || c>=n) return 0;\n        if (visited.count(n*r+c)>0 || grid[r][c]==0) return 0;\n        visited.insert(n*r+c);\n        return 1 + util(r-1,c,grid,m,n,visited) + util(r+1,c,grid,m,n,visited) + \\\n                   util(r,c-1,grid,m,n,visited) + util(r,c+1,grid,m,n,visited);\n    }\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int m=grid.size(), n=grid[0].size(), res=0;\n        unordered_set<int> visited;\n        for (int r=0; r<m; r++)\n            for (int c=0; c<n; c++)\n                res = max(res, util(r,c,grid,m,n,visited));\n        return res;\n    }\n};\n```\n```\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        seen = set()\n        def util(r,c):\n            if r<0 or r>=m or c<0 or c>=n or (r,c) in seen or grid[r][c]==0:\n                return 0\n            seen.add((r,c))\n            return 1+util(r+1,c)+util(r-1,c)+util(r,c+1)+util(r,c-1)\n        return max([max([util(r,c) for c in range(n)]) for r in range(m)])\n```","creationDate":1643930023}},"acRate":71.77040702354812,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"695","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"max-area-of-island","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"},{"name":"Union Find","id":"VG9waWNUYWdOb2RlOjIz","slug":"union-find"},{"name":"Matrix","id":"VG9waWNUYWdOb2RlOjYxMDUz","slug":"matrix"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>&#39;s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>\n\n<p>The <strong>area</strong> of an island is the number of cells with a value <code>1</code> in the island.</p>\n\n<p>Return <em>the maximum <strong>area</strong> of an island in </em><code>grid</code>. If there is no island, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg\" style=\"width: 500px; height: 310px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The answer is not 11, because the island must be connected 4-directionally.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,0,0,0,0,0,0,0]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n"},{"id":"1743061","title":"4Sum II","url":"/discuss/topic/1743061/easy-on2-solution-using-hashmap","questionTitle":"4Sum II","post":{"creationDate":1643927949},"post_data":{"id":1743061,"title":"Easy O(N^2) solution using HashMap","solutionTags":[{"name":"Python"},{"name":"C"}],"post":{"id":2996602,"content":"Create a hashmap H of all possible sums of `nums1` and `nums2` in O(N^2) time.\nThen traverse `nums3`X`nums4` in O(N^2) time and each time check membership in H.\nEasy-peasy!\n\nC++ version:\n```\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        int n = nums1.size(), res=0;\n        unordered_map<int,int> H;\n        for (int n1: nums1) for (int n2: nums2) H[n1+n2]++;\n        for (int n3: nums3) for (int n4: nums4) if (H.count(-(n3+n4))) res+=H[-(n3+n4)];\n        return res;\n    }\n};\n```\nPython version:\n```\nclass Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        H = collections.defaultdict(int)\n        res = 0\n        for n1 in nums1:\n            for n2 in nums2:\n                H[n1+n2]+=1\n        for n3 in nums3:\n            for n4 in nums4:\n                if -(n3+n4) in H:\n                    res += H[-(n3+n4)]\n        return res\n```","creationDate":1643927949}},"acRate":57.235423753173954,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"454","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"4sum-ii","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j, k, l &lt; n</code></li>\n\t<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nThe two tuples are:\n1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>n == nums3.length</code></li>\n\t<li><code>n == nums4.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>-2<sup>28</sup> &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2<sup>28</sup></code></li>\n</ul>\n"},{"id":"1743013","title":"4Sum","url":"/discuss/topic/1743013/c-tle-vs-python-ac-issue","questionTitle":"4Sum","post":{"creationDate":1643925074},"post_data":{"id":1743013,"title":"C++ TLE vs Python AC issue","solutionTags":[],"post":{"id":2996537,"content":"I have noticed several times that I am getting TLE while solving a problem in C++. Then when I write the exact same algorithm in python I get an AC. This could be because LC allows more time for python. Does this mean anything? Is it better to switch to python for this reason?\n\nEvidence:\n[4-Sum](https://leetcode.com/problems/4sum) throws TLE in C++ for this:\n```\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n=nums.size();\n        vector<vector<int>> res;\n        for (int i=0; i<n; i++)\n        {\n            for (int j=i+1; j<n; j++)\n            {\n                unordered_set<int> S;\n                for (int k=j+1; k<n; k++)\n                {\n                    if (S.count(nums[k])) \n                    {\n                        vector<int>quad {nums[i],nums[j],nums[k],target-nums[i]-nums[j]-nums[k]};\n                        sort(quad.begin(),quad.end());\n                        if (find(res.begin(), res.end(), quad)==res.end()) res.push_back(quad);\n                    }\n                    S.insert(target-nums[i]-nums[j]-nums[k]);\n                }\n            }\n        }\n        return res;\n    }\n};\n```\nbut passes in python for this which is exactly the same.\n```\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        n = len(nums)\n        res = []\n        for i in range(n):\n            for j in range(i+1,n):\n                S = set()\n                for k in range(j+1,n):\n                    if nums[k] in S:\n                        quad = [nums[i],nums[j],nums[k],target-nums[i]-nums[j]-nums[k]]\n                        quad.sort()\n                        if quad not in res:\n                            res.append(quad)\n                    S.add(target-nums[i]-nums[j]-nums[k])\n        return res\n```","creationDate":1643925074}},"acRate":36.04422421890663,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"18","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"4sum","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"},{"name":"Sorting","id":"VG9waWNUYWdOb2RlOjYxMDQ5","slug":"sorting"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>\n\t<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>\n\t<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0\n<strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2], target = 8\n<strong>Output:</strong> [[2,2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n"},{"id":"1741322","title":"Seat Reservation Manager","url":"/discuss/topic/1741322/easy-min-heap-solution","questionTitle":"Seat Reservation Manager","post":{"creationDate":1643874882},"post_data":{"id":1741322,"title":"Easy min-heap solution","solutionTags":[{"name":"C"},{"name":"Heap (Priority Queue)"}],"post":{"id":2993829,"content":"Algorithm:\n- At the beginning keep increasing counter at each reservation\n- When someone does unreserve, then store their seat number in a min heap\n- For a new booking try to first book from the heap. If heap is empty then increase your counter and book at `seat_number=counter`.\n```\nclass SeatManager {\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int ctr=0;\npublic:\n    SeatManager(int n) {\n    }\n    \n    int reserve() {\n        if (pq.size()==0) return ++ctr;\n        int minAvailable = pq.top();\n        pq.pop();\n        return minAvailable;\n    }\n    \n    void unreserve(int seatNumber) {\n        pq.push(seatNumber);\n    }\n};\n\n```","creationDate":1643874882}},"acRate":65.41717049576783,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1845","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"seat-reservation-manager","topicTags":[{"name":"Design","id":"VG9waWNUYWdOb2RlOjI1","slug":"design"},{"name":"Heap (Priority Queue)","id":"VG9waWNUYWdOb2RlOjYxMDUw","slug":"heap-priority-queue"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>Design a system that manages the reservation state of <code>n</code> seats that are numbered from <code>1</code> to <code>n</code>.</p>\n\n<p>Implement the <code>SeatManager</code> class:</p>\n\n<ul>\n\t<li><code>SeatManager(int n)</code> Initializes a <code>SeatManager</code> object that will manage <code>n</code> seats numbered from <code>1</code> to <code>n</code>. All seats are initially available.</li>\n\t<li><code>int reserve()</code> Fetches the <strong>smallest-numbered</strong> unreserved seat, reserves it, and returns its number.</li>\n\t<li><code>void unreserve(int seatNumber)</code> Unreserves the seat with the given <code>seatNumber</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;SeatManager&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;unreserve&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;reserve&quot;, &quot;unreserve&quot;]\n[[5], [], [], [2], [], [], [], [], [5]]\n<strong>Output</strong>\n[null, 1, 2, null, 2, 3, 4, 5, null]\n\n<strong>Explanation</strong>\nSeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats.\nseatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1.\nseatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.\nseatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5].\nseatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.\nseatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3.\nseatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4.\nseatManager.reserve();    // The only available seat is seat 5, so return 5.\nseatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= seatNumber &lt;= n</code></li>\n\t<li>For each call to <code>reserve</code>, it is guaranteed that there will be at least one unreserved seat.</li>\n\t<li>For each call to <code>unreserve</code>, it is guaranteed that <code>seatNumber</code> will be reserved.</li>\n\t<li>At most <code>10<sup>5</sup></code> calls <strong>in total</strong> will be made to <code>reserve</code> and <code>unreserve</code>.</li>\n</ul>\n"},{"id":"1738772","title":"Find All Anagrams in a String","url":"/discuss/topic/1738772/simplest-solution-ever","questionTitle":"Find All Anagrams in a String","post":{"creationDate":1643790254},"post_data":{"id":1738772,"title":"Simplest solution ever","solutionTags":[{"name":"Python"},{"name":"C"}],"post":{"id":2989772,"content":"If we look at the frequency map of s or p, we know it is at max of length 26. So why not just match them? Beats 62% of all solutions in c++ with this simple logic.\nC++ Version:\n```\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int ns = s.size(), np = p.size();\n        if (ns<np) return {};\n        vector<int> H_s(26,0), H_p(26,0);\n        for (char ch: p) H_p[ch-\"a\"]++;\n        for (char ch: string(s.begin(),s.begin()+np)) H_s[ch-\"a\"]++;\n        vector<int> res;\n        if (H_s==H_p) res.push_back(0);\n        for (int i=1; i<=ns-np; i++)\n        {\n            char ch1 = s[i-1], ch2=s[i+np-1];\n            H_s[ch1-\"a\"]--;\n            H_s[ch2-\"a\"]++;\n            if (H_s==H_p) res.push_back(i);\n        }\n        return res;\n    }\n};\n```\nPython version: (python has a `collections.Counter` that you can use to get frrequency map without writing code)\n```\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n\t\tif len(s)<len(p) return []\n        H_p = collections.Counter(p)\n        H_s = collections.Counter(s[:len(p)])\n        res = []\n        if H_s==H_p:\n            res.append(0)\n        for i in range(1,len(s)-len(p)+1):\n            ch1, ch2 = s[i-1], s[i+len(p)-1]\n            H_s[ch1]-=1\n            H_s[ch2]+=1\n            if H_s==H_p:\n                res.append(i)\n        return res\n```\n\nComplexity: `O(26n)` or in other words `O(n)`","creationDate":1643790254}},"acRate":50.12613568248939,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"438","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"find-all-anagrams-in-a-string","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Sliding Window","id":"VG9waWNUYWdOb2RlOjU1ODIx","slug":"sliding-window"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given two strings <code>s</code> and <code>p</code>, return <em>an array of all the start indices of </em><code>p</code><em>&#39;s anagrams in </em><code>s</code>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;\n<strong>Output:</strong> [0,6]\n<strong>Explanation:</strong>\nThe substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.\nThe substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abab&quot;, p = &quot;ab&quot;\n<strong>Output:</strong> [0,1,2]\n<strong>Explanation:</strong>\nThe substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.\nThe substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.\nThe substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, p.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>p</code> consist of lowercase English letters.</li>\n</ul>\n"},{"id":"1737524","title":"Next Permutation","url":"/discuss/topic/1737524/well-explained-on-easy-to-understand-in-c","questionTitle":"Next Permutation","post":{"creationDate":1643744607},"post_data":{"id":1737524,"title":"Well-explained O(n) easy to understand in C++","solutionTags":[{"name":"C"}],"post":{"id":2987794,"content":"Steps:\n- Traverse through the array right to left, starting from `n-2` position (`n` is length of array)\n- If you find `a[i+1]>a[i]` stop.\n- If you reached `i=-1` means array is sorted in decreasing order. Reverse the whole array and return. Else follow next steps\n- Now remember that to the right of `i` we have decreasing sorted array (from `i+1` to `n-1`)\n- Reverse the array from `i+1` to `n-1` to make it increasing sorted.\n- Find the smallest number greater than `a[i]` in this portion and swap with `a[i]`. Remember there will always be at least one number greater than `a[i]` here because when you had stopped traversing, you had `a[i+1]>a[i]`, so at least that `a[i+1]` will still be there, but there still might be another more suitable candidate.\n- You are done!\n\nFor example\n```\nA = [9,8,4,8,6,4,3]\n```\nYou will stop at `i=2` because for the first time from right to left, `A[i+1]>A[i]`\nNow we see that we have a decreasing sorted array to the right of `i=2`: `[8,6,4,3]`. Reverse this part, so A now becomes:\n```\nA = [9,8,4,3,4,6,8]\n```\nNow traverse from `i=3` to end of array to find smallest number greater than `A[2]=4` and swap with `A[2]`. So we will have:\n```\nA=[9,8,6,3,4,4,8]\n```\nThis is indeed the correct answer.\n\nCoding it up:\n```\nclass Solution {\npublic:\n    void swap(int &a, int&b)\n    {\n        int t=a;\n        a=b;\n        b=t;\n    }\n    void nextPermutation(vector<int>& nums) {\n        if (nums.size()==1) return;\n        int n=nums.size(), i;\n        for (i=n-2; i>=0; i--)\n            if (nums[i+1]>nums[i]) break;\n        if (i==-1) {reverse(nums.begin(),nums.end()); return;}\n        sort(nums.begin()+i+1, nums.end());\n        int j;\n        for (j=i+1; j<n; j++) if (nums[j]>nums[i]) break;\n        swap(nums[i],nums[j]);\n        return;\n    }\n};\n```","creationDate":1643744607}},"acRate":37.418364293372754,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"31","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"next-permutation","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"}],"hasSolution":true,"hasVideoSolution":true,"content":"<p>A <strong>permutation</strong> of an array of integers is an arrangement of its members into a sequence or linear order.</p>\n\n<ul>\n\t<li>For example, for <code>arr = [1,2,3]</code>, the following are all the permutations of <code>arr</code>: <code>[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]</code>.</li>\n</ul>\n\n<p>The <strong>next permutation</strong> of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the <strong>next permutation</strong> of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p>\n\n<ul>\n\t<li>For example, the next permutation of <code>arr = [1,2,3]</code> is <code>[1,3,2]</code>.</li>\n\t<li>Similarly, the next permutation of <code>arr = [2,3,1]</code> is <code>[3,1,2]</code>.</li>\n\t<li>While the next permutation of <code>arr = [3,2,1]</code> is <code>[1,2,3]</code> because <code>[3,2,1]</code> does not have a lexicographical larger rearrangement.</li>\n</ul>\n\n<p>Given an array of integers <code>nums</code>, <em>find the next permutation of</em> <code>nums</code>.</p>\n\n<p>The replacement must be <strong><a href=\"http://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in place</a></strong> and use only constant extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [1,3,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,5]\n<strong>Output:</strong> [1,5,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n"},{"id":"1717626","title":"Maximum Good People Based on Statements","url":"/discuss/topic/1717626/cjavapython-detailed-easy-to-understand-bitmask","questionTitle":"Maximum Good People Based on Statements","post":{"creationDate":1643087645},"post_data":{"id":1717626,"title":"[C++,Java,Python] Detailed easy to understand bitmask","solutionTags":[{"name":"Java"},{"name":"Python"},{"name":"C"}],"post":{"id":2956127,"content":"# Algorithm\nWe have a `statements` matrix of size n by n made up of elements 0,1,2 where \n- `statements[i][j]=1` means `person i` thinks `person j` is good.\n- `statements[i][j]=0` means `person i` thinks `person j` is bad.\n- `statements[i][j]=2` means `person i` doesnt comment on `person j`.\n\nWe also have these conditions:\n- Good person speaks truth always\n- Bad person can say truth or lie\n\nWe want to assign either 1 (for good) and 0 (for bad) to all persons in `0,1,..n-1` such that the `statements` matrix is feasible.\n\n## Pseudocode\nNow let us write our pseudocode to validate an assignment:\n```\nFOR i in 0,..,n-1\n\tFOR j in 0,..,n-1\n\t\t\tIF person i is good AND person j \\u2260  statement of person i on person j\n\t\t\t\tRETURN False\nRETURN True\n```\nWe simply need to run this for all possible assignments and if the assignment is valid we count the number of ones. At the end we return the maximum number of ones out of all valid assignments.\n\n## Bitmask\nNow, to use bitmask, let us have some notation:\nWe have `2^n` ways of doing the assignment (each person can be either good or bad). Let us denote an assignment as a variable caleld `number` which is in the range `[0,2^n-1]`.  If ith digit from left is 1 then in our assignment person i is assigned good and if ith digit from left is 0 then in our assignment person i is assigned bad.\nFor example say n is 3. The we can have 0,1,2,3,4,5,6,7 as possible assignments.\n0 in binary is `000` so means all bad\n1 in binary is `001` so means (0,1) are bad and 2 is good\n5 in binary is `101` so means (0,2) are good, 1 is bad\nand so on.\n\nNow let us write some logic we are gonna use later:\n#### How do we find if in our assignment ith person is assigned good or bad?\nFor exampel say our assignment is 5 ie `101`. Then\n- `5 & 4 > 0` means person 0 is assigned 1 ie good\n- `5 & 2 == 0` means person 1 is assigned 0 ie bad\n- `5 & 1 > 0` means person 2 is assigned  1 ie good\n\nBasically it is just a way of iterating over the binary representation of the number.\n\nNow that we have all the pieces let us write the code:\n\n<iframe src=\"https://leetcode.com/playground/8LL9m5Nw/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\n\nTime complexity: O((n^2 )* (2^n))\nSpace complexity: O(1)\n\nThis solution beats 80% of the solutions in terms of runtime and beats 95% of solutions in terms of memory. Please upvote if you found this helpful.","creationDate":1643087645}},"acRate":49.279137660004494,"difficulty":"Hard","freqBar":null,"frontendQuestionId":"2151","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"maximum-good-people-based-on-statements","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Backtracking","id":"VG9waWNUYWdOb2RlOjE0","slug":"backtracking"},{"name":"Bit Manipulation","id":"VG9waWNUYWdOb2RlOjE5","slug":"bit-manipulation"},{"name":"Enumeration","id":"VG9waWNUYWdOb2RlOjYxMDY2","slug":"enumeration"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>There are two types of persons:</p>\n\n<ul>\n\t<li>The <strong>good person</strong>: The person who always tells the truth.</li>\n\t<li>The <strong>bad person</strong>: The person who might tell the truth and might lie.</li>\n</ul>\n\n<p>You are given a <strong>0-indexed</strong> 2D integer array <code>statements</code> of size <code>n x n</code> that represents the statements made by <code>n</code> people about each other. More specifically, <code>statements[i][j]</code> could be one of the following:</p>\n\n<ul>\n\t<li><code>0</code> which represents a statement made by person <code>i</code> that person <code>j</code> is a <strong>bad</strong> person.</li>\n\t<li><code>1</code> which represents a statement made by person <code>i</code> that person <code>j</code> is a <strong>good</strong> person.</li>\n\t<li><code>2</code> represents that <strong>no statement</strong> is made by person <code>i</code> about person <code>j</code>.</li>\n</ul>\n\n<p>Additionally, no person ever makes a statement about themselves. Formally, we have that <code>statements[i][i] = 2</code> for all <code>0 &lt;= i &lt; n</code>.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of people who can be <strong>good</strong> based on the statements made by the </em><code>n</code><em> people</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg\" style=\"width: 600px; height: 262px;\" />\n<pre>\n<strong>Input:</strong> statements = [[2,1,2],[1,2,2],[2,0,2]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Each person makes a single statement.\n- Person 0 states that person 1 is good.\n- Person 1 states that person 0 is good.\n- Person 2 states that person 1 is bad.\nLet&#39;s take person 2 as the key.\n- Assuming that person 2 is a good person:\n    - Based on the statement made by person 2, person 1 is a bad person.\n    - Now we know for sure that person 1 is bad and person 2 is good.\n    - Based on the statement made by person 1, and since person 1 is bad, they could be:\n        - telling the truth. There will be a contradiction in this case and this assumption is invalid.\n        - lying. In this case, person 0 is also a bad person and lied in their statement.\n    - <strong>Following that person 2 is a good person, there will be only one good person in the group</strong>.\n- Assuming that person 2 is a bad person:\n    - Based on the statement made by person 2, and since person 2 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.\n            - <strong>Following that person 2 is bad but told the truth, there will be no good persons in the group</strong>.\n        - lying. In this case person 1 is a good person.\n            - Since person 1 is a good person, person 0 is also a good person.\n            - <strong>Following that person 2 is bad and lied, there will be two good persons in the group</strong>.\nWe can see that at most 2 persons are good in the best case, so we return 2.\nNote that there is more than one way to arrive at this conclusion.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/15/logic2.jpg\" style=\"width: 600px; height: 262px;\" />\n<pre>\n<strong>Input:</strong> statements = [[2,0],[0,2]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Each person makes a single statement.\n- Person 0 states that person 1 is bad.\n- Person 1 states that person 0 is bad.\nLet&#39;s take person 0 as the key.\n- Assuming that person 0 is a good person:\n    - Based on the statement made by person 0, person 1 is a bad person and was lying.\n    - <strong>Following that person 0 is a good person, there will be only one good person in the group</strong>.\n- Assuming that person 0 is a bad person:\n    - Based on the statement made by person 0, and since person 0 is bad, they could be:\n        - telling the truth. Following this scenario, person 0 and 1 are both bad.\n            - <strong>Following that person 0 is bad but told the truth, there will be no good persons in the group</strong>.\n        - lying. In this case person 1 is a good person.\n            - <strong>Following that person 0 is bad and lied, there will be only one good person in the group</strong>.\nWe can see that at most, one person is good in the best case, so we return 1.\nNote that there is more than one way to arrive at this conclusion.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == statements.length == statements[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>statements[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n\t<li><code>statements[i][i] == 2</code></li>\n</ul>\n"},{"id":"1707414","title":"Add Binary","url":"/discuss/topic/1707414/serious-and-non-serious-solution","questionTitle":"Add Binary","post":{"creationDate":1642783947},"post_data":{"id":1707414,"title":"Serious and non-serious solution","solutionTags":[],"post":{"id":2939951,"content":"Serious solution:\n```\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        string res;\n        int i = a.size()-1, j = b.size()-1;\n        int carry = 0;\n        while (i>=0 && j>=0)\n        {\n            int sum = carry + (a[i]-\"0\") + (b[j]-\"0\");\n            res.push_back(\"0\"+sum%2);\n            carry = (sum>1)?1:0;\n            i--; j--;\n        }\n        while (i>=0)\n        {\n            int sum = carry + (a[i]-\"0\");\n            res.push_back(\"0\"+sum%2);\n            carry = (sum>1)?1:0;\n            i--;\n        }\n        while (j>=0)\n        {\n            int sum = carry + (b[j]-\"0\");\n            res.push_back(\"0\"+sum%2);\n            carry = (sum>1)?1:0;\n            j--;\n        }\n        if (carry==1) res.push_back(\"0\"+carry);\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\nIf you want to troll LC:\n```\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        return bin(int(a,2)+int(b,2))[2:]\n```","creationDate":1642783947}},"acRate":52.35356989962921,"difficulty":"Easy","freqBar":null,"frontendQuestionId":"67","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"add-binary","topicTags":[{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Bit Manipulation","id":"VG9waWNUYWdOb2RlOjE5","slug":"bit-manipulation"},{"name":"Simulation","id":"VG9waWNUYWdOb2RlOjYxMDU1","slug":"simulation"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given two binary strings <code>a</code> and <code>b</code>, return <em>their sum as a binary string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> a = \"11\", b = \"1\"\n<strong>Output:</strong> \"100\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> a = \"1010\", b = \"1011\"\n<strong>Output:</strong> \"10101\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> and <code>b</code> consist&nbsp;only of <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code> characters.</li>\n\t<li>Each string does not contain leading zeros except for the zero itself.</li>\n</ul>\n"},{"id":"1701129","title":"N-ary Tree Level Order Traversal","url":"/discuss/topic/1701129/easy-bfs-solution","questionTitle":"N-ary Tree Level Order Traversal","post":{"creationDate":1642562228},"post_data":{"id":1701129,"title":"Easy BFS solution","solutionTags":[],"post":{"id":2929881,"content":"We had this solution for Level order traversal in Binary Tree:\n```\nvoid helper(TreeNode *root, vector<vector<int>> &res, int level)\n{\n\tif (!root) return;\n\tif (res.size()==level) res.push_back({});\n\tres[level].push_back(root->val);\n\thelper(root->left, res, level+1);\n\thelper(root->right, res, level+1);\n}\nvector<vector<int>> levelOrder(TreeNode* root) \n{\n\tvector<vector<int>> res;\n\thelper(root, res, 0);\n\treturn res;\n}\n```\n\nWe can modify this for N-ary tree as:\n```\nvoid helper(Node *root, vector<vector<int>> &res, int level)\n{\n\tif (!root) return;\n\tif (res.size()==level) res.push_back({});\n\tres[level].push_back(root->val);\n\tfor (auto child: root->children) helper(child, res, level+1);\n}\nvector<vector<int>> levelOrder(Node* root) \n{\n\tvector<vector<int>> res;\n\thelper(root, res, 0);\n\treturn res;\n}\n```","creationDate":1642562228}},"acRate":70.66132753399026,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"429","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"n-ary-tree-level-order-traversal","topicTags":[{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Breadth-First Search","id":"VG9waWNUYWdOb2RlOjIy","slug":"breadth-first-search"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes&#39; values.</p>\n\n<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [[1],[3,2,4],[5,6]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\n\t<li>The total number of nodes is between <code>[0, 10<sup>4</sup>]</code></li>\n</ul>\n"},{"id":"1701064","title":"Linked List Cycle II","url":"/discuss/topic/1701064/an-easy-and-a-difficult-solution","questionTitle":"Linked List Cycle II","post":{"creationDate":1642559318},"post_data":{"id":1701064,"title":"An easy and a difficult solution","solutionTags":[],"post":{"id":2929773,"content":"Easy method is to use hashset and traverse. If you find an element already present in hashset, return it. \n```\nListNode *detectCycle(ListNode *head) {\n\tListNode *curr = head;\n\tunordered_set<ListNode *> S;\n\twhile (curr)\n\t{\n\t\tif (S.find(curr)!=S.end()) return curr;\n\t\tS.insert(curr);\n\t\tcurr = curr->next;\n\t}\n\treturn NULL;        \n}\n```\nO(n) time and O(n) space complexity.\n\nFor O(1) space solution, we can use fast and slow pointers. If we encounter NULL ever, means there was no cycle. If cycle is present the two pointers will meet. Then we again traverse both slow and start nodes till they meet and then return it:\n```\nListNode *detectCycle(ListNode *head) {\n\tif (!head || !head->next) return NULL;\n\tListNode *start=head, *slow=head, *fast=head;\n\twhile (fast->next && fast->next->next)\n\t{\n\t\tslow = slow->next;\n\t\tfast = fast->next->next;\n\t\tif (slow==fast)\n\t\t{\n\t\t\twhile (start!=slow)\n\t\t\t{\n\t\t\t\tslow = slow->next;\n\t\t\t\tstart = start->next;\n\t\t\t}\n\t\t\treturn start;\n\t\t}\n\t}\n\treturn NULL;\n}\n```","creationDate":1642559318}},"acRate":47.34921398780879,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"142","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"linked-list-cycle-ii","topicTags":[{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Linked List","id":"VG9waWNUYWdOb2RlOjc=","slug":"linked-list"},{"name":"Two Pointers","id":"VG9waWNUYWdOb2RlOjk=","slug":"two-pointers"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return </em><code>null</code>.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>\n\n<p><strong>Do not modify</strong> the linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 145px; width: 450px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> tail connects to node index 1\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 105px; width: 201px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> tail connects to node index 0\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 65px; width: 65px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> no cycle\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n"},{"id":"1672353","title":"House Robber III","url":"/discuss/topic/1672353/recursionmemoization-cpp-explained-with-intuitions-step-wise","questionTitle":"House Robber III","post":{"creationDate":1641536096},"post_data":{"id":1672353,"title":"Recursion+Memoization [cpp] Explained with intuitions step-wise","solutionTags":[{"name":"C++"},{"name":"Recursion"},{"name":"Memoization"}],"post":{"id":2883972,"content":"Let us start at the `root` node. Assume that `root->left` and `root->right` are both non-NULL and define the following:\n```\nTreeNode *L= root->left\nTreeNode *R = root->right\nTreeNode *LL = root->left->left\nTreeNode *LR= root->left->right\nTreeNode *RL = root->right->left\nTreeNode *RR= root->right->right\n```\nNow, the recursive relation is:\n```\nrob(root)=max(rob(L)+rob(R),  root->val+rob(LL)+rob(LR)+rob(RL)+rob(RR))\n```\nIf `root->left` is NULL, then we replace `rob(LL)+rob(LR)` with the value zero. Thus we have the following relation:\n```\nrob(root)=max(rob(R),  root->val+rob(RL)+rob(RR))\n```\nSimilarly if `root->right` is NULL, we have the following relation\n```\nrob(root)=max(rob(L),  root->val+rob(LL)+rob(LR))\n```\n\n\n# Vanilla recursion Method\n\n```\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        if (root==NULL) return 0;\n        TreeNode *l=root->left, *r=root->right, *ll, *lr, *rl, *rr;\n        if (l){ll=l->left; lr=l->right;}\n        if (r){rl=r->left; rr=r->right;}\n        int a = (l)?rob(ll)+rob(lr):0;\n        int b = (r)?rob(rl)+rob(rr):0;\n        return max(root->val+a+b, rob(l)+rob(r));\n    }\n};\n```\nThe logic is perfectly correct in above algorithm and passes for the two test cases given in description. However on submission it gives `TLE` for large tree.\n\n# Memoization\n\nNotice that in the vanilla method, we are calculating the value for each node multiple times. Hence we can do memoization to reduce complexity. The idea is to use an HashMap ie `unordered_map<TreeNode *, int>`. At each node we return from the HashMap if present else calculate the value and add to the HashMap and then return the same.\n\n\n\n```\nclass Solution {\npublic:\n    int helper(TreeNode *root, unordered_map<TreeNode *, int> &money)\n    {\n        if (root==NULL) return 0;\n        if (money.find(root)!=money.end()) return money[root];\n        TreeNode *l=root->left, *r=root->right, *ll, *lr, *rl, *rr;\n        if (l){ll=l->left; lr=l->right;}\n        if (r){rl=r->left; rr=r->right;}\n        int a = (l)?helper(ll,money)+helper(lr,money):0;\n        int b = (r)?helper(rl,money)+helper(rr,money):0;\n        return money[root]=max(root->val+a+b, helper(l,money)+helper(r,money));\n    }\n    int rob(TreeNode* root) {\n        unordered_map<TreeNode *, int> moneys;\n        return helper(root, moneys);\n    }\n};\n```\n\nTime complexity: O(n)\nSpace complexity: O(n)\n\nPlease upvote and comment if you found this useful.\n","creationDate":1641536096}},"acRate":53.93918241489045,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"337","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"house-robber-iii","topicTags":[{"name":"Dynamic Programming","id":"VG9waWNUYWdOb2RlOjEz","slug":"dynamic-programming"},{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Depth-First Search","id":"VG9waWNUYWdOb2RlOjIx","slug":"depth-first-search"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called <code>root</code>.</p>\n\n<p>Besides the <code>root</code>, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if <strong>two directly-linked houses were broken into on the same night</strong>.</p>\n\n<p>Given the <code>root</code> of the binary tree, return <em>the maximum amount of money the thief can rob <strong>without alerting the police</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg\" style=\"width: 277px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [3,2,3,null,3,null,1]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg\" style=\"width: 357px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [3,4,5,1,3,null,1]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> Maximum amount of money the thief can rob = 4 + 5 = 9.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n"},{"id":"1669813","title":"Construct Binary Tree from Preorder and Inorder Traversal","url":"/discuss/topic/1669813/two-easy-to-understand-recursive-solutions","questionTitle":"Construct Binary Tree from Preorder and Inorder Traversal","post":{"creationDate":1641440695},"post_data":{"id":1669813,"title":"Two easy to understand recursive solutions","solutionTags":[{"name":"C"}],"post":{"id":2879793,"content":"## Method-I:\n- We know the root is at `preorder[0]`. Find the index of this element in `inorder` array. Call this `rootIndex`.\n- In the `inorder` array, everything to the left of this element is in the left subtree and everything to the right is in the right subtree ie `inorder[:rootIndex]` is the inorder traversal of left subtree and `inorder[rootIndex+1:]` is the inorder traversal of the right subtree\n- Now we can know the size of the left subtree and the right subtree from the above arrays. So we use this to form the preorder traversals of left and right subtree ie `preorder[1:rootIndex+1]` is the preorder traversal of left subtree and `preorder[rootIndex+1:]` is the preorder traversal of the right subtree\n- Recursively form the tree using the above 4 arrays as left and right.\n\n```\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        if (preorder.size()==0||inorder.size()==0) return NULL;\n\n        int rootIndex=0;\n        while(inorder[rootIndex]!=preorder[0])  rootIndex++;\n        vector<int> pre_left(preorder.begin()+1, preorder.begin()+rootIndex+1);\n        vector<int> pre_right(preorder.begin()+rootIndex+1, preorder.end());\n        vector<int> in_left(inorder.begin(), inorder.begin()+rootIndex);\n        vector<int> in_right(inorder.begin()+rootIndex+1, inorder.end());\n\n        TreeNode *root = new TreeNode;\n        root->val = preorder[0];\n        root->left = buildTree(pre_left, in_left);\n        root->right = buildTree(pre_right, in_right);\n        return root;\n    }\n};\n```\n\n## Method -II\nThis is similar to the solution provided by Leetcode in java. I translated it in c++.\n\nBasically we do the same method as method-I in a different manner. \n\n- Create a `HashMap<int, int>` and Keep indices of `inorder` array in the form `value: index`. \n- Initialize `preOrderIndex` as 0.\n- Both these variables are class variables so that these can be changed during the function calls.\n- Now we know that root is present at `preorder[0]`. So create the node with this value. Note that since we have a `preOrderIndex` variable, we can increment it and get this value from preorder array.\n- Use the index map created earlier to find the index of this element in the `inorder` array.\n- We know that to the left of this in `inorder` is the left subtree and to the right is the right subtree. So recursively call with appropriate left and right limits of inorder array.\n\n```\nclass Solution {\n    int preOrderIndex;\n    unordered_map<int,int> inOrderIndexMap;\npublic:\n    TreeNode *helper(vector<int>preorder, int left, int right)\n    {\n        if (left>right) return NULL;\n        int rootVal = preorder[preOrderIndex];\n        preOrderIndex++;\n        int inOrderIndex = inOrderIndexMap[rootVal];\n        TreeNode *root = new TreeNode;\n        root->val = rootVal;\n        root->left = helper(preorder, left, inOrderIndex-1);\n        root->right = helper(preorder, inOrderIndex+1, right);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        preOrderIndex=0;\n        for(int i=0; i<inorder.size(); i++) inOrderIndexMap[inorder[i]]=i;\n        return helper(preorder, 0, preorder.size()-1);\n    }\n};\n```\n\nI  personally  think method-I is easier and is what I would come up with when asked this problem during an interview.","creationDate":1641440695}},"acRate":61.32002547132195,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"105","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"construct-binary-tree-from-preorder-and-inorder-traversal","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"Divide and Conquer","id":"VG9waWNUYWdOb2RlOjEy","slug":"divide-and-conquer"},{"name":"Tree","id":"VG9waWNUYWdOb2RlOjIw","slug":"tree"},{"name":"Binary Tree","id":"VG9waWNUYWdOb2RlOjYxMDU3","slug":"binary-tree"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> preorder = [-1], inorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>\n\t<li><code>inorder.length == preorder.length</code></li>\n\t<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>\n\t<li><code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.</li>\n\t<li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li>\n\t<li><code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</li>\n\t<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>\n</ul>\n"},{"id":"1653960","title":"Check if a Parentheses String Can Be Valid","url":"/discuss/topic/1653960/greedy-solution-with-easy-to-understand-intuition-cpython","questionTitle":"Check if a Parentheses String Can Be Valid","post":{"creationDate":1640752796},"post_data":{"id":1653960,"title":"Greedy Solution with easy to understand intuition [C++,Python]","solutionTags":[{"name":"Python"},{"name":"C"}],"post":{"id":2853220,"content":"Suppose there were no `locked` string and we need to only check if a given string is valid or not then we can do the following logic for forward:\n```\nint bal=0, n=s.size();\nfor (int i=0; i<n; i++)\n{\n\tif (s[i]==\"(\") bal++;\n\telse bal--;\n\tif (bal<0) return false;\n}\nreturn true;\n```\nAbove code checks orphan `)`. Now the following for backward  checks orphan `(`:\n```\nint bal = 0;\nfor (int i=n-1; i>=0; i--)\n{\n\tif (s[i]==\")\") bal++;\n\telse bal--;\n\tif (bal<0) return false;\n}\nreturn true;\n```\n\nTogether we can use both to check valid string:\n```\nbool isValid(string s) {\n\tif (s.size()%2==1) return false;\n\tint bal=0, n=s.size();\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tif (s[i]==\"(\" ) bal++;\n\t\telse bal--;\n\t\tif (bal<0) return false;\n\t}\n\tbal = 0;\n\tfor (int i=n-1; i>=0; i--)\n\t{\n\t\tif (s[i]==\")\") bal++;\n\t\telse bal--;\n\t\tif (bal<0) return false;\n\t}\n\treturn true;\n}\n```\n\nNow to solve our `canBeValid` problem we just need to add an extra condition as OR to allow one of the non-locked bracket to be inverted.\nC++:\n```\nclass Solution {\npublic:\n    bool canBeValid(string s, string locked) {\n        if (s.size()%2==1) return false;\n        int bal=0, n=s.size();\n        for (int i=0; i<n; i++)\n        {\n            if (s[i]==\"(\" || locked[i]==\"0\") bal++;\n            else bal--;\n            if (bal<0) return false;\n        }\n        bal = 0;\n        for (int i=n-1; i>=0; i--)\n        {\n            if (s[i]==\")\" || locked[i]==\"0\") bal++;\n            else bal--;\n            if (bal<0) return false;\n        }\n        return true;\n    }\n};\n```\nPython:\n```\nclass Solution:\n    def canBeValid(self, s: str, locked: str) -> bool:\n        if len(s)%2==1: return False\n        bal = 0\n        for ch, lock in zip(s, locked):\n            if lock == \"0\" or ch == \"(\": bal += 1\n            else: bal -= 1\n            if bal < 0: return False \n        bal = 0\n        for ch, lock in zip(reversed(s), reversed(locked)): \n            if lock == \"0\" or ch == \")\": bal += 1\n            else: bal -= 1\n            if bal < 0: return False\n        return True\n```","creationDate":1640752796}},"acRate":31.093040447776954,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"2116","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"check-if-a-parentheses-string-can-be-valid","topicTags":[{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Stack","id":"VG9waWNUYWdOb2RlOjE1","slug":"stack"},{"name":"Greedy","id":"VG9waWNUYWdOb2RlOjE3","slug":"greedy"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>A parentheses string is a <strong>non-empty</strong> string consisting only of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>. It is valid if <strong>any</strong> of the following conditions is <strong>true</strong>:</p>\n\n<ul>\n\t<li>It is <code>()</code>.</li>\n\t<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid parentheses strings.</li>\n\t<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid parentheses string.</li>\n</ul>\n\n<p>You are given a parentheses string <code>s</code> and a string <code>locked</code>, both of length <code>n</code>. <code>locked</code> is a binary string consisting only of <code>&#39;0&#39;</code>s and <code>&#39;1&#39;</code>s. For <strong>each</strong> index <code>i</code> of <code>locked</code>,</p>\n\n<ul>\n\t<li>If <code>locked[i]</code> is <code>&#39;1&#39;</code>, you <strong>cannot</strong> change <code>s[i]</code>.</li>\n\t<li>But if <code>locked[i]</code> is <code>&#39;0&#39;</code>, you <strong>can</strong> change <code>s[i]</code> to either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if you can make <code>s</code> a valid parentheses string</em>. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/eg1.png\" style=\"width: 311px; height: 101px;\" />\n<pre>\n<strong>Input:</strong> s = &quot;))()))&quot;, locked = &quot;010100&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> locked[1] == &#39;1&#39; and locked[3] == &#39;1&#39;, so we cannot change s[1] or s[3].\nWe change s[0] and s[4] to &#39;(&#39; while leaving s[2] and s[5] unchanged to make s valid.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()()&quot;, locked = &quot;0000&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We do not need to make any changes because s is already valid.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;)&quot;, locked = &quot;0&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> locked permits us to change s[0]. \nChanging s[0] to either &#39;(&#39; or &#39;)&#39; will not make s valid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == s.length == locked.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.</li>\n\t<li><code>locked[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n"},{"id":"1653908","title":"Find All Possible Recipes from Given Supplies","url":"/discuss/topic/1653908/two-ways-to-do-topological-sort","questionTitle":"Find All Possible Recipes from Given Supplies","post":{"creationDate":1640750796},"post_data":{"id":1653908,"title":"Two ways to do topological sort","solutionTags":[{"name":"Python"},{"name":"C"},{"name":"Topological Sort"}],"post":{"id":2853137,"content":"The first is the standard Kahn\"s Algorithm:\nPseudocode:\n- Construct adjacency list graph and inDegrees array\n- Create two arrays S and L both empty initially\n- Put all nodes of `supplies` in S\n- While S is not empty \n\t- Pop a node from S and insert in L\n\t- Traverse through adjacency list of this node and for each destination node in this adjacency list:\n\t  - Decrement `inDegree` of this destination node. This is equivalent to breaking an edge\n\t  - if `InDegree` is 0 then insert it into S\n\nNotice that at any point in the pseudocode, S consists of only nodes with zero `inDegree`.\n\n<iframe src=\"https://leetcode.com/playground/8NcX3sbt/shared\" frameBorder=\"0\" width=\"1000\" height=\"800\"></iframe>\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\nThe second is a cheat way to do topological sort in `O(n^2)` worse case time  complexity (You just keep traversing through the graph again and again till no new node is found). This should throw TLE in a proper contest/interview but surprisingly for me passed all the tests.\n<iframe src=\"https://leetcode.com/playground/Eyhyenv8/shared\" frameBorder=\"0\" width=\"1000\" height=\"400\"></iframe>","creationDate":1640750796}},"acRate":48.55112083105522,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"2115","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"find-all-possible-recipes-from-given-supplies","topicTags":[{"name":"Array","id":"VG9waWNUYWdOb2RlOjU=","slug":"array"},{"name":"Hash Table","id":"VG9waWNUYWdOb2RlOjY=","slug":"hash-table"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Graph","id":"VG9waWNUYWdOb2RlOjI0","slug":"graph"},{"name":"Topological Sort","id":"VG9waWNUYWdOb2RlOjI2","slug":"topological-sort"}],"hasSolution":false,"hasVideoSolution":false,"content":"<p>You have information about <code>n</code> different recipes. You are given a string array <code>recipes</code> and a 2D string array <code>ingredients</code>. The <code>i<sup>th</sup></code> recipe has the name <code>recipes[i]</code>, and you can <strong>create</strong> it if you have <strong>all</strong> the needed ingredients from <code>ingredients[i]</code>. Ingredients to a recipe may need to be created from <strong>other </strong>recipes, i.e., <code>ingredients[i]</code> may contain a string that is in <code>recipes</code>.</p>\n\n<p>You are also given a string array <code>supplies</code> containing all the ingredients that you initially have, and you have an infinite supply of all of them.</p>\n\n<p>Return <em>a list of all the recipes that you can create. </em>You may return the answer in <strong>any order</strong>.</p>\n\n<p>Note that two recipes may contain each other in their ingredients.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> recipes = [&quot;bread&quot;], ingredients = [[&quot;yeast&quot;,&quot;flour&quot;]], supplies = [&quot;yeast&quot;,&quot;flour&quot;,&quot;corn&quot;]\n<strong>Output:</strong> [&quot;bread&quot;]\n<strong>Explanation:</strong>\nWe can create &quot;bread&quot; since we have the ingredients &quot;yeast&quot; and &quot;flour&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> recipes = [&quot;bread&quot;,&quot;sandwich&quot;], ingredients = [[&quot;yeast&quot;,&quot;flour&quot;],[&quot;bread&quot;,&quot;meat&quot;]], supplies = [&quot;yeast&quot;,&quot;flour&quot;,&quot;meat&quot;]\n<strong>Output:</strong> [&quot;bread&quot;,&quot;sandwich&quot;]\n<strong>Explanation:</strong>\nWe can create &quot;bread&quot; since we have the ingredients &quot;yeast&quot; and &quot;flour&quot;.\nWe can create &quot;sandwich&quot; since we have the ingredient &quot;meat&quot; and can create the ingredient &quot;bread&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> recipes = [&quot;bread&quot;,&quot;sandwich&quot;,&quot;burger&quot;], ingredients = [[&quot;yeast&quot;,&quot;flour&quot;],[&quot;bread&quot;,&quot;meat&quot;],[&quot;sandwich&quot;,&quot;meat&quot;,&quot;bread&quot;]], supplies = [&quot;yeast&quot;,&quot;flour&quot;,&quot;meat&quot;]\n<strong>Output:</strong> [&quot;bread&quot;,&quot;sandwich&quot;,&quot;burger&quot;]\n<strong>Explanation:</strong>\nWe can create &quot;bread&quot; since we have the ingredients &quot;yeast&quot; and &quot;flour&quot;.\nWe can create &quot;sandwich&quot; since we have the ingredient &quot;meat&quot; and can create the ingredient &quot;bread&quot;.\nWe can create &quot;burger&quot; since we have the ingredient &quot;meat&quot; and can create the ingredients &quot;bread&quot; and &quot;sandwich&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == recipes.length == ingredients.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= ingredients[i].length, supplies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= recipes[i].length, ingredients[i][j].length, supplies[k].length &lt;= 10</code></li>\n\t<li><code>recipes[i], ingredients[i][j]</code>, and <code>supplies[k]</code> consist only of lowercase English letters.</li>\n\t<li>All the values of <code>recipes</code> and <code>supplies</code>&nbsp;combined are unique.</li>\n\t<li>Each <code>ingredients[i]</code> does not contain any duplicate values.</li>\n</ul>\n"},{"id":"1620979","title":"Robot Bounded In Circle","url":"/discuss/topic/1620979/c-basic-solution","questionTitle":"Robot Bounded In Circle","post":{"creationDate":1639115779},"post_data":{"id":1620979,"title":"C++ Basic solution","solutionTags":[],"post":{"id":2800324,"content":"After little bit of experimenting on paper, one can realize that the only situation that it does not land up at origin is if we do not end up on origin after one round and are also facing north.\nThe other two cases are:\n- Ending up on origin: Obviously it is `true`\n- Not ending up on origin but facing South/East/West: This is also true because after 2 rounds(South) or 4 rounds(East/West), we will again land at origin.\n\nNow for implementation, we will use three variables:\n- `a` for x-coordinate\n- `b` for y-coordinate\n- `c` for direction\n\nAll 3 are integers. One important thing to notice is that we can use `c` variable for direction as follows:\n- If you see \"L\",  increment c by 1\n- If you see \"R\", increment c by 3\n- If you see \"G\", do not change c\n\nFurther we can check which direction we are facing:\n- `c%4=0` means North\n- `c%4=1` means West\n- `c%4=2` means South\n- `c%4=3` means East\n\n\nNow the logic is that:\n- If you see G, find out which direction you are facing and modify the coordinates accordingly. This will change either a or b.\n- If you see L or R, change the variable c as per rule given above. Variables a and b do not change in this case.\n\n```\nclass Solution {\npublic:\n    bool isRobotBounded(string instructions) {\n        int a=0,b=0,c=0;\n        for(char ch: instructions)\n        {\n            if(ch==\"G\")\n            {\n                if(c%4==0)b++;\n                if(c%4==1)a--;\n                if(c%4==2)b--;\n                if(c%4==3)a++;\n            }\n            if(ch==\"L\") c++;\n            if(ch==\"R\") c+=3;\n        }\n        cout << a << \" \" << b << \" \" << c << endl;\n        if(c%4==0 && (a!=0 || b!=0)) return false;\n        return true;\n    }\n};\n```","creationDate":1639115779}},"acRate":55.30143479443144,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"1041","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"robot-bounded-in-circle","topicTags":[{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"String","id":"VG9waWNUYWdOb2RlOjEw","slug":"string"},{"name":"Simulation","id":"VG9waWNUYWdOb2RlOjYxMDU1","slug":"simulation"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>On an infinite plane, a robot initially stands at <code>(0, 0)</code> and faces north. Note that:</p>\n\n<ul>\n\t<li>The <strong>north direction</strong> is the positive direction of the y-axis.</li>\n\t<li>The <strong>south direction</strong> is the negative direction of the y-axis.</li>\n\t<li>The <strong>east direction</strong> is the positive direction of the x-axis.</li>\n\t<li>The <strong>west direction</strong> is the negative direction of the x-axis.</li>\n</ul>\n\n<p>The robot can receive one of three instructions:</p>\n\n<ul>\n\t<li><code>&quot;G&quot;</code>: go straight 1 unit.</li>\n\t<li><code>&quot;L&quot;</code>: turn 90 degrees to the left (i.e., anti-clockwise direction).</li>\n\t<li><code>&quot;R&quot;</code>: turn 90 degrees to the right (i.e., clockwise direction).</li>\n</ul>\n\n<p>The robot performs the <code>instructions</code> given in order, and repeats them forever.</p>\n\n<p>Return <code>true</code> if and only if there exists a circle in the plane such that the robot never leaves the circle.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> instructions = &quot;GGLLGG&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The robot is initially at (0, 0) facing the north direction.\n&quot;G&quot;: move one step. Position: (0, 1). Direction: North.\n&quot;G&quot;: move one step. Position: (0, 2). Direction: North.\n&quot;L&quot;: turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West.\n&quot;L&quot;: turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South.\n&quot;G&quot;: move one step. Position: (0, 1). Direction: South.\n&quot;G&quot;: move one step. Position: (0, 0). Direction: South.\nRepeating the instructions, the robot goes into the cycle: (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 1) --&gt; (0, 0).\nBased on that, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> instructions = &quot;GG&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The robot is initially at (0, 0) facing the north direction.\n&quot;G&quot;: move one step. Position: (0, 1). Direction: North.\n&quot;G&quot;: move one step. Position: (0, 2). Direction: North.\nRepeating the instructions, keeps advancing in the north direction and does not go into cycles.\nBased on that, we return false.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> instructions = &quot;GL&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The robot is initially at (0, 0) facing the north direction.\n&quot;G&quot;: move one step. Position: (0, 1). Direction: North.\n&quot;L&quot;: turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West.\n&quot;G&quot;: move one step. Position: (-1, 1). Direction: West.\n&quot;L&quot;: turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South.\n&quot;G&quot;: move one step. Position: (-1, 0). Direction: South.\n&quot;L&quot;: turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East.\n&quot;G&quot;: move one step. Position: (0, 0). Direction: East.\n&quot;L&quot;: turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North.\nRepeating the instructions, the robot goes into the cycle: (0, 0) --&gt; (0, 1) --&gt; (-1, 1) --&gt; (-1, 0) --&gt; (0, 0).\nBased on that, we return true.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= instructions.length &lt;= 100</code></li>\n\t<li><code>instructions[i]</code> is <code>&#39;G&#39;</code>, <code>&#39;L&#39;</code> or, <code>&#39;R&#39;</code>.</li>\n</ul>\n"},{"id":"1319275","title":"Gray Code","url":"/discuss/topic/1319275/python-easy-to-understand-3-line-recursive-solution","questionTitle":"Gray Code","post":{"creationDate":1625551249},"post_data":{"id":1319275,"title":"Python easy to understand 3 line recursive solution","solutionTags":[],"post":{"id":2322304,"content":"We see the pattern:\n```\n1: [0,1]\n2: [00,01,11,10]\n3: [000,001,011,010,110,111,101,100]\n```\nNotice the following recursive relation:\n```\ngrayCode(n) = [grayCode(n-1), new_part]\n```\n`new_part` consists of `1` added to the left of each item in reversed sequence of `grayCode(n-1)`.\n\nThis leads us to the following code:\n```python\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        if n==1: return [0,1]\n        prev = self.grayCode(n-1)\n        return prev + [2**(n-1)+i for i in prev[::-1]]\n```\nTime complexity: `O(n)`.","creationDate":1625551249}},"acRate":56.98085220245193,"difficulty":"Medium","freqBar":null,"frontendQuestionId":"89","isFavor":false,"paidOnly":false,"status":null,"titleSlug":"gray-code","topicTags":[{"name":"Math","id":"VG9waWNUYWdOb2RlOjg=","slug":"math"},{"name":"Backtracking","id":"VG9waWNUYWdOb2RlOjE0","slug":"backtracking"},{"name":"Bit Manipulation","id":"VG9waWNUYWdOb2RlOjE5","slug":"bit-manipulation"}],"hasSolution":true,"hasVideoSolution":false,"content":"<p>An <strong>n-bit gray code sequence</strong> is a sequence of <code>2<sup>n</sup></code> integers where:</p>\n\n<ul>\n\t<li>Every integer is in the <strong>inclusive</strong> range <code>[0, 2<sup>n</sup> - 1]</code>,</li>\n\t<li>The first integer is <code>0</code>,</li>\n\t<li>An integer appears <strong>no more than once</strong> in the sequence,</li>\n\t<li>The binary representation of every pair of <strong>adjacent</strong> integers differs by <strong>exactly one bit</strong>, and</li>\n\t<li>The binary representation of the <strong>first</strong> and <strong>last</strong> integers differs by <strong>exactly one bit</strong>.</li>\n</ul>\n\n<p>Given an integer <code>n</code>, return <em>any valid <strong>n-bit gray code sequence</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> [0,1,3,2]\n<strong>Explanation:</strong>\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 0<u>0</u> and 0<u>1</u> differ by one bit\n- <u>0</u>1 and <u>1</u>1 differ by one bit\n- 1<u>1</u> and 1<u>0</u> differ by one bit\n- <u>1</u>0 and <u>0</u>0 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- <u>0</u>0 and <u>1</u>0 differ by one bit\n- 1<u>0</u> and 1<u>1</u> differ by one bit\n- <u>1</u>1 and <u>0</u>1 differ by one bit\n- 0<u>1</u> and 0<u>0</u> differ by one bit\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n</ul>\n"}]